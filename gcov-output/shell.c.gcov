        -:    0:Source:shell.c
        -:    0:Graph:sqlite3-shell.gcno
        -:    0:Data:sqlite3-shell.gcda
        -:    0:Runs:2
        -:    1:/* DO NOT EDIT!
        -:    2:** This file is automatically generated by the script in the canonical
        -:    3:** SQLite source tree at tool/mkshellc.tcl.  That script combines source
        -:    4:** code from various constituent source files of SQLite into this single
        -:    5:** "shell.c" file used to implement the SQLite command-line shell.
        -:    6:**
        -:    7:** Most of the code found below comes from the "src/shell.c.in" file in
        -:    8:** the canonical SQLite source tree.  That main file contains "INCLUDE"
        -:    9:** lines that specify other files in the canonical source tree that are
        -:   10:** inserted to getnerate this complete program source file.
        -:   11:**
        -:   12:** The code from multiple files is combined into this single "shell.c"
        -:   13:** source file to help make the command-line program easier to compile.
        -:   14:**
        -:   15:** To modify this program, get a copy of the canonical SQLite source tree,
        -:   16:** edit the src/shell.c.in" and/or some of the other files that are included
        -:   17:** by "src/shell.c.in", then rerun the tool/mkshellc.tcl script.
        -:   18:*/
        -:   19:/*
        -:   20:** 2001 September 15
        -:   21:**
        -:   22:** The author disclaims copyright to this source code.  In place of
        -:   23:** a legal notice, here is a blessing:
        -:   24:**
        -:   25:**    May you do good and not evil.
        -:   26:**    May you find forgiveness for yourself and forgive others.
        -:   27:**    May you share freely, never taking more than you give.
        -:   28:**
        -:   29:*************************************************************************
        -:   30:** This file contains code to implement the "sqlite" command line
        -:   31:** utility for accessing SQLite databases.
        -:   32:*/
        -:   33:#if (defined(_WIN32) || defined(WIN32)) && !defined(_CRT_SECURE_NO_WARNINGS)
        -:   34:/* This needs to come before any includes for MSVC compiler */
        -:   35:#define _CRT_SECURE_NO_WARNINGS
        -:   36:#endif
        -:   37:
        -:   38:/*
        -:   39:** Warning pragmas copied from msvc.h in the core.
        -:   40:*/
        -:   41:#if defined(_MSC_VER)
        -:   42:#pragma warning(disable : 4054)
        -:   43:#pragma warning(disable : 4055)
        -:   44:#pragma warning(disable : 4100)
        -:   45:#pragma warning(disable : 4127)
        -:   46:#pragma warning(disable : 4130)
        -:   47:#pragma warning(disable : 4152)
        -:   48:#pragma warning(disable : 4189)
        -:   49:#pragma warning(disable : 4206)
        -:   50:#pragma warning(disable : 4210)
        -:   51:#pragma warning(disable : 4232)
        -:   52:#pragma warning(disable : 4244)
        -:   53:#pragma warning(disable : 4305)
        -:   54:#pragma warning(disable : 4306)
        -:   55:#pragma warning(disable : 4702)
        -:   56:#pragma warning(disable : 4706)
        -:   57:#endif /* defined(_MSC_VER) */
        -:   58:
        -:   59:/*
        -:   60:** No support for loadable extensions in VxWorks.
        -:   61:*/
        -:   62:#if (defined(__RTP__) || defined(_WRS_KERNEL)) && !SQLITE_OMIT_LOAD_EXTENSION
        -:   63:# define SQLITE_OMIT_LOAD_EXTENSION 1
        -:   64:#endif
        -:   65:
        -:   66:/*
        -:   67:** Enable large-file support for fopen() and friends on unix.
        -:   68:*/
        -:   69:#ifndef SQLITE_DISABLE_LFS
        -:   70:# define _LARGE_FILE       1
        -:   71:# ifndef _FILE_OFFSET_BITS
        -:   72:#   define _FILE_OFFSET_BITS 64
        -:   73:# endif
        -:   74:# define _LARGEFILE_SOURCE 1
        -:   75:#endif
        -:   76:
        -:   77:#include <stdlib.h>
        -:   78:#include <string.h>
        -:   79:#include <stdio.h>
        -:   80:#include <assert.h>
        -:   81:#include "sqlite3.h"
        -:   82:typedef sqlite3_int64 i64;
        -:   83:typedef sqlite3_uint64 u64;
        -:   84:typedef unsigned char u8;
        -:   85:#if SQLITE_USER_AUTHENTICATION
        -:   86:# include "sqlite3userauth.h"
        -:   87:#endif
        -:   88:#include <ctype.h>
        -:   89:#include <stdarg.h>
        -:   90:
        -:   91:#if !defined(_WIN32) && !defined(WIN32)
        -:   92:# include <signal.h>
        -:   93:# if !defined(__RTP__) && !defined(_WRS_KERNEL)
        -:   94:#  include <pwd.h>
        -:   95:# endif
        -:   96:#endif
        -:   97:#if (!defined(_WIN32) && !defined(WIN32)) || defined(__MINGW32__)
        -:   98:# include <unistd.h>
        -:   99:# include <dirent.h>
        -:  100:# define GETPID getpid
        -:  101:# if defined(__MINGW32__)
        -:  102:#  define DIRENT dirent
        -:  103:#  ifndef S_ISLNK
        -:  104:#   define S_ISLNK(mode) (0)
        -:  105:#  endif
        -:  106:# endif
        -:  107:#else
        -:  108:# define GETPID (int)GetCurrentProcessId
        -:  109:#endif
        -:  110:#include <sys/types.h>
        -:  111:#include <sys/stat.h>
        -:  112:
        -:  113:#if HAVE_READLINE
        -:  114:# include <readline/readline.h>
        -:  115:# include <readline/history.h>
        -:  116:#endif
        -:  117:
        -:  118:#if HAVE_EDITLINE
        -:  119:# include <editline/readline.h>
        -:  120:#endif
        -:  121:
        -:  122:#if HAVE_EDITLINE || HAVE_READLINE
        -:  123:
        -:  124:# define shell_add_history(X) add_history(X)
        -:  125:# define shell_read_history(X) read_history(X)
        -:  126:# define shell_write_history(X) write_history(X)
        -:  127:# define shell_stifle_history(X) stifle_history(X)
        -:  128:# define shell_readline(X) readline(X)
        -:  129:
        -:  130:#elif HAVE_LINENOISE
        -:  131:
        -:  132:# include "linenoise.h"
        -:  133:# define shell_add_history(X) linenoiseHistoryAdd(X)
        -:  134:# define shell_read_history(X) linenoiseHistoryLoad(X)
        -:  135:# define shell_write_history(X) linenoiseHistorySave(X)
        -:  136:# define shell_stifle_history(X) linenoiseHistorySetMaxLen(X)
        -:  137:# define shell_readline(X) linenoise(X)
        -:  138:
        -:  139:#else
        -:  140:
        -:  141:# define shell_read_history(X)
        -:  142:# define shell_write_history(X)
        -:  143:# define shell_stifle_history(X)
        -:  144:
        -:  145:# define SHELL_USE_LOCAL_GETLINE 1
        -:  146:#endif
        -:  147:
        -:  148:
        -:  149:#if defined(_WIN32) || defined(WIN32)
        -:  150:# include <io.h>
        -:  151:# include <fcntl.h>
        -:  152:# define isatty(h) _isatty(h)
        -:  153:# ifndef access
        -:  154:#  define access(f,m) _access((f),(m))
        -:  155:# endif
        -:  156:# ifndef unlink
        -:  157:#  define unlink _unlink
        -:  158:# endif
        -:  159:# undef popen
        -:  160:# define popen _popen
        -:  161:# undef pclose
        -:  162:# define pclose _pclose
        -:  163:#else
        -:  164: /* Make sure isatty() has a prototype. */
        -:  165: extern int isatty(int);
        -:  166:
        -:  167:# if !defined(__RTP__) && !defined(_WRS_KERNEL)
        -:  168:  /* popen and pclose are not C89 functions and so are
        -:  169:  ** sometimes omitted from the <stdio.h> header */
        -:  170:   extern FILE *popen(const char*,const char*);
        -:  171:   extern int pclose(FILE*);
        -:  172:# else
        -:  173:#  define SQLITE_OMIT_POPEN 1
        -:  174:# endif
        -:  175:#endif
        -:  176:
        -:  177:#if defined(_WIN32_WCE)
        -:  178:/* Windows CE (arm-wince-mingw32ce-gcc) does not provide isatty()
        -:  179: * thus we always assume that we have a console. That can be
        -:  180: * overridden with the -batch command line option.
        -:  181: */
        -:  182:#define isatty(x) 1
        -:  183:#endif
        -:  184:
        -:  185:/* ctype macros that work with signed characters */
        -:  186:#define IsSpace(X)  isspace((unsigned char)X)
        -:  187:#define IsDigit(X)  isdigit((unsigned char)X)
        -:  188:#define ToLower(X)  (char)tolower((unsigned char)X)
        -:  189:
        -:  190:#if defined(_WIN32) || defined(WIN32)
        -:  191:#include <windows.h>
        -:  192:
        -:  193:/* string conversion routines only needed on Win32 */
        -:  194:extern char *sqlite3_win32_unicode_to_utf8(LPCWSTR);
        -:  195:extern char *sqlite3_win32_mbcs_to_utf8_v2(const char *, int);
        -:  196:extern char *sqlite3_win32_utf8_to_mbcs_v2(const char *, int);
        -:  197:extern LPWSTR sqlite3_win32_utf8_to_unicode(const char *zText);
        -:  198:#endif
        -:  199:
        -:  200:/* On Windows, we normally run with output mode of TEXT so that \n characters
        -:  201:** are automatically translated into \r\n.  However, this behavior needs
        -:  202:** to be disabled in some cases (ex: when generating CSV output and when
        -:  203:** rendering quoted strings that contain \n characters).  The following
        -:  204:** routines take care of that.
        -:  205:*/
        -:  206:#if defined(_WIN32) || defined(WIN32)
        -:  207:static void setBinaryMode(FILE *file, int isOutput){
        -:  208:  if( isOutput ) fflush(file);
        -:  209:  _setmode(_fileno(file), _O_BINARY);
        -:  210:}
        -:  211:static void setTextMode(FILE *file, int isOutput){
        -:  212:  if( isOutput ) fflush(file);
        -:  213:  _setmode(_fileno(file), _O_TEXT);
        -:  214:}
        -:  215:#else
        -:  216:# define setBinaryMode(X,Y)
        -:  217:# define setTextMode(X,Y)
        -:  218:#endif
        -:  219:
        -:  220:
        -:  221:/* True if the timer is enabled */
        -:  222:static int enableTimer = 0;
        -:  223:
        -:  224:/* Return the current wall-clock time */
    #####:  225:static sqlite3_int64 timeOfDay(void){
        -:  226:  static sqlite3_vfs *clockVfs = 0;
        -:  227:  sqlite3_int64 t;
    #####:  228:  if( clockVfs==0 ) clockVfs = sqlite3_vfs_find(0);
    #####:  229:  if( clockVfs->iVersion>=2 && clockVfs->xCurrentTimeInt64!=0 ){
    #####:  230:    clockVfs->xCurrentTimeInt64(clockVfs, &t);
        -:  231:  }else{
        -:  232:    double r;
    #####:  233:    clockVfs->xCurrentTime(clockVfs, &r);
    #####:  234:    t = (sqlite3_int64)(r*86400000.0);
        -:  235:  }
    #####:  236:  return t;
        -:  237:}
        -:  238:
        -:  239:#if !defined(_WIN32) && !defined(WIN32) && !defined(__minux)
        -:  240:#include <sys/time.h>
        -:  241:#include <sys/resource.h>
        -:  242:
        -:  243:/* VxWorks does not support getrusage() as far as we can determine */
        -:  244:#if defined(_WRS_KERNEL) || defined(__RTP__)
        -:  245:struct rusage {
        -:  246:  struct timeval ru_utime; /* user CPU time used */
        -:  247:  struct timeval ru_stime; /* system CPU time used */
        -:  248:};
        -:  249:#define getrusage(A,B) memset(B,0,sizeof(*B))
        -:  250:#endif
        -:  251:
        -:  252:/* Saved resource information for the beginning of an operation */
        -:  253:static struct rusage sBegin;  /* CPU time at start */
        -:  254:static sqlite3_int64 iBegin;  /* Wall-clock time at start */
        -:  255:
        -:  256:/*
        -:  257:** Begin timing an operation
        -:  258:*/
        2:  259:static void beginTimer(void){
        2:  260:  if( enableTimer ){
    #####:  261:    getrusage(RUSAGE_SELF, &sBegin);
    #####:  262:    iBegin = timeOfDay();
        -:  263:  }
        2:  264:}
        -:  265:
        -:  266:/* Return the difference of two time_structs in seconds */
    #####:  267:static double timeDiff(struct timeval *pStart, struct timeval *pEnd){
    #####:  268:  return (pEnd->tv_usec - pStart->tv_usec)*0.000001 +
    #####:  269:         (double)(pEnd->tv_sec - pStart->tv_sec);
        -:  270:}
        -:  271:
        -:  272:/*
        -:  273:** Print the timing results.
        -:  274:*/
        2:  275:static void endTimer(void){
        2:  276:  if( enableTimer ){
    #####:  277:    sqlite3_int64 iEnd = timeOfDay();
        -:  278:    struct rusage sEnd;
    #####:  279:    getrusage(RUSAGE_SELF, &sEnd);
    #####:  280:    printf("Run Time: real %.3f user %f sys %f\n",
    #####:  281:       (iEnd - iBegin)*0.001,
        -:  282:       timeDiff(&sBegin.ru_utime, &sEnd.ru_utime),
        -:  283:       timeDiff(&sBegin.ru_stime, &sEnd.ru_stime));
        -:  284:  }
        2:  285:}
        -:  286:
        -:  287:#define BEGIN_TIMER beginTimer()
        -:  288:#define END_TIMER endTimer()
        -:  289:#define HAS_TIMER 1
        -:  290:
        -:  291:#elif (defined(_WIN32) || defined(WIN32))
        -:  292:
        -:  293:/* Saved resource information for the beginning of an operation */
        -:  294:static HANDLE hProcess;
        -:  295:static FILETIME ftKernelBegin;
        -:  296:static FILETIME ftUserBegin;
        -:  297:static sqlite3_int64 ftWallBegin;
        -:  298:typedef BOOL (WINAPI *GETPROCTIMES)(HANDLE, LPFILETIME, LPFILETIME,
        -:  299:                                    LPFILETIME, LPFILETIME);
        -:  300:static GETPROCTIMES getProcessTimesAddr = NULL;
        -:  301:
        -:  302:/*
        -:  303:** Check to see if we have timer support.  Return 1 if necessary
        -:  304:** support found (or found previously).
        -:  305:*/
        -:  306:static int hasTimer(void){
        -:  307:  if( getProcessTimesAddr ){
        -:  308:    return 1;
        -:  309:  } else {
        -:  310:    /* GetProcessTimes() isn't supported in WIN95 and some other Windows
        -:  311:    ** versions. See if the version we are running on has it, and if it
        -:  312:    ** does, save off a pointer to it and the current process handle.
        -:  313:    */
        -:  314:    hProcess = GetCurrentProcess();
        -:  315:    if( hProcess ){
        -:  316:      HINSTANCE hinstLib = LoadLibrary(TEXT("Kernel32.dll"));
        -:  317:      if( NULL != hinstLib ){
        -:  318:        getProcessTimesAddr =
        -:  319:            (GETPROCTIMES) GetProcAddress(hinstLib, "GetProcessTimes");
        -:  320:        if( NULL != getProcessTimesAddr ){
        -:  321:          return 1;
        -:  322:        }
        -:  323:        FreeLibrary(hinstLib);
        -:  324:      }
        -:  325:    }
        -:  326:  }
        -:  327:  return 0;
        -:  328:}
        -:  329:
        -:  330:/*
        -:  331:** Begin timing an operation
        -:  332:*/
        -:  333:static void beginTimer(void){
        -:  334:  if( enableTimer && getProcessTimesAddr ){
        -:  335:    FILETIME ftCreation, ftExit;
        -:  336:    getProcessTimesAddr(hProcess,&ftCreation,&ftExit,
        -:  337:                        &ftKernelBegin,&ftUserBegin);
        -:  338:    ftWallBegin = timeOfDay();
        -:  339:  }
        -:  340:}
        -:  341:
        -:  342:/* Return the difference of two FILETIME structs in seconds */
        -:  343:static double timeDiff(FILETIME *pStart, FILETIME *pEnd){
        -:  344:  sqlite_int64 i64Start = *((sqlite_int64 *) pStart);
        -:  345:  sqlite_int64 i64End = *((sqlite_int64 *) pEnd);
        -:  346:  return (double) ((i64End - i64Start) / 10000000.0);
        -:  347:}
        -:  348:
        -:  349:/*
        -:  350:** Print the timing results.
        -:  351:*/
        -:  352:static void endTimer(void){
        -:  353:  if( enableTimer && getProcessTimesAddr){
        -:  354:    FILETIME ftCreation, ftExit, ftKernelEnd, ftUserEnd;
        -:  355:    sqlite3_int64 ftWallEnd = timeOfDay();
        -:  356:    getProcessTimesAddr(hProcess,&ftCreation,&ftExit,&ftKernelEnd,&ftUserEnd);
        -:  357:    printf("Run Time: real %.3f user %f sys %f\n",
        -:  358:       (ftWallEnd - ftWallBegin)*0.001,
        -:  359:       timeDiff(&ftUserBegin, &ftUserEnd),
        -:  360:       timeDiff(&ftKernelBegin, &ftKernelEnd));
        -:  361:  }
        -:  362:}
        -:  363:
        -:  364:#define BEGIN_TIMER beginTimer()
        -:  365:#define END_TIMER endTimer()
        -:  366:#define HAS_TIMER hasTimer()
        -:  367:
        -:  368:#else
        -:  369:#define BEGIN_TIMER
        -:  370:#define END_TIMER
        -:  371:#define HAS_TIMER 0
        -:  372:#endif
        -:  373:
        -:  374:/*
        -:  375:** Used to prevent warnings about unused parameters
        -:  376:*/
        -:  377:#define UNUSED_PARAMETER(x) (void)(x)
        -:  378:
        -:  379:/*
        -:  380:** Number of elements in an array
        -:  381:*/
        -:  382:#define ArraySize(X)  (int)(sizeof(X)/sizeof(X[0]))
        -:  383:
        -:  384:/*
        -:  385:** If the following flag is set, then command execution stops
        -:  386:** at an error if we are not interactive.
        -:  387:*/
        -:  388:static int bail_on_error = 0;
        -:  389:
        -:  390:/*
        -:  391:** Threat stdin as an interactive input if the following variable
        -:  392:** is true.  Otherwise, assume stdin is connected to a file or pipe.
        -:  393:*/
        -:  394:static int stdin_is_interactive = 1;
        -:  395:
        -:  396:/*
        -:  397:** On Windows systems we have to know if standard output is a console
        -:  398:** in order to translate UTF-8 into MBCS.  The following variable is
        -:  399:** true if translation is required.
        -:  400:*/
        -:  401:static int stdout_is_console = 1;
        -:  402:
        -:  403:/*
        -:  404:** The following is the open SQLite database.  We make a pointer
        -:  405:** to this database a static variable so that it can be accessed
        -:  406:** by the SIGINT handler to interrupt database processing.
        -:  407:*/
        -:  408:static sqlite3 *globalDb = 0;
        -:  409:
        -:  410:/*
        -:  411:** True if an interrupt (Control-C) has been received.
        -:  412:*/
        -:  413:static volatile int seenInterrupt = 0;
        -:  414:
        -:  415:/*
        -:  416:** This is the name of our program. It is set in main(), used
        -:  417:** in a number of other places, mostly for error messages.
        -:  418:*/
        -:  419:static char *Argv0;
        -:  420:
        -:  421:/*
        -:  422:** Prompt strings. Initialized in main. Settable with
        -:  423:**   .prompt main continue
        -:  424:*/
        -:  425:static char mainPrompt[20];     /* First line prompt. default: "sqlite> "*/
        -:  426:static char continuePrompt[20]; /* Continuation prompt. default: "   ...> " */
        -:  427:
        -:  428:/*
        -:  429:** Render output like fprintf().  Except, if the output is going to the
        -:  430:** console and if this is running on a Windows machine, translate the
        -:  431:** output from UTF-8 into MBCS.
        -:  432:*/
        -:  433:#if defined(_WIN32) || defined(WIN32)
        -:  434:void utf8_printf(FILE *out, const char *zFormat, ...){
        -:  435:  va_list ap;
        -:  436:  va_start(ap, zFormat);
        -:  437:  if( stdout_is_console && (out==stdout || out==stderr) ){
        -:  438:    char *z1 = sqlite3_vmprintf(zFormat, ap);
        -:  439:    char *z2 = sqlite3_win32_utf8_to_mbcs_v2(z1, 0);
        -:  440:    sqlite3_free(z1);
        -:  441:    fputs(z2, out);
        -:  442:    sqlite3_free(z2);
        -:  443:  }else{
        -:  444:    vfprintf(out, zFormat, ap);
        -:  445:  }
        -:  446:  va_end(ap);
        -:  447:}
        -:  448:#elif !defined(utf8_printf)
        -:  449:# define utf8_printf fprintf
        -:  450:#endif
        -:  451:
        -:  452:/*
        -:  453:** Render output like fprintf().  This should not be used on anything that
        -:  454:** includes string formatting (e.g. "%s").
        -:  455:*/
        -:  456:#if !defined(raw_printf)
        -:  457:# define raw_printf fprintf
        -:  458:#endif
        -:  459:
        -:  460:/* Indicate out-of-memory and exit. */
    #####:  461:static void shell_out_of_memory(void){
    #####:  462:  raw_printf(stderr,"Error: out of memory\n");
    #####:  463:  exit(1);
        -:  464:}
        -:  465:
        -:  466:/*
        -:  467:** Write I/O traces to the following stream.
        -:  468:*/
        -:  469:#ifdef SQLITE_ENABLE_IOTRACE
        -:  470:static FILE *iotrace = 0;
        -:  471:#endif
        -:  472:
        -:  473:/*
        -:  474:** This routine works like printf in that its first argument is a
        -:  475:** format string and subsequent arguments are values to be substituted
        -:  476:** in place of % fields.  The result of formatting this string
        -:  477:** is written to iotrace.
        -:  478:*/
        -:  479:#ifdef SQLITE_ENABLE_IOTRACE
        -:  480:static void SQLITE_CDECL iotracePrintf(const char *zFormat, ...){
        -:  481:  va_list ap;
        -:  482:  char *z;
        -:  483:  if( iotrace==0 ) return;
        -:  484:  va_start(ap, zFormat);
        -:  485:  z = sqlite3_vmprintf(zFormat, ap);
        -:  486:  va_end(ap);
        -:  487:  utf8_printf(iotrace, "%s", z);
        -:  488:  sqlite3_free(z);
        -:  489:}
        -:  490:#endif
        -:  491:
        -:  492:/*
        -:  493:** Output string zUtf to stream pOut as w characters.  If w is negative,
        -:  494:** then right-justify the text.  W is the width in UTF-8 characters, not
        -:  495:** in bytes.  This is different from the %*.*s specification in printf
        -:  496:** since with %*.*s the width is measured in bytes, not characters.
        -:  497:*/
    #####:  498:static void utf8_width_print(FILE *pOut, int w, const char *zUtf){
        -:  499:  int i;
        -:  500:  int n;
    #####:  501:  int aw = w<0 ? -w : w;
        -:  502:  char zBuf[1000];
    #####:  503:  if( aw>(int)sizeof(zBuf)/3 ) aw = (int)sizeof(zBuf)/3;
    #####:  504:  for(i=n=0; zUtf[i]; i++){
    #####:  505:    if( (zUtf[i]&0xc0)!=0x80 ){
    #####:  506:      n++;
    #####:  507:      if( n==aw ){
    #####:  508:        do{ i++; }while( (zUtf[i]&0xc0)==0x80 );
    #####:  509:        break;
        -:  510:      }
        -:  511:    }
        -:  512:  }
    #####:  513:  if( n>=aw ){
    #####:  514:    utf8_printf(pOut, "%.*s", i, zUtf);
    #####:  515:  }else if( w<0 ){
    #####:  516:    utf8_printf(pOut, "%*s%s", aw-n, "", zUtf);
        -:  517:  }else{
    #####:  518:    utf8_printf(pOut, "%s%*s", zUtf, aw-n, "");
        -:  519:  }
    #####:  520:}
        -:  521:
        -:  522:
        -:  523:/*
        -:  524:** Determines if a string is a number of not.
        -:  525:*/
    #####:  526:static int isNumber(const char *z, int *realnum){
    #####:  527:  if( *z=='-' || *z=='+' ) z++;
    #####:  528:  if( !IsDigit(*z) ){
    #####:  529:    return 0;
        -:  530:  }
    #####:  531:  z++;
    #####:  532:  if( realnum ) *realnum = 0;
    #####:  533:  while( IsDigit(*z) ){ z++; }
    #####:  534:  if( *z=='.' ){
    #####:  535:    z++;
    #####:  536:    if( !IsDigit(*z) ) return 0;
    #####:  537:    while( IsDigit(*z) ){ z++; }
    #####:  538:    if( realnum ) *realnum = 1;
        -:  539:  }
    #####:  540:  if( *z=='e' || *z=='E' ){
    #####:  541:    z++;
    #####:  542:    if( *z=='+' || *z=='-' ) z++;
    #####:  543:    if( !IsDigit(*z) ) return 0;
    #####:  544:    while( IsDigit(*z) ){ z++; }
    #####:  545:    if( realnum ) *realnum = 1;
        -:  546:  }
    #####:  547:  return *z==0;
        -:  548:}
        -:  549:
        -:  550:/*
        -:  551:** Compute a string length that is limited to what can be stored in
        -:  552:** lower 30 bits of a 32-bit signed integer.
        -:  553:*/
       10:  554:static int strlen30(const char *z){
       10:  555:  const char *z2 = z;
      154:  556:  while( *z2 ){ z2++; }
       10:  557:  return 0x3fffffff & (int)(z2 - z);
        -:  558:}
        -:  559:
        -:  560:/*
        -:  561:** Return the length of a string in characters.  Multibyte UTF8 characters
        -:  562:** count as a single character.
        -:  563:*/
    #####:  564:static int strlenChar(const char *z){
    #####:  565:  int n = 0;
    #####:  566:  while( *z ){
    #####:  567:    if( (0xc0&*(z++))!=0x80 ) n++;
        -:  568:  }
    #####:  569:  return n;
        -:  570:}
        -:  571:
        -:  572:/*
        -:  573:** This routine reads a line of text from FILE in, stores
        -:  574:** the text in memory obtained from malloc() and returns a pointer
        -:  575:** to the text.  NULL is returned at end of file, or if malloc()
        -:  576:** fails.
        -:  577:**
        -:  578:** If zLine is not NULL then it is a malloced buffer returned from
        -:  579:** a previous call to this routine that may be reused.
        -:  580:*/
        4:  581:static char *local_getline(char *zLine, FILE *in){
        4:  582:  int nLine = zLine==0 ? 0 : 100;
        4:  583:  int n = 0;
        -:  584:
        -:  585:  while( 1 ){
        4:  586:    if( n+100>nLine ){
        2:  587:      nLine = nLine*2 + 100;
        2:  588:      zLine = realloc(zLine, nLine);
       2*:  589:      if( zLine==0 ) shell_out_of_memory();
        -:  590:    }
        4:  591:    if( fgets(&zLine[n], nLine - n, in)==0 ){
    #####:  592:      if( n==0 ){
    #####:  593:        free(zLine);
    #####:  594:        return 0;
        -:  595:      }
    #####:  596:      zLine[n] = 0;
    #####:  597:      break;
        -:  598:    }
       52:  599:    while( zLine[n] ) n++;
        4:  600:    if( n>0 && zLine[n-1]=='\n' ){
        4:  601:      n--;
       4*:  602:      if( n>0 && zLine[n-1]=='\r' ) n--;
        4:  603:      zLine[n] = 0;
        4:  604:      break;
        -:  605:    }
        -:  606:  }
        -:  607:#if defined(_WIN32) || defined(WIN32)
        -:  608:  /* For interactive input on Windows systems, translate the
        -:  609:  ** multi-byte characterset characters into UTF-8. */
        -:  610:  if( stdin_is_interactive && in==stdin ){
        -:  611:    char *zTrans = sqlite3_win32_mbcs_to_utf8_v2(zLine, 0);
        -:  612:    if( zTrans ){
        -:  613:      int nTrans = strlen30(zTrans)+1;
        -:  614:      if( nTrans>nLine ){
        -:  615:        zLine = realloc(zLine, nTrans);
        -:  616:        if( zLine==0 ) shell_out_of_memory();
        -:  617:      }
        -:  618:      memcpy(zLine, zTrans, nTrans);
        -:  619:      sqlite3_free(zTrans);
        -:  620:    }
        -:  621:  }
        -:  622:#endif /* defined(_WIN32) || defined(WIN32) */
        4:  623:  return zLine;
        -:  624:}
        -:  625:
        -:  626:/*
        -:  627:** Retrieve a single line of input text.
        -:  628:**
        -:  629:** If in==0 then read from standard input and prompt before each line.
        -:  630:** If isContinuation is true, then a continuation prompt is appropriate.
        -:  631:** If isContinuation is zero, then the main prompt should be used.
        -:  632:**
        -:  633:** If zPrior is not NULL then it is a buffer from a prior call to this
        -:  634:** routine that can be reused.
        -:  635:**
        -:  636:** The result is stored in space obtained from malloc() and must either
        -:  637:** be freed by the caller or else passed back into this routine via the
        -:  638:** zPrior argument for reuse.
        -:  639:*/
        4:  640:static char *one_input_line(FILE *in, char *zPrior, int isContinuation){
        -:  641:  char *zPrompt;
        -:  642:  char *zResult;
        4:  643:  if( in!=0 ){
    #####:  644:    zResult = local_getline(zPrior, in);
        -:  645:  }else{
       4*:  646:    zPrompt = isContinuation ? continuePrompt : mainPrompt;
        -:  647:#if SHELL_USE_LOCAL_GETLINE
        4:  648:    printf("%s", zPrompt);
        4:  649:    fflush(stdout);
        4:  650:    zResult = local_getline(zPrior, stdin);
        -:  651:#else
        -:  652:    free(zPrior);
        -:  653:    zResult = shell_readline(zPrompt);
        -:  654:    if( zResult && *zResult ) shell_add_history(zResult);
        -:  655:#endif
        -:  656:  }
        4:  657:  return zResult;
        -:  658:}
        -:  659:
        -:  660:
        -:  661:/*
        -:  662:** Return the value of a hexadecimal digit.  Return -1 if the input
        -:  663:** is not a hex digit.
        -:  664:*/
    #####:  665:static int hexDigitValue(char c){
    #####:  666:  if( c>='0' && c<='9' ) return c - '0';
    #####:  667:  if( c>='a' && c<='f' ) return c - 'a' + 10;
    #####:  668:  if( c>='A' && c<='F' ) return c - 'A' + 10;
    #####:  669:  return -1;
        -:  670:}
        -:  671:
        -:  672:/*
        -:  673:** Interpret zArg as an integer value, possibly with suffixes.
        -:  674:*/
    #####:  675:static sqlite3_int64 integerValue(const char *zArg){
    #####:  676:  sqlite3_int64 v = 0;
        -:  677:  static const struct { char *zSuffix; int iMult; } aMult[] = {
        -:  678:    { "KiB", 1024 },
        -:  679:    { "MiB", 1024*1024 },
        -:  680:    { "GiB", 1024*1024*1024 },
        -:  681:    { "KB",  1000 },
        -:  682:    { "MB",  1000000 },
        -:  683:    { "GB",  1000000000 },
        -:  684:    { "K",   1000 },
        -:  685:    { "M",   1000000 },
        -:  686:    { "G",   1000000000 },
        -:  687:  };
        -:  688:  int i;
    #####:  689:  int isNeg = 0;
    #####:  690:  if( zArg[0]=='-' ){
    #####:  691:    isNeg = 1;
    #####:  692:    zArg++;
    #####:  693:  }else if( zArg[0]=='+' ){
    #####:  694:    zArg++;
        -:  695:  }
    #####:  696:  if( zArg[0]=='0' && zArg[1]=='x' ){
        -:  697:    int x;
    #####:  698:    zArg += 2;
    #####:  699:    while( (x = hexDigitValue(zArg[0]))>=0 ){
    #####:  700:      v = (v<<4) + x;
    #####:  701:      zArg++;
        -:  702:    }
        -:  703:  }else{
    #####:  704:    while( IsDigit(zArg[0]) ){
    #####:  705:      v = v*10 + zArg[0] - '0';
    #####:  706:      zArg++;
        -:  707:    }
        -:  708:  }
    #####:  709:  for(i=0; i<ArraySize(aMult); i++){
    #####:  710:    if( sqlite3_stricmp(aMult[i].zSuffix, zArg)==0 ){
    #####:  711:      v *= aMult[i].iMult;
    #####:  712:      break;
        -:  713:    }
        -:  714:  }
    #####:  715:  return isNeg? -v : v;
        -:  716:}
        -:  717:
        -:  718:/*
        -:  719:** A variable length string to which one can append text.
        -:  720:*/
        -:  721:typedef struct ShellText ShellText;
        -:  722:struct ShellText {
        -:  723:  char *z;
        -:  724:  int n;
        -:  725:  int nAlloc;
        -:  726:};
        -:  727:
        -:  728:/*
        -:  729:** Initialize and destroy a ShellText object
        -:  730:*/
    #####:  731:static void initText(ShellText *p){
    #####:  732:  memset(p, 0, sizeof(*p));
    #####:  733:}
    #####:  734:static void freeText(ShellText *p){
    #####:  735:  free(p->z);
    #####:  736:  initText(p);
    #####:  737:}
        -:  738:
        -:  739:/* zIn is either a pointer to a NULL-terminated string in memory obtained
        -:  740:** from malloc(), or a NULL pointer. The string pointed to by zAppend is
        -:  741:** added to zIn, and the result returned in memory obtained from malloc().
        -:  742:** zIn, if it was not NULL, is freed.
        -:  743:**
        -:  744:** If the third argument, quote, is not '\0', then it is used as a
        -:  745:** quote character for zAppend.
        -:  746:*/
    #####:  747:static void appendText(ShellText *p, char const *zAppend, char quote){
        -:  748:  int len;
        -:  749:  int i;
    #####:  750:  int nAppend = strlen30(zAppend);
        -:  751:
    #####:  752:  len = nAppend+p->n+1;
    #####:  753:  if( quote ){
    #####:  754:    len += 2;
    #####:  755:    for(i=0; i<nAppend; i++){
    #####:  756:      if( zAppend[i]==quote ) len++;
        -:  757:    }
        -:  758:  }
        -:  759:
    #####:  760:  if( p->n+len>=p->nAlloc ){
    #####:  761:    p->nAlloc = p->nAlloc*2 + len + 20;
    #####:  762:    p->z = realloc(p->z, p->nAlloc);
    #####:  763:    if( p->z==0 ) shell_out_of_memory();
        -:  764:  }
        -:  765:
    #####:  766:  if( quote ){
    #####:  767:    char *zCsr = p->z+p->n;
    #####:  768:    *zCsr++ = quote;
    #####:  769:    for(i=0; i<nAppend; i++){
    #####:  770:      *zCsr++ = zAppend[i];
    #####:  771:      if( zAppend[i]==quote ) *zCsr++ = quote;
        -:  772:    }
    #####:  773:    *zCsr++ = quote;
    #####:  774:    p->n = (int)(zCsr - p->z);
    #####:  775:    *zCsr = '\0';
        -:  776:  }else{
    #####:  777:    memcpy(p->z+p->n, zAppend, nAppend);
    #####:  778:    p->n += nAppend;
    #####:  779:    p->z[p->n] = '\0';
        -:  780:  }
    #####:  781:}
        -:  782:
        -:  783:/*
        -:  784:** Attempt to determine if identifier zName needs to be quoted, either
        -:  785:** because it contains non-alphanumeric characters, or because it is an
        -:  786:** SQLite keyword.  Be conservative in this estimate:  When in doubt assume
        -:  787:** that quoting is required.
        -:  788:**
        -:  789:** Return '"' if quoting is required.  Return 0 if no quoting is required.
        -:  790:*/
    #####:  791:static char quoteChar(const char *zName){
        -:  792:  int i;
    #####:  793:  if( !isalpha((unsigned char)zName[0]) && zName[0]!='_' ) return '"';
    #####:  794:  for(i=0; zName[i]; i++){
    #####:  795:    if( !isalnum((unsigned char)zName[i]) && zName[i]!='_' ) return '"';
        -:  796:  }
    #####:  797:  return sqlite3_keyword_check(zName, i) ? '"' : 0;
        -:  798:}
        -:  799:
        -:  800:/*
        -:  801:** Construct a fake object name and column list to describe the structure
        -:  802:** of the view, virtual table, or table valued function zSchema.zName.
        -:  803:*/
    #####:  804:static char *shellFakeSchema(
        -:  805:  sqlite3 *db,            /* The database connection containing the vtab */
        -:  806:  const char *zSchema,    /* Schema of the database holding the vtab */
        -:  807:  const char *zName       /* The name of the virtual table */
        -:  808:){
    #####:  809:  sqlite3_stmt *pStmt = 0;
        -:  810:  char *zSql;
        -:  811:  ShellText s;
        -:  812:  char cQuote;
    #####:  813:  char *zDiv = "(";
    #####:  814:  int nRow = 0;
        -:  815:
    #####:  816:  zSql = sqlite3_mprintf("PRAGMA \"%w\".table_info=%Q;",
        -:  817:                         zSchema ? zSchema : "main", zName);
    #####:  818:  sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);
    #####:  819:  sqlite3_free(zSql);
    #####:  820:  initText(&s);
    #####:  821:  if( zSchema ){
    #####:  822:    cQuote = quoteChar(zSchema);
    #####:  823:    if( cQuote && sqlite3_stricmp(zSchema,"temp")==0 ) cQuote = 0;
    #####:  824:    appendText(&s, zSchema, cQuote);
    #####:  825:    appendText(&s, ".", 0);
        -:  826:  }
    #####:  827:  cQuote = quoteChar(zName);
    #####:  828:  appendText(&s, zName, cQuote);
    #####:  829:  while( sqlite3_step(pStmt)==SQLITE_ROW ){
    #####:  830:    const char *zCol = (const char*)sqlite3_column_text(pStmt, 1);
    #####:  831:    nRow++;
    #####:  832:    appendText(&s, zDiv, 0);
    #####:  833:    zDiv = ",";
    #####:  834:    cQuote = quoteChar(zCol);
    #####:  835:    appendText(&s, zCol, cQuote);
        -:  836:  }
    #####:  837:  appendText(&s, ")", 0);
    #####:  838:  sqlite3_finalize(pStmt);
    #####:  839:  if( nRow==0 ){
    #####:  840:    freeText(&s);
    #####:  841:    s.z = 0;
        -:  842:  }
    #####:  843:  return s.z;
        -:  844:}
        -:  845:
        -:  846:/*
        -:  847:** SQL function:  shell_module_schema(X)
        -:  848:**
        -:  849:** Return a fake schema for the table-valued function or eponymous virtual
        -:  850:** table X.
        -:  851:*/
    #####:  852:static void shellModuleSchema(
        -:  853:  sqlite3_context *pCtx,
        -:  854:  int nVal,
        -:  855:  sqlite3_value **apVal
        -:  856:){
    #####:  857:  const char *zName = (const char*)sqlite3_value_text(apVal[0]);
    #####:  858:  char *zFake = shellFakeSchema(sqlite3_context_db_handle(pCtx), 0, zName);
        -:  859:  UNUSED_PARAMETER(nVal);
    #####:  860:  if( zFake ){
    #####:  861:    sqlite3_result_text(pCtx, sqlite3_mprintf("/* %s */", zFake),
        -:  862:                        -1, sqlite3_free);
    #####:  863:    free(zFake);
        -:  864:  }
    #####:  865:}
        -:  866:
        -:  867:/*
        -:  868:** SQL function:  shell_add_schema(S,X)
        -:  869:**
        -:  870:** Add the schema name X to the CREATE statement in S and return the result.
        -:  871:** Examples:
        -:  872:**
        -:  873:**    CREATE TABLE t1(x)   ->   CREATE TABLE xyz.t1(x);
        -:  874:**
        -:  875:** Also works on
        -:  876:**
        -:  877:**    CREATE INDEX
        -:  878:**    CREATE UNIQUE INDEX
        -:  879:**    CREATE VIEW
        -:  880:**    CREATE TRIGGER
        -:  881:**    CREATE VIRTUAL TABLE
        -:  882:**
        -:  883:** This UDF is used by the .schema command to insert the schema name of
        -:  884:** attached databases into the middle of the sqlite_master.sql field.
        -:  885:*/
    #####:  886:static void shellAddSchemaName(
        -:  887:  sqlite3_context *pCtx,
        -:  888:  int nVal,
        -:  889:  sqlite3_value **apVal
        -:  890:){
        -:  891:  static const char *aPrefix[] = {
        -:  892:     "TABLE",
        -:  893:     "INDEX",
        -:  894:     "UNIQUE INDEX",
        -:  895:     "VIEW",
        -:  896:     "TRIGGER",
        -:  897:     "VIRTUAL TABLE"
        -:  898:  };
    #####:  899:  int i = 0;
    #####:  900:  const char *zIn = (const char*)sqlite3_value_text(apVal[0]);
    #####:  901:  const char *zSchema = (const char*)sqlite3_value_text(apVal[1]);
    #####:  902:  const char *zName = (const char*)sqlite3_value_text(apVal[2]);
    #####:  903:  sqlite3 *db = sqlite3_context_db_handle(pCtx);
        -:  904:  UNUSED_PARAMETER(nVal);
    #####:  905:  if( zIn!=0 && strncmp(zIn, "CREATE ", 7)==0 ){
    #####:  906:    for(i=0; i<(int)(sizeof(aPrefix)/sizeof(aPrefix[0])); i++){
    #####:  907:      int n = strlen30(aPrefix[i]);
    #####:  908:      if( strncmp(zIn+7, aPrefix[i], n)==0 && zIn[n+7]==' ' ){
    #####:  909:        char *z = 0;
    #####:  910:        char *zFake = 0;
    #####:  911:        if( zSchema ){
    #####:  912:          char cQuote = quoteChar(zSchema);
    #####:  913:          if( cQuote && sqlite3_stricmp(zSchema,"temp")!=0 ){
    #####:  914:            z = sqlite3_mprintf("%.*s \"%w\".%s", n+7, zIn, zSchema, zIn+n+8);
        -:  915:          }else{
    #####:  916:            z = sqlite3_mprintf("%.*s %s.%s", n+7, zIn, zSchema, zIn+n+8);
        -:  917:          }
        -:  918:        }
    #####:  919:        if( zName
    #####:  920:         && aPrefix[i][0]=='V'
    #####:  921:         && (zFake = shellFakeSchema(db, zSchema, zName))!=0
        -:  922:        ){
    #####:  923:          if( z==0 ){
    #####:  924:            z = sqlite3_mprintf("%s\n/* %s */", zIn, zFake);
        -:  925:          }else{
    #####:  926:            z = sqlite3_mprintf("%z\n/* %s */", z, zFake);
        -:  927:          }
    #####:  928:          free(zFake);
        -:  929:        }
    #####:  930:        if( z ){
    #####:  931:          sqlite3_result_text(pCtx, z, -1, sqlite3_free);
    #####:  932:          return;
        -:  933:        }
        -:  934:      }
        -:  935:    }
        -:  936:  }
    #####:  937:  sqlite3_result_value(pCtx, apVal[0]);
        -:  938:}
        -:  939:
        -:  940:/*
        -:  941:** The source code for several run-time loadable extensions is inserted
        -:  942:** below by the ../tool/mkshellc.tcl script.  Before processing that included
        -:  943:** code, we need to override some macros to make the included program code
        -:  944:** work here in the middle of this regular program.
        -:  945:*/
        -:  946:#define SQLITE_EXTENSION_INIT1
        -:  947:#define SQLITE_EXTENSION_INIT2(X) (void)(X)
        -:  948:
        -:  949:#if defined(_WIN32) && defined(_MSC_VER)
        -:  950:/************************* Begin test_windirent.h ******************/
        -:  951:/*
        -:  952:** 2015 November 30
        -:  953:**
        -:  954:** The author disclaims copyright to this source code.  In place of
        -:  955:** a legal notice, here is a blessing:
        -:  956:**
        -:  957:**    May you do good and not evil.
        -:  958:**    May you find forgiveness for yourself and forgive others.
        -:  959:**    May you share freely, never taking more than you give.
        -:  960:**
        -:  961:*************************************************************************
        -:  962:** This file contains declarations for most of the opendir() family of
        -:  963:** POSIX functions on Win32 using the MSVCRT.
        -:  964:*/
        -:  965:
        -:  966:#if defined(_WIN32) && defined(_MSC_VER) && !defined(SQLITE_WINDIRENT_H)
        -:  967:#define SQLITE_WINDIRENT_H
        -:  968:
        -:  969:/*
        -:  970:** We need several data types from the Windows SDK header.
        -:  971:*/
        -:  972:
        -:  973:#ifndef WIN32_LEAN_AND_MEAN
        -:  974:#define WIN32_LEAN_AND_MEAN
        -:  975:#endif
        -:  976:
        -:  977:#include "windows.h"
        -:  978:
        -:  979:/*
        -:  980:** We need several support functions from the SQLite core.
        -:  981:*/
        -:  982:
        -:  983:
        -:  984:/*
        -:  985:** We need several things from the ANSI and MSVCRT headers.
        -:  986:*/
        -:  987:
        -:  988:#include <stdio.h>
        -:  989:#include <stdlib.h>
        -:  990:#include <errno.h>
        -:  991:#include <io.h>
        -:  992:#include <limits.h>
        -:  993:#include <sys/types.h>
        -:  994:#include <sys/stat.h>
        -:  995:
        -:  996:/*
        -:  997:** We may need several defines that should have been in "sys/stat.h".
        -:  998:*/
        -:  999:
        -: 1000:#ifndef S_ISREG
        -: 1001:#define S_ISREG(mode) (((mode) & S_IFMT) == S_IFREG)
        -: 1002:#endif
        -: 1003:
        -: 1004:#ifndef S_ISDIR
        -: 1005:#define S_ISDIR(mode) (((mode) & S_IFMT) == S_IFDIR)
        -: 1006:#endif
        -: 1007:
        -: 1008:#ifndef S_ISLNK
        -: 1009:#define S_ISLNK(mode) (0)
        -: 1010:#endif
        -: 1011:
        -: 1012:/*
        -: 1013:** We may need to provide the "mode_t" type.
        -: 1014:*/
        -: 1015:
        -: 1016:#ifndef MODE_T_DEFINED
        -: 1017:  #define MODE_T_DEFINED
        -: 1018:  typedef unsigned short mode_t;
        -: 1019:#endif
        -: 1020:
        -: 1021:/*
        -: 1022:** We may need to provide the "ino_t" type.
        -: 1023:*/
        -: 1024:
        -: 1025:#ifndef INO_T_DEFINED
        -: 1026:  #define INO_T_DEFINED
        -: 1027:  typedef unsigned short ino_t;
        -: 1028:#endif
        -: 1029:
        -: 1030:/*
        -: 1031:** We need to define "NAME_MAX" if it was not present in "limits.h".
        -: 1032:*/
        -: 1033:
        -: 1034:#ifndef NAME_MAX
        -: 1035:#  ifdef FILENAME_MAX
        -: 1036:#    define NAME_MAX (FILENAME_MAX)
        -: 1037:#  else
        -: 1038:#    define NAME_MAX (260)
        -: 1039:#  endif
        -: 1040:#endif
        -: 1041:
        -: 1042:/*
        -: 1043:** We need to define "NULL_INTPTR_T" and "BAD_INTPTR_T".
        -: 1044:*/
        -: 1045:
        -: 1046:#ifndef NULL_INTPTR_T
        -: 1047:#  define NULL_INTPTR_T ((intptr_t)(0))
        -: 1048:#endif
        -: 1049:
        -: 1050:#ifndef BAD_INTPTR_T
        -: 1051:#  define BAD_INTPTR_T ((intptr_t)(-1))
        -: 1052:#endif
        -: 1053:
        -: 1054:/*
        -: 1055:** We need to provide the necessary structures and related types.
        -: 1056:*/
        -: 1057:
        -: 1058:#ifndef DIRENT_DEFINED
        -: 1059:#define DIRENT_DEFINED
        -: 1060:typedef struct DIRENT DIRENT;
        -: 1061:typedef DIRENT *LPDIRENT;
        -: 1062:struct DIRENT {
        -: 1063:  ino_t d_ino;               /* Sequence number, do not use. */
        -: 1064:  unsigned d_attributes;     /* Win32 file attributes. */
        -: 1065:  char d_name[NAME_MAX + 1]; /* Name within the directory. */
        -: 1066:};
        -: 1067:#endif
        -: 1068:
        -: 1069:#ifndef DIR_DEFINED
        -: 1070:#define DIR_DEFINED
        -: 1071:typedef struct DIR DIR;
        -: 1072:typedef DIR *LPDIR;
        -: 1073:struct DIR {
        -: 1074:  intptr_t d_handle; /* Value returned by "_findfirst". */
        -: 1075:  DIRENT d_first;    /* DIRENT constructed based on "_findfirst". */
        -: 1076:  DIRENT d_next;     /* DIRENT constructed based on "_findnext". */
        -: 1077:};
        -: 1078:#endif
        -: 1079:
        -: 1080:/*
        -: 1081:** Provide a macro, for use by the implementation, to determine if a
        -: 1082:** particular directory entry should be skipped over when searching for
        -: 1083:** the next directory entry that should be returned by the readdir() or
        -: 1084:** readdir_r() functions.
        -: 1085:*/
        -: 1086:
        -: 1087:#ifndef is_filtered
        -: 1088:#  define is_filtered(a) ((((a).attrib)&_A_HIDDEN) || (((a).attrib)&_A_SYSTEM))
        -: 1089:#endif
        -: 1090:
        -: 1091:/*
        -: 1092:** Provide the function prototype for the POSIX compatiable getenv()
        -: 1093:** function.  This function is not thread-safe.
        -: 1094:*/
        -: 1095:
        -: 1096:extern const char *windirent_getenv(const char *name);
        -: 1097:
        -: 1098:/*
        -: 1099:** Finally, we can provide the function prototypes for the opendir(),
        -: 1100:** readdir(), readdir_r(), and closedir() POSIX functions.
        -: 1101:*/
        -: 1102:
        -: 1103:extern LPDIR opendir(const char *dirname);
        -: 1104:extern LPDIRENT readdir(LPDIR dirp);
        -: 1105:extern INT readdir_r(LPDIR dirp, LPDIRENT entry, LPDIRENT *result);
        -: 1106:extern INT closedir(LPDIR dirp);
        -: 1107:
        -: 1108:#endif /* defined(WIN32) && defined(_MSC_VER) */
        -: 1109:
        -: 1110:/************************* End test_windirent.h ********************/
        -: 1111:/************************* Begin test_windirent.c ******************/
        -: 1112:/*
        -: 1113:** 2015 November 30
        -: 1114:**
        -: 1115:** The author disclaims copyright to this source code.  In place of
        -: 1116:** a legal notice, here is a blessing:
        -: 1117:**
        -: 1118:**    May you do good and not evil.
        -: 1119:**    May you find forgiveness for yourself and forgive others.
        -: 1120:**    May you share freely, never taking more than you give.
        -: 1121:**
        -: 1122:*************************************************************************
        -: 1123:** This file contains code to implement most of the opendir() family of
        -: 1124:** POSIX functions on Win32 using the MSVCRT.
        -: 1125:*/
        -: 1126:
        -: 1127:#if defined(_WIN32) && defined(_MSC_VER)
        -: 1128:/* #include "test_windirent.h" */
        -: 1129:
        -: 1130:/*
        -: 1131:** Implementation of the POSIX getenv() function using the Win32 API.
        -: 1132:** This function is not thread-safe.
        -: 1133:*/
        -: 1134:const char *windirent_getenv(
        -: 1135:  const char *name
        -: 1136:){
        -: 1137:  static char value[32768]; /* Maximum length, per MSDN */
        -: 1138:  DWORD dwSize = sizeof(value) / sizeof(char); /* Size in chars */
        -: 1139:  DWORD dwRet; /* Value returned by GetEnvironmentVariableA() */
        -: 1140:
        -: 1141:  memset(value, 0, sizeof(value));
        -: 1142:  dwRet = GetEnvironmentVariableA(name, value, dwSize);
        -: 1143:  if( dwRet==0 || dwRet>dwSize ){
        -: 1144:    /*
        -: 1145:    ** The function call to GetEnvironmentVariableA() failed -OR-
        -: 1146:    ** the buffer is not large enough.  Either way, return NULL.
        -: 1147:    */
        -: 1148:    return 0;
        -: 1149:  }else{
        -: 1150:    /*
        -: 1151:    ** The function call to GetEnvironmentVariableA() succeeded
        -: 1152:    ** -AND- the buffer contains the entire value.
        -: 1153:    */
        -: 1154:    return value;
        -: 1155:  }
        -: 1156:}
        -: 1157:
        -: 1158:/*
        -: 1159:** Implementation of the POSIX opendir() function using the MSVCRT.
        -: 1160:*/
        -: 1161:LPDIR opendir(
        -: 1162:  const char *dirname
        -: 1163:){
        -: 1164:  struct _finddata_t data;
        -: 1165:  LPDIR dirp = (LPDIR)sqlite3_malloc(sizeof(DIR));
        -: 1166:  SIZE_T namesize = sizeof(data.name) / sizeof(data.name[0]);
        -: 1167:
        -: 1168:  if( dirp==NULL ) return NULL;
        -: 1169:  memset(dirp, 0, sizeof(DIR));
        -: 1170:
        -: 1171:  /* TODO: Remove this if Unix-style root paths are not used. */
        -: 1172:  if( sqlite3_stricmp(dirname, "/")==0 ){
        -: 1173:    dirname = windirent_getenv("SystemDrive");
        -: 1174:  }
        -: 1175:
        -: 1176:  memset(&data, 0, sizeof(struct _finddata_t));
        -: 1177:  _snprintf(data.name, namesize, "%s\\*", dirname);
        -: 1178:  dirp->d_handle = _findfirst(data.name, &data);
        -: 1179:
        -: 1180:  if( dirp->d_handle==BAD_INTPTR_T ){
        -: 1181:    closedir(dirp);
        -: 1182:    return NULL;
        -: 1183:  }
        -: 1184:
        -: 1185:  /* TODO: Remove this block to allow hidden and/or system files. */
        -: 1186:  if( is_filtered(data) ){
        -: 1187:next:
        -: 1188:
        -: 1189:    memset(&data, 0, sizeof(struct _finddata_t));
        -: 1190:    if( _findnext(dirp->d_handle, &data)==-1 ){
        -: 1191:      closedir(dirp);
        -: 1192:      return NULL;
        -: 1193:    }
        -: 1194:
        -: 1195:    /* TODO: Remove this block to allow hidden and/or system files. */
        -: 1196:    if( is_filtered(data) ) goto next;
        -: 1197:  }
        -: 1198:
        -: 1199:  dirp->d_first.d_attributes = data.attrib;
        -: 1200:  strncpy(dirp->d_first.d_name, data.name, NAME_MAX);
        -: 1201:  dirp->d_first.d_name[NAME_MAX] = '\0';
        -: 1202:
        -: 1203:  return dirp;
        -: 1204:}
        -: 1205:
        -: 1206:/*
        -: 1207:** Implementation of the POSIX readdir() function using the MSVCRT.
        -: 1208:*/
        -: 1209:LPDIRENT readdir(
        -: 1210:  LPDIR dirp
        -: 1211:){
        -: 1212:  struct _finddata_t data;
        -: 1213:
        -: 1214:  if( dirp==NULL ) return NULL;
        -: 1215:
        -: 1216:  if( dirp->d_first.d_ino==0 ){
        -: 1217:    dirp->d_first.d_ino++;
        -: 1218:    dirp->d_next.d_ino++;
        -: 1219:
        -: 1220:    return &dirp->d_first;
        -: 1221:  }
        -: 1222:
        -: 1223:next:
        -: 1224:
        -: 1225:  memset(&data, 0, sizeof(struct _finddata_t));
        -: 1226:  if( _findnext(dirp->d_handle, &data)==-1 ) return NULL;
        -: 1227:
        -: 1228:  /* TODO: Remove this block to allow hidden and/or system files. */
        -: 1229:  if( is_filtered(data) ) goto next;
        -: 1230:
        -: 1231:  dirp->d_next.d_ino++;
        -: 1232:  dirp->d_next.d_attributes = data.attrib;
        -: 1233:  strncpy(dirp->d_next.d_name, data.name, NAME_MAX);
        -: 1234:  dirp->d_next.d_name[NAME_MAX] = '\0';
        -: 1235:
        -: 1236:  return &dirp->d_next;
        -: 1237:}
        -: 1238:
        -: 1239:/*
        -: 1240:** Implementation of the POSIX readdir_r() function using the MSVCRT.
        -: 1241:*/
        -: 1242:INT readdir_r(
        -: 1243:  LPDIR dirp,
        -: 1244:  LPDIRENT entry,
        -: 1245:  LPDIRENT *result
        -: 1246:){
        -: 1247:  struct _finddata_t data;
        -: 1248:
        -: 1249:  if( dirp==NULL ) return EBADF;
        -: 1250:
        -: 1251:  if( dirp->d_first.d_ino==0 ){
        -: 1252:    dirp->d_first.d_ino++;
        -: 1253:    dirp->d_next.d_ino++;
        -: 1254:
        -: 1255:    entry->d_ino = dirp->d_first.d_ino;
        -: 1256:    entry->d_attributes = dirp->d_first.d_attributes;
        -: 1257:    strncpy(entry->d_name, dirp->d_first.d_name, NAME_MAX);
        -: 1258:    entry->d_name[NAME_MAX] = '\0';
        -: 1259:
        -: 1260:    *result = entry;
        -: 1261:    return 0;
        -: 1262:  }
        -: 1263:
        -: 1264:next:
        -: 1265:
        -: 1266:  memset(&data, 0, sizeof(struct _finddata_t));
        -: 1267:  if( _findnext(dirp->d_handle, &data)==-1 ){
        -: 1268:    *result = NULL;
        -: 1269:    return ENOENT;
        -: 1270:  }
        -: 1271:
        -: 1272:  /* TODO: Remove this block to allow hidden and/or system files. */
        -: 1273:  if( is_filtered(data) ) goto next;
        -: 1274:
        -: 1275:  entry->d_ino = (ino_t)-1; /* not available */
        -: 1276:  entry->d_attributes = data.attrib;
        -: 1277:  strncpy(entry->d_name, data.name, NAME_MAX);
        -: 1278:  entry->d_name[NAME_MAX] = '\0';
        -: 1279:
        -: 1280:  *result = entry;
        -: 1281:  return 0;
        -: 1282:}
        -: 1283:
        -: 1284:/*
        -: 1285:** Implementation of the POSIX closedir() function using the MSVCRT.
        -: 1286:*/
        -: 1287:INT closedir(
        -: 1288:  LPDIR dirp
        -: 1289:){
        -: 1290:  INT result = 0;
        -: 1291:
        -: 1292:  if( dirp==NULL ) return EINVAL;
        -: 1293:
        -: 1294:  if( dirp->d_handle!=NULL_INTPTR_T && dirp->d_handle!=BAD_INTPTR_T ){
        -: 1295:    result = _findclose(dirp->d_handle);
        -: 1296:  }
        -: 1297:
        -: 1298:  sqlite3_free(dirp);
        -: 1299:  return result;
        -: 1300:}
        -: 1301:
        -: 1302:#endif /* defined(WIN32) && defined(_MSC_VER) */
        -: 1303:
        -: 1304:/************************* End test_windirent.c ********************/
        -: 1305:#define dirent DIRENT
        -: 1306:#endif
        -: 1307:/************************* Begin ../ext/misc/shathree.c ******************/
        -: 1308:/*
        -: 1309:** 2017-03-08
        -: 1310:**
        -: 1311:** The author disclaims copyright to this source code.  In place of
        -: 1312:** a legal notice, here is a blessing:
        -: 1313:**
        -: 1314:**    May you do good and not evil.
        -: 1315:**    May you find forgiveness for yourself and forgive others.
        -: 1316:**    May you share freely, never taking more than you give.
        -: 1317:**
        -: 1318:******************************************************************************
        -: 1319:**
        -: 1320:** This SQLite extension implements functions that compute SHA3 hashes.
        -: 1321:** Two SQL functions are implemented:
        -: 1322:**
        -: 1323:**     sha3(X,SIZE)
        -: 1324:**     sha3_query(Y,SIZE)
        -: 1325:**
        -: 1326:** The sha3(X) function computes the SHA3 hash of the input X, or NULL if
        -: 1327:** X is NULL.
        -: 1328:**
        -: 1329:** The sha3_query(Y) function evalutes all queries in the SQL statements of Y
        -: 1330:** and returns a hash of their results.
        -: 1331:**
        -: 1332:** The SIZE argument is optional.  If omitted, the SHA3-256 hash algorithm
        -: 1333:** is used.  If SIZE is included it must be one of the integers 224, 256,
        -: 1334:** 384, or 512, to determine SHA3 hash variant that is computed.
        -: 1335:*/
        -: 1336:SQLITE_EXTENSION_INIT1
        -: 1337:#include <assert.h>
        -: 1338:#include <string.h>
        -: 1339:#include <stdarg.h>
        -: 1340:/* typedef sqlite3_uint64 u64; */
        -: 1341:
        -: 1342:/******************************************************************************
        -: 1343:** The Hash Engine
        -: 1344:*/
        -: 1345:/*
        -: 1346:** Macros to determine whether the machine is big or little endian,
        -: 1347:** and whether or not that determination is run-time or compile-time.
        -: 1348:**
        -: 1349:** For best performance, an attempt is made to guess at the byte-order
        -: 1350:** using C-preprocessor macros.  If that is unsuccessful, or if
        -: 1351:** -DSHA3_BYTEORDER=0 is set, then byte-order is determined
        -: 1352:** at run-time.
        -: 1353:*/
        -: 1354:#ifndef SHA3_BYTEORDER
        -: 1355:# if defined(i386)     || defined(__i386__)   || defined(_M_IX86) ||    \
        -: 1356:     defined(__x86_64) || defined(__x86_64__) || defined(_M_X64)  ||    \
        -: 1357:     defined(_M_AMD64) || defined(_M_ARM)     || defined(__x86)   ||    \
        -: 1358:     defined(__arm__)
        -: 1359:#   define SHA3_BYTEORDER    1234
        -: 1360:# elif defined(sparc)    || defined(__ppc__)
        -: 1361:#   define SHA3_BYTEORDER    4321
        -: 1362:# else
        -: 1363:#   define SHA3_BYTEORDER 0
        -: 1364:# endif
        -: 1365:#endif
        -: 1366:
        -: 1367:
        -: 1368:/*
        -: 1369:** State structure for a SHA3 hash in progress
        -: 1370:*/
        -: 1371:typedef struct SHA3Context SHA3Context;
        -: 1372:struct SHA3Context {
        -: 1373:  union {
        -: 1374:    u64 s[25];                /* Keccak state. 5x5 lines of 64 bits each */
        -: 1375:    unsigned char x[1600];    /* ... or 1600 bytes */
        -: 1376:  } u;
        -: 1377:  unsigned nRate;        /* Bytes of input accepted per Keccak iteration */
        -: 1378:  unsigned nLoaded;      /* Input bytes loaded into u.x[] so far this cycle */
        -: 1379:  unsigned ixMask;       /* Insert next input into u.x[nLoaded^ixMask]. */
        -: 1380:};
        -: 1381:
        -: 1382:/*
        -: 1383:** A single step of the Keccak mixing function for a 1600-bit state
        -: 1384:*/
    #####: 1385:static void KeccakF1600Step(SHA3Context *p){
        -: 1386:  int i;
        -: 1387:  u64 b0, b1, b2, b3, b4;
        -: 1388:  u64 c0, c1, c2, c3, c4;
        -: 1389:  u64 d0, d1, d2, d3, d4;
        -: 1390:  static const u64 RC[] = {
        -: 1391:    0x0000000000000001ULL,  0x0000000000008082ULL,
        -: 1392:    0x800000000000808aULL,  0x8000000080008000ULL,
        -: 1393:    0x000000000000808bULL,  0x0000000080000001ULL,
        -: 1394:    0x8000000080008081ULL,  0x8000000000008009ULL,
        -: 1395:    0x000000000000008aULL,  0x0000000000000088ULL,
        -: 1396:    0x0000000080008009ULL,  0x000000008000000aULL,
        -: 1397:    0x000000008000808bULL,  0x800000000000008bULL,
        -: 1398:    0x8000000000008089ULL,  0x8000000000008003ULL,
        -: 1399:    0x8000000000008002ULL,  0x8000000000000080ULL,
        -: 1400:    0x000000000000800aULL,  0x800000008000000aULL,
        -: 1401:    0x8000000080008081ULL,  0x8000000000008080ULL,
        -: 1402:    0x0000000080000001ULL,  0x8000000080008008ULL
        -: 1403:  };
        -: 1404:# define a00 (p->u.s[0])
        -: 1405:# define a01 (p->u.s[1])
        -: 1406:# define a02 (p->u.s[2])
        -: 1407:# define a03 (p->u.s[3])
        -: 1408:# define a04 (p->u.s[4])
        -: 1409:# define a10 (p->u.s[5])
        -: 1410:# define a11 (p->u.s[6])
        -: 1411:# define a12 (p->u.s[7])
        -: 1412:# define a13 (p->u.s[8])
        -: 1413:# define a14 (p->u.s[9])
        -: 1414:# define a20 (p->u.s[10])
        -: 1415:# define a21 (p->u.s[11])
        -: 1416:# define a22 (p->u.s[12])
        -: 1417:# define a23 (p->u.s[13])
        -: 1418:# define a24 (p->u.s[14])
        -: 1419:# define a30 (p->u.s[15])
        -: 1420:# define a31 (p->u.s[16])
        -: 1421:# define a32 (p->u.s[17])
        -: 1422:# define a33 (p->u.s[18])
        -: 1423:# define a34 (p->u.s[19])
        -: 1424:# define a40 (p->u.s[20])
        -: 1425:# define a41 (p->u.s[21])
        -: 1426:# define a42 (p->u.s[22])
        -: 1427:# define a43 (p->u.s[23])
        -: 1428:# define a44 (p->u.s[24])
        -: 1429:# define ROL64(a,x) ((a<<x)|(a>>(64-x)))
        -: 1430:
    #####: 1431:  for(i=0; i<24; i+=4){
    #####: 1432:    c0 = a00^a10^a20^a30^a40;
    #####: 1433:    c1 = a01^a11^a21^a31^a41;
    #####: 1434:    c2 = a02^a12^a22^a32^a42;
    #####: 1435:    c3 = a03^a13^a23^a33^a43;
    #####: 1436:    c4 = a04^a14^a24^a34^a44;
    #####: 1437:    d0 = c4^ROL64(c1, 1);
    #####: 1438:    d1 = c0^ROL64(c2, 1);
    #####: 1439:    d2 = c1^ROL64(c3, 1);
    #####: 1440:    d3 = c2^ROL64(c4, 1);
    #####: 1441:    d4 = c3^ROL64(c0, 1);
        -: 1442:
    #####: 1443:    b0 = (a00^d0);
    #####: 1444:    b1 = ROL64((a11^d1), 44);
    #####: 1445:    b2 = ROL64((a22^d2), 43);
    #####: 1446:    b3 = ROL64((a33^d3), 21);
    #####: 1447:    b4 = ROL64((a44^d4), 14);
    #####: 1448:    a00 =   b0 ^((~b1)&  b2 );
    #####: 1449:    a00 ^= RC[i];
    #####: 1450:    a11 =   b1 ^((~b2)&  b3 );
    #####: 1451:    a22 =   b2 ^((~b3)&  b4 );
    #####: 1452:    a33 =   b3 ^((~b4)&  b0 );
    #####: 1453:    a44 =   b4 ^((~b0)&  b1 );
        -: 1454:
    #####: 1455:    b2 = ROL64((a20^d0), 3);
    #####: 1456:    b3 = ROL64((a31^d1), 45);
    #####: 1457:    b4 = ROL64((a42^d2), 61);
    #####: 1458:    b0 = ROL64((a03^d3), 28);
    #####: 1459:    b1 = ROL64((a14^d4), 20);
    #####: 1460:    a20 =   b0 ^((~b1)&  b2 );
    #####: 1461:    a31 =   b1 ^((~b2)&  b3 );
    #####: 1462:    a42 =   b2 ^((~b3)&  b4 );
    #####: 1463:    a03 =   b3 ^((~b4)&  b0 );
    #####: 1464:    a14 =   b4 ^((~b0)&  b1 );
        -: 1465:
    #####: 1466:    b4 = ROL64((a40^d0), 18);
    #####: 1467:    b0 = ROL64((a01^d1), 1);
    #####: 1468:    b1 = ROL64((a12^d2), 6);
    #####: 1469:    b2 = ROL64((a23^d3), 25);
    #####: 1470:    b3 = ROL64((a34^d4), 8);
    #####: 1471:    a40 =   b0 ^((~b1)&  b2 );
    #####: 1472:    a01 =   b1 ^((~b2)&  b3 );
    #####: 1473:    a12 =   b2 ^((~b3)&  b4 );
    #####: 1474:    a23 =   b3 ^((~b4)&  b0 );
    #####: 1475:    a34 =   b4 ^((~b0)&  b1 );
        -: 1476:
    #####: 1477:    b1 = ROL64((a10^d0), 36);
    #####: 1478:    b2 = ROL64((a21^d1), 10);
    #####: 1479:    b3 = ROL64((a32^d2), 15);
    #####: 1480:    b4 = ROL64((a43^d3), 56);
    #####: 1481:    b0 = ROL64((a04^d4), 27);
    #####: 1482:    a10 =   b0 ^((~b1)&  b2 );
    #####: 1483:    a21 =   b1 ^((~b2)&  b3 );
    #####: 1484:    a32 =   b2 ^((~b3)&  b4 );
    #####: 1485:    a43 =   b3 ^((~b4)&  b0 );
    #####: 1486:    a04 =   b4 ^((~b0)&  b1 );
        -: 1487:
    #####: 1488:    b3 = ROL64((a30^d0), 41);
    #####: 1489:    b4 = ROL64((a41^d1), 2);
    #####: 1490:    b0 = ROL64((a02^d2), 62);
    #####: 1491:    b1 = ROL64((a13^d3), 55);
    #####: 1492:    b2 = ROL64((a24^d4), 39);
    #####: 1493:    a30 =   b0 ^((~b1)&  b2 );
    #####: 1494:    a41 =   b1 ^((~b2)&  b3 );
    #####: 1495:    a02 =   b2 ^((~b3)&  b4 );
    #####: 1496:    a13 =   b3 ^((~b4)&  b0 );
    #####: 1497:    a24 =   b4 ^((~b0)&  b1 );
        -: 1498:
    #####: 1499:    c0 = a00^a20^a40^a10^a30;
    #####: 1500:    c1 = a11^a31^a01^a21^a41;
    #####: 1501:    c2 = a22^a42^a12^a32^a02;
    #####: 1502:    c3 = a33^a03^a23^a43^a13;
    #####: 1503:    c4 = a44^a14^a34^a04^a24;
    #####: 1504:    d0 = c4^ROL64(c1, 1);
    #####: 1505:    d1 = c0^ROL64(c2, 1);
    #####: 1506:    d2 = c1^ROL64(c3, 1);
    #####: 1507:    d3 = c2^ROL64(c4, 1);
    #####: 1508:    d4 = c3^ROL64(c0, 1);
        -: 1509:
    #####: 1510:    b0 = (a00^d0);
    #####: 1511:    b1 = ROL64((a31^d1), 44);
    #####: 1512:    b2 = ROL64((a12^d2), 43);
    #####: 1513:    b3 = ROL64((a43^d3), 21);
    #####: 1514:    b4 = ROL64((a24^d4), 14);
    #####: 1515:    a00 =   b0 ^((~b1)&  b2 );
    #####: 1516:    a00 ^= RC[i+1];
    #####: 1517:    a31 =   b1 ^((~b2)&  b3 );
    #####: 1518:    a12 =   b2 ^((~b3)&  b4 );
    #####: 1519:    a43 =   b3 ^((~b4)&  b0 );
    #####: 1520:    a24 =   b4 ^((~b0)&  b1 );
        -: 1521:
    #####: 1522:    b2 = ROL64((a40^d0), 3);
    #####: 1523:    b3 = ROL64((a21^d1), 45);
    #####: 1524:    b4 = ROL64((a02^d2), 61);
    #####: 1525:    b0 = ROL64((a33^d3), 28);
    #####: 1526:    b1 = ROL64((a14^d4), 20);
    #####: 1527:    a40 =   b0 ^((~b1)&  b2 );
    #####: 1528:    a21 =   b1 ^((~b2)&  b3 );
    #####: 1529:    a02 =   b2 ^((~b3)&  b4 );
    #####: 1530:    a33 =   b3 ^((~b4)&  b0 );
    #####: 1531:    a14 =   b4 ^((~b0)&  b1 );
        -: 1532:
    #####: 1533:    b4 = ROL64((a30^d0), 18);
    #####: 1534:    b0 = ROL64((a11^d1), 1);
    #####: 1535:    b1 = ROL64((a42^d2), 6);
    #####: 1536:    b2 = ROL64((a23^d3), 25);
    #####: 1537:    b3 = ROL64((a04^d4), 8);
    #####: 1538:    a30 =   b0 ^((~b1)&  b2 );
    #####: 1539:    a11 =   b1 ^((~b2)&  b3 );
    #####: 1540:    a42 =   b2 ^((~b3)&  b4 );
    #####: 1541:    a23 =   b3 ^((~b4)&  b0 );
    #####: 1542:    a04 =   b4 ^((~b0)&  b1 );
        -: 1543:
    #####: 1544:    b1 = ROL64((a20^d0), 36);
    #####: 1545:    b2 = ROL64((a01^d1), 10);
    #####: 1546:    b3 = ROL64((a32^d2), 15);
    #####: 1547:    b4 = ROL64((a13^d3), 56);
    #####: 1548:    b0 = ROL64((a44^d4), 27);
    #####: 1549:    a20 =   b0 ^((~b1)&  b2 );
    #####: 1550:    a01 =   b1 ^((~b2)&  b3 );
    #####: 1551:    a32 =   b2 ^((~b3)&  b4 );
    #####: 1552:    a13 =   b3 ^((~b4)&  b0 );
    #####: 1553:    a44 =   b4 ^((~b0)&  b1 );
        -: 1554:
    #####: 1555:    b3 = ROL64((a10^d0), 41);
    #####: 1556:    b4 = ROL64((a41^d1), 2);
    #####: 1557:    b0 = ROL64((a22^d2), 62);
    #####: 1558:    b1 = ROL64((a03^d3), 55);
    #####: 1559:    b2 = ROL64((a34^d4), 39);
    #####: 1560:    a10 =   b0 ^((~b1)&  b2 );
    #####: 1561:    a41 =   b1 ^((~b2)&  b3 );
    #####: 1562:    a22 =   b2 ^((~b3)&  b4 );
    #####: 1563:    a03 =   b3 ^((~b4)&  b0 );
    #####: 1564:    a34 =   b4 ^((~b0)&  b1 );
        -: 1565:
    #####: 1566:    c0 = a00^a40^a30^a20^a10;
    #####: 1567:    c1 = a31^a21^a11^a01^a41;
    #####: 1568:    c2 = a12^a02^a42^a32^a22;
    #####: 1569:    c3 = a43^a33^a23^a13^a03;
    #####: 1570:    c4 = a24^a14^a04^a44^a34;
    #####: 1571:    d0 = c4^ROL64(c1, 1);
    #####: 1572:    d1 = c0^ROL64(c2, 1);
    #####: 1573:    d2 = c1^ROL64(c3, 1);
    #####: 1574:    d3 = c2^ROL64(c4, 1);
    #####: 1575:    d4 = c3^ROL64(c0, 1);
        -: 1576:
    #####: 1577:    b0 = (a00^d0);
    #####: 1578:    b1 = ROL64((a21^d1), 44);
    #####: 1579:    b2 = ROL64((a42^d2), 43);
    #####: 1580:    b3 = ROL64((a13^d3), 21);
    #####: 1581:    b4 = ROL64((a34^d4), 14);
    #####: 1582:    a00 =   b0 ^((~b1)&  b2 );
    #####: 1583:    a00 ^= RC[i+2];
    #####: 1584:    a21 =   b1 ^((~b2)&  b3 );
    #####: 1585:    a42 =   b2 ^((~b3)&  b4 );
    #####: 1586:    a13 =   b3 ^((~b4)&  b0 );
    #####: 1587:    a34 =   b4 ^((~b0)&  b1 );
        -: 1588:
    #####: 1589:    b2 = ROL64((a30^d0), 3);
    #####: 1590:    b3 = ROL64((a01^d1), 45);
    #####: 1591:    b4 = ROL64((a22^d2), 61);
    #####: 1592:    b0 = ROL64((a43^d3), 28);
    #####: 1593:    b1 = ROL64((a14^d4), 20);
    #####: 1594:    a30 =   b0 ^((~b1)&  b2 );
    #####: 1595:    a01 =   b1 ^((~b2)&  b3 );
    #####: 1596:    a22 =   b2 ^((~b3)&  b4 );
    #####: 1597:    a43 =   b3 ^((~b4)&  b0 );
    #####: 1598:    a14 =   b4 ^((~b0)&  b1 );
        -: 1599:
    #####: 1600:    b4 = ROL64((a10^d0), 18);
    #####: 1601:    b0 = ROL64((a31^d1), 1);
    #####: 1602:    b1 = ROL64((a02^d2), 6);
    #####: 1603:    b2 = ROL64((a23^d3), 25);
    #####: 1604:    b3 = ROL64((a44^d4), 8);
    #####: 1605:    a10 =   b0 ^((~b1)&  b2 );
    #####: 1606:    a31 =   b1 ^((~b2)&  b3 );
    #####: 1607:    a02 =   b2 ^((~b3)&  b4 );
    #####: 1608:    a23 =   b3 ^((~b4)&  b0 );
    #####: 1609:    a44 =   b4 ^((~b0)&  b1 );
        -: 1610:
    #####: 1611:    b1 = ROL64((a40^d0), 36);
    #####: 1612:    b2 = ROL64((a11^d1), 10);
    #####: 1613:    b3 = ROL64((a32^d2), 15);
    #####: 1614:    b4 = ROL64((a03^d3), 56);
    #####: 1615:    b0 = ROL64((a24^d4), 27);
    #####: 1616:    a40 =   b0 ^((~b1)&  b2 );
    #####: 1617:    a11 =   b1 ^((~b2)&  b3 );
    #####: 1618:    a32 =   b2 ^((~b3)&  b4 );
    #####: 1619:    a03 =   b3 ^((~b4)&  b0 );
    #####: 1620:    a24 =   b4 ^((~b0)&  b1 );
        -: 1621:
    #####: 1622:    b3 = ROL64((a20^d0), 41);
    #####: 1623:    b4 = ROL64((a41^d1), 2);
    #####: 1624:    b0 = ROL64((a12^d2), 62);
    #####: 1625:    b1 = ROL64((a33^d3), 55);
    #####: 1626:    b2 = ROL64((a04^d4), 39);
    #####: 1627:    a20 =   b0 ^((~b1)&  b2 );
    #####: 1628:    a41 =   b1 ^((~b2)&  b3 );
    #####: 1629:    a12 =   b2 ^((~b3)&  b4 );
    #####: 1630:    a33 =   b3 ^((~b4)&  b0 );
    #####: 1631:    a04 =   b4 ^((~b0)&  b1 );
        -: 1632:
    #####: 1633:    c0 = a00^a30^a10^a40^a20;
    #####: 1634:    c1 = a21^a01^a31^a11^a41;
    #####: 1635:    c2 = a42^a22^a02^a32^a12;
    #####: 1636:    c3 = a13^a43^a23^a03^a33;
    #####: 1637:    c4 = a34^a14^a44^a24^a04;
    #####: 1638:    d0 = c4^ROL64(c1, 1);
    #####: 1639:    d1 = c0^ROL64(c2, 1);
    #####: 1640:    d2 = c1^ROL64(c3, 1);
    #####: 1641:    d3 = c2^ROL64(c4, 1);
    #####: 1642:    d4 = c3^ROL64(c0, 1);
        -: 1643:
    #####: 1644:    b0 = (a00^d0);
    #####: 1645:    b1 = ROL64((a01^d1), 44);
    #####: 1646:    b2 = ROL64((a02^d2), 43);
    #####: 1647:    b3 = ROL64((a03^d3), 21);
    #####: 1648:    b4 = ROL64((a04^d4), 14);
    #####: 1649:    a00 =   b0 ^((~b1)&  b2 );
    #####: 1650:    a00 ^= RC[i+3];
    #####: 1651:    a01 =   b1 ^((~b2)&  b3 );
    #####: 1652:    a02 =   b2 ^((~b3)&  b4 );
    #####: 1653:    a03 =   b3 ^((~b4)&  b0 );
    #####: 1654:    a04 =   b4 ^((~b0)&  b1 );
        -: 1655:
    #####: 1656:    b2 = ROL64((a10^d0), 3);
    #####: 1657:    b3 = ROL64((a11^d1), 45);
    #####: 1658:    b4 = ROL64((a12^d2), 61);
    #####: 1659:    b0 = ROL64((a13^d3), 28);
    #####: 1660:    b1 = ROL64((a14^d4), 20);
    #####: 1661:    a10 =   b0 ^((~b1)&  b2 );
    #####: 1662:    a11 =   b1 ^((~b2)&  b3 );
    #####: 1663:    a12 =   b2 ^((~b3)&  b4 );
    #####: 1664:    a13 =   b3 ^((~b4)&  b0 );
    #####: 1665:    a14 =   b4 ^((~b0)&  b1 );
        -: 1666:
    #####: 1667:    b4 = ROL64((a20^d0), 18);
    #####: 1668:    b0 = ROL64((a21^d1), 1);
    #####: 1669:    b1 = ROL64((a22^d2), 6);
    #####: 1670:    b2 = ROL64((a23^d3), 25);
    #####: 1671:    b3 = ROL64((a24^d4), 8);
    #####: 1672:    a20 =   b0 ^((~b1)&  b2 );
    #####: 1673:    a21 =   b1 ^((~b2)&  b3 );
    #####: 1674:    a22 =   b2 ^((~b3)&  b4 );
    #####: 1675:    a23 =   b3 ^((~b4)&  b0 );
    #####: 1676:    a24 =   b4 ^((~b0)&  b1 );
        -: 1677:
    #####: 1678:    b1 = ROL64((a30^d0), 36);
    #####: 1679:    b2 = ROL64((a31^d1), 10);
    #####: 1680:    b3 = ROL64((a32^d2), 15);
    #####: 1681:    b4 = ROL64((a33^d3), 56);
    #####: 1682:    b0 = ROL64((a34^d4), 27);
    #####: 1683:    a30 =   b0 ^((~b1)&  b2 );
    #####: 1684:    a31 =   b1 ^((~b2)&  b3 );
    #####: 1685:    a32 =   b2 ^((~b3)&  b4 );
    #####: 1686:    a33 =   b3 ^((~b4)&  b0 );
    #####: 1687:    a34 =   b4 ^((~b0)&  b1 );
        -: 1688:
    #####: 1689:    b3 = ROL64((a40^d0), 41);
    #####: 1690:    b4 = ROL64((a41^d1), 2);
    #####: 1691:    b0 = ROL64((a42^d2), 62);
    #####: 1692:    b1 = ROL64((a43^d3), 55);
    #####: 1693:    b2 = ROL64((a44^d4), 39);
    #####: 1694:    a40 =   b0 ^((~b1)&  b2 );
    #####: 1695:    a41 =   b1 ^((~b2)&  b3 );
    #####: 1696:    a42 =   b2 ^((~b3)&  b4 );
    #####: 1697:    a43 =   b3 ^((~b4)&  b0 );
    #####: 1698:    a44 =   b4 ^((~b0)&  b1 );
        -: 1699:  }
    #####: 1700:}
        -: 1701:
        -: 1702:/*
        -: 1703:** Initialize a new hash.  iSize determines the size of the hash
        -: 1704:** in bits and should be one of 224, 256, 384, or 512.  Or iSize
        -: 1705:** can be zero to use the default hash size of 256 bits.
        -: 1706:*/
    #####: 1707:static void SHA3Init(SHA3Context *p, int iSize){
    #####: 1708:  memset(p, 0, sizeof(*p));
    #####: 1709:  if( iSize>=128 && iSize<=512 ){
    #####: 1710:    p->nRate = (1600 - ((iSize + 31)&~31)*2)/8;
        -: 1711:  }else{
    #####: 1712:    p->nRate = (1600 - 2*256)/8;
        -: 1713:  }
        -: 1714:#if SHA3_BYTEORDER==1234
        -: 1715:  /* Known to be little-endian at compile-time. No-op */
        -: 1716:#elif SHA3_BYTEORDER==4321
        -: 1717:  p->ixMask = 7;  /* Big-endian */
        -: 1718:#else
        -: 1719:  {
        -: 1720:    static unsigned int one = 1;
    #####: 1721:    if( 1==*(unsigned char*)&one ){
        -: 1722:      /* Little endian.  No byte swapping. */
    #####: 1723:      p->ixMask = 0;
        -: 1724:    }else{
        -: 1725:      /* Big endian.  Byte swap. */
    #####: 1726:      p->ixMask = 7;
        -: 1727:    }
        -: 1728:  }
        -: 1729:#endif
    #####: 1730:}
        -: 1731:
        -: 1732:/*
        -: 1733:** Make consecutive calls to the SHA3Update function to add new content
        -: 1734:** to the hash
        -: 1735:*/
    #####: 1736:static void SHA3Update(
        -: 1737:  SHA3Context *p,
        -: 1738:  const unsigned char *aData,
        -: 1739:  unsigned int nData
        -: 1740:){
    #####: 1741:  unsigned int i = 0;
        -: 1742:#if SHA3_BYTEORDER==1234
        -: 1743:  if( (p->nLoaded % 8)==0 && ((aData - (const unsigned char*)0)&7)==0 ){
        -: 1744:    for(; i+7<nData; i+=8){
        -: 1745:      p->u.s[p->nLoaded/8] ^= *(u64*)&aData[i];
        -: 1746:      p->nLoaded += 8;
        -: 1747:      if( p->nLoaded>=p->nRate ){
        -: 1748:        KeccakF1600Step(p);
        -: 1749:        p->nLoaded = 0;
        -: 1750:      }
        -: 1751:    }
        -: 1752:  }
        -: 1753:#endif
    #####: 1754:  for(; i<nData; i++){
        -: 1755:#if SHA3_BYTEORDER==1234
        -: 1756:    p->u.x[p->nLoaded] ^= aData[i];
        -: 1757:#elif SHA3_BYTEORDER==4321
        -: 1758:    p->u.x[p->nLoaded^0x07] ^= aData[i];
        -: 1759:#else
    #####: 1760:    p->u.x[p->nLoaded^p->ixMask] ^= aData[i];
        -: 1761:#endif
    #####: 1762:    p->nLoaded++;
    #####: 1763:    if( p->nLoaded==p->nRate ){
    #####: 1764:      KeccakF1600Step(p);
    #####: 1765:      p->nLoaded = 0;
        -: 1766:    }
        -: 1767:  }
    #####: 1768:}
        -: 1769:
        -: 1770:/*
        -: 1771:** After all content has been added, invoke SHA3Final() to compute
        -: 1772:** the final hash.  The function returns a pointer to the binary
        -: 1773:** hash value.
        -: 1774:*/
    #####: 1775:static unsigned char *SHA3Final(SHA3Context *p){
        -: 1776:  unsigned int i;
    #####: 1777:  if( p->nLoaded==p->nRate-1 ){
    #####: 1778:    const unsigned char c1 = 0x86;
    #####: 1779:    SHA3Update(p, &c1, 1);
        -: 1780:  }else{
    #####: 1781:    const unsigned char c2 = 0x06;
    #####: 1782:    const unsigned char c3 = 0x80;
    #####: 1783:    SHA3Update(p, &c2, 1);
    #####: 1784:    p->nLoaded = p->nRate - 1;
    #####: 1785:    SHA3Update(p, &c3, 1);
        -: 1786:  }
    #####: 1787:  for(i=0; i<p->nRate; i++){
    #####: 1788:    p->u.x[i+p->nRate] = p->u.x[i^p->ixMask];
        -: 1789:  }
    #####: 1790:  return &p->u.x[p->nRate];
        -: 1791:}
        -: 1792:/* End of the hashing logic
        -: 1793:*****************************************************************************/
        -: 1794:
        -: 1795:/*
        -: 1796:** Implementation of the sha3(X,SIZE) function.
        -: 1797:**
        -: 1798:** Return a BLOB which is the SIZE-bit SHA3 hash of X.  The default
        -: 1799:** size is 256.  If X is a BLOB, it is hashed as is.  
        -: 1800:** For all other non-NULL types of input, X is converted into a UTF-8 string
        -: 1801:** and the string is hashed without the trailing 0x00 terminator.  The hash
        -: 1802:** of a NULL value is NULL.
        -: 1803:*/
    #####: 1804:static void sha3Func(
        -: 1805:  sqlite3_context *context,
        -: 1806:  int argc,
        -: 1807:  sqlite3_value **argv
        -: 1808:){
        -: 1809:  SHA3Context cx;
    #####: 1810:  int eType = sqlite3_value_type(argv[0]);
    #####: 1811:  int nByte = sqlite3_value_bytes(argv[0]);
        -: 1812:  int iSize;
    #####: 1813:  if( argc==1 ){
    #####: 1814:    iSize = 256;
        -: 1815:  }else{
    #####: 1816:    iSize = sqlite3_value_int(argv[1]);
    #####: 1817:    if( iSize!=224 && iSize!=256 && iSize!=384 && iSize!=512 ){
    #####: 1818:      sqlite3_result_error(context, "SHA3 size should be one of: 224 256 "
        -: 1819:                                    "384 512", -1);
    #####: 1820:      return;
        -: 1821:    }
        -: 1822:  }
    #####: 1823:  if( eType==SQLITE_NULL ) return;
    #####: 1824:  SHA3Init(&cx, iSize);
    #####: 1825:  if( eType==SQLITE_BLOB ){
    #####: 1826:    SHA3Update(&cx, sqlite3_value_blob(argv[0]), nByte);
        -: 1827:  }else{
    #####: 1828:    SHA3Update(&cx, sqlite3_value_text(argv[0]), nByte);
        -: 1829:  }
    #####: 1830:  sqlite3_result_blob(context, SHA3Final(&cx), iSize/8, SQLITE_TRANSIENT);
        -: 1831:}
        -: 1832:
        -: 1833:/* Compute a string using sqlite3_vsnprintf() with a maximum length
        -: 1834:** of 50 bytes and add it to the hash.
        -: 1835:*/
    #####: 1836:static void hash_step_vformat(
        -: 1837:  SHA3Context *p,                 /* Add content to this context */
        -: 1838:  const char *zFormat,
        -: 1839:  ...
        -: 1840:){
        -: 1841:  va_list ap;
        -: 1842:  int n;
        -: 1843:  char zBuf[50];
    #####: 1844:  va_start(ap, zFormat);
    #####: 1845:  sqlite3_vsnprintf(sizeof(zBuf),zBuf,zFormat,ap);
    #####: 1846:  va_end(ap);
    #####: 1847:  n = (int)strlen(zBuf);
    #####: 1848:  SHA3Update(p, (unsigned char*)zBuf, n);
    #####: 1849:}
        -: 1850:
        -: 1851:/*
        -: 1852:** Implementation of the sha3_query(SQL,SIZE) function.
        -: 1853:**
        -: 1854:** This function compiles and runs the SQL statement(s) given in the
        -: 1855:** argument. The results are hashed using a SIZE-bit SHA3.  The default
        -: 1856:** size is 256.
        -: 1857:**
        -: 1858:** The format of the byte stream that is hashed is summarized as follows:
        -: 1859:**
        -: 1860:**       S<n>:<sql>
        -: 1861:**       R
        -: 1862:**       N
        -: 1863:**       I<int>
        -: 1864:**       F<ieee-float>
        -: 1865:**       B<size>:<bytes>
        -: 1866:**       T<size>:<text>
        -: 1867:**
        -: 1868:** <sql> is the original SQL text for each statement run and <n> is
        -: 1869:** the size of that text.  The SQL text is UTF-8.  A single R character
        -: 1870:** occurs before the start of each row.  N means a NULL value.
        -: 1871:** I mean an 8-byte little-endian integer <int>.  F is a floating point
        -: 1872:** number with an 8-byte little-endian IEEE floating point value <ieee-float>.
        -: 1873:** B means blobs of <size> bytes.  T means text rendered as <size>
        -: 1874:** bytes of UTF-8.  The <n> and <size> values are expressed as an ASCII
        -: 1875:** text integers.
        -: 1876:**
        -: 1877:** For each SQL statement in the X input, there is one S segment.  Each
        -: 1878:** S segment is followed by zero or more R segments, one for each row in the
        -: 1879:** result set.  After each R, there are one or more N, I, F, B, or T segments,
        -: 1880:** one for each column in the result set.  Segments are concatentated directly
        -: 1881:** with no delimiters of any kind.
        -: 1882:*/
    #####: 1883:static void sha3QueryFunc(
        -: 1884:  sqlite3_context *context,
        -: 1885:  int argc,
        -: 1886:  sqlite3_value **argv
        -: 1887:){
    #####: 1888:  sqlite3 *db = sqlite3_context_db_handle(context);
    #####: 1889:  const char *zSql = (const char*)sqlite3_value_text(argv[0]);
    #####: 1890:  sqlite3_stmt *pStmt = 0;
        -: 1891:  int nCol;                   /* Number of columns in the result set */
        -: 1892:  int i;                      /* Loop counter */
        -: 1893:  int rc;
        -: 1894:  int n;
        -: 1895:  const char *z;
        -: 1896:  SHA3Context cx;
        -: 1897:  int iSize;
        -: 1898:
    #####: 1899:  if( argc==1 ){
    #####: 1900:    iSize = 256;
        -: 1901:  }else{
    #####: 1902:    iSize = sqlite3_value_int(argv[1]);
    #####: 1903:    if( iSize!=224 && iSize!=256 && iSize!=384 && iSize!=512 ){
    #####: 1904:      sqlite3_result_error(context, "SHA3 size should be one of: 224 256 "
        -: 1905:                                    "384 512", -1);
    #####: 1906:      return;
        -: 1907:    }
        -: 1908:  }
    #####: 1909:  if( zSql==0 ) return;
    #####: 1910:  SHA3Init(&cx, iSize);
    #####: 1911:  while( zSql[0] ){
    #####: 1912:    rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, &zSql);
    #####: 1913:    if( rc ){
    #####: 1914:      char *zMsg = sqlite3_mprintf("error SQL statement [%s]: %s",
        -: 1915:                                   zSql, sqlite3_errmsg(db));
    #####: 1916:      sqlite3_finalize(pStmt);
    #####: 1917:      sqlite3_result_error(context, zMsg, -1);
    #####: 1918:      sqlite3_free(zMsg);
    #####: 1919:      return;
        -: 1920:    }
    #####: 1921:    if( !sqlite3_stmt_readonly(pStmt) ){
    #####: 1922:      char *zMsg = sqlite3_mprintf("non-query: [%s]", sqlite3_sql(pStmt));
    #####: 1923:      sqlite3_finalize(pStmt);
    #####: 1924:      sqlite3_result_error(context, zMsg, -1);
    #####: 1925:      sqlite3_free(zMsg);
    #####: 1926:      return;
        -: 1927:    }
    #####: 1928:    nCol = sqlite3_column_count(pStmt);
    #####: 1929:    z = sqlite3_sql(pStmt);
    #####: 1930:    n = (int)strlen(z);
    #####: 1931:    hash_step_vformat(&cx,"S%d:",n);
    #####: 1932:    SHA3Update(&cx,(unsigned char*)z,n);
        -: 1933:
        -: 1934:    /* Compute a hash over the result of the query */
    #####: 1935:    while( SQLITE_ROW==sqlite3_step(pStmt) ){
    #####: 1936:      SHA3Update(&cx,(const unsigned char*)"R",1);
    #####: 1937:      for(i=0; i<nCol; i++){
    #####: 1938:        switch( sqlite3_column_type(pStmt,i) ){
    #####: 1939:          case SQLITE_NULL: {
    #####: 1940:            SHA3Update(&cx, (const unsigned char*)"N",1);
    #####: 1941:            break;
        -: 1942:          }
    #####: 1943:          case SQLITE_INTEGER: {
        -: 1944:            sqlite3_uint64 u;
        -: 1945:            int j;
        -: 1946:            unsigned char x[9];
    #####: 1947:            sqlite3_int64 v = sqlite3_column_int64(pStmt,i);
    #####: 1948:            memcpy(&u, &v, 8);
    #####: 1949:            for(j=8; j>=1; j--){
    #####: 1950:              x[j] = u & 0xff;
    #####: 1951:              u >>= 8;
        -: 1952:            }
    #####: 1953:            x[0] = 'I';
    #####: 1954:            SHA3Update(&cx, x, 9);
    #####: 1955:            break;
        -: 1956:          }
    #####: 1957:          case SQLITE_FLOAT: {
        -: 1958:            sqlite3_uint64 u;
        -: 1959:            int j;
        -: 1960:            unsigned char x[9];
    #####: 1961:            double r = sqlite3_column_double(pStmt,i);
    #####: 1962:            memcpy(&u, &r, 8);
    #####: 1963:            for(j=8; j>=1; j--){
    #####: 1964:              x[j] = u & 0xff;
    #####: 1965:              u >>= 8;
        -: 1966:            }
    #####: 1967:            x[0] = 'F';
    #####: 1968:            SHA3Update(&cx,x,9);
    #####: 1969:            break;
        -: 1970:          }
    #####: 1971:          case SQLITE_TEXT: {
    #####: 1972:            int n2 = sqlite3_column_bytes(pStmt, i);
    #####: 1973:            const unsigned char *z2 = sqlite3_column_text(pStmt, i);
    #####: 1974:            hash_step_vformat(&cx,"T%d:",n2);
    #####: 1975:            SHA3Update(&cx, z2, n2);
    #####: 1976:            break;
        -: 1977:          }
    #####: 1978:          case SQLITE_BLOB: {
    #####: 1979:            int n2 = sqlite3_column_bytes(pStmt, i);
    #####: 1980:            const unsigned char *z2 = sqlite3_column_blob(pStmt, i);
    #####: 1981:            hash_step_vformat(&cx,"B%d:",n2);
    #####: 1982:            SHA3Update(&cx, z2, n2);
    #####: 1983:            break;
        -: 1984:          }
        -: 1985:        }
        -: 1986:      }
        -: 1987:    }
    #####: 1988:    sqlite3_finalize(pStmt);
        -: 1989:  }
    #####: 1990:  sqlite3_result_blob(context, SHA3Final(&cx), iSize/8, SQLITE_TRANSIENT);
        -: 1991:}
        -: 1992:
        -: 1993:
        -: 1994:#ifdef _WIN32
        -: 1995:
        -: 1996:#endif
        2: 1997:int sqlite3_shathree_init(
        -: 1998:  sqlite3 *db,
        -: 1999:  char **pzErrMsg,
        -: 2000:  const sqlite3_api_routines *pApi
        -: 2001:){
        2: 2002:  int rc = SQLITE_OK;
        -: 2003:  SQLITE_EXTENSION_INIT2(pApi);
        -: 2004:  (void)pzErrMsg;  /* Unused parameter */
        2: 2005:  rc = sqlite3_create_function(db, "sha3", 1, SQLITE_UTF8, 0,
        -: 2006:                               sha3Func, 0, 0);
        2: 2007:  if( rc==SQLITE_OK ){
        2: 2008:    rc = sqlite3_create_function(db, "sha3", 2, SQLITE_UTF8, 0,
        -: 2009:                                 sha3Func, 0, 0);
        -: 2010:  }
        2: 2011:  if( rc==SQLITE_OK ){
        2: 2012:    rc = sqlite3_create_function(db, "sha3_query", 1, SQLITE_UTF8, 0,
        -: 2013:                                 sha3QueryFunc, 0, 0);
        -: 2014:  }
        2: 2015:  if( rc==SQLITE_OK ){
        2: 2016:    rc = sqlite3_create_function(db, "sha3_query", 2, SQLITE_UTF8, 0,
        -: 2017:                                 sha3QueryFunc, 0, 0);
        -: 2018:  }
        2: 2019:  return rc;
        -: 2020:}
        -: 2021:
        -: 2022:/************************* End ../ext/misc/shathree.c ********************/
        -: 2023:/************************* Begin ../ext/misc/fileio.c ******************/
        -: 2024:/*
        -: 2025:** 2014-06-13
        -: 2026:**
        -: 2027:** The author disclaims copyright to this source code.  In place of
        -: 2028:** a legal notice, here is a blessing:
        -: 2029:**
        -: 2030:**    May you do good and not evil.
        -: 2031:**    May you find forgiveness for yourself and forgive others.
        -: 2032:**    May you share freely, never taking more than you give.
        -: 2033:**
        -: 2034:******************************************************************************
        -: 2035:**
        -: 2036:** This SQLite extension implements SQL functions readfile() and
        -: 2037:** writefile(), and eponymous virtual type "fsdir".
        -: 2038:**
        -: 2039:** WRITEFILE(FILE, DATA [, MODE [, MTIME]]):
        -: 2040:**
        -: 2041:**   If neither of the optional arguments is present, then this UDF
        -: 2042:**   function writes blob DATA to file FILE. If successful, the number
        -: 2043:**   of bytes written is returned. If an error occurs, NULL is returned.
        -: 2044:**
        -: 2045:**   If the first option argument - MODE - is present, then it must
        -: 2046:**   be passed an integer value that corresponds to a POSIX mode
        -: 2047:**   value (file type + permissions, as returned in the stat.st_mode
        -: 2048:**   field by the stat() system call). Three types of files may
        -: 2049:**   be written/created:
        -: 2050:**
        -: 2051:**     regular files:  (mode & 0170000)==0100000
        -: 2052:**     symbolic links: (mode & 0170000)==0120000
        -: 2053:**     directories:    (mode & 0170000)==0040000
        -: 2054:**
        -: 2055:**   For a directory, the DATA is ignored. For a symbolic link, it is
        -: 2056:**   interpreted as text and used as the target of the link. For a
        -: 2057:**   regular file, it is interpreted as a blob and written into the
        -: 2058:**   named file. Regardless of the type of file, its permissions are
        -: 2059:**   set to (mode & 0777) before returning.
        -: 2060:**
        -: 2061:**   If the optional MTIME argument is present, then it is interpreted
        -: 2062:**   as an integer - the number of seconds since the unix epoch. The
        -: 2063:**   modification-time of the target file is set to this value before
        -: 2064:**   returning.
        -: 2065:**
        -: 2066:**   If three or more arguments are passed to this function and an
        -: 2067:**   error is encountered, an exception is raised.
        -: 2068:**
        -: 2069:** READFILE(FILE):
        -: 2070:**
        -: 2071:**   Read and return the contents of file FILE (type blob) from disk.
        -: 2072:**
        -: 2073:** FSDIR:
        -: 2074:**
        -: 2075:**   Used as follows:
        -: 2076:**
        -: 2077:**     SELECT * FROM fsdir($path [, $dir]);
        -: 2078:**
        -: 2079:**   Parameter $path is an absolute or relative pathname. If the file that it
        -: 2080:**   refers to does not exist, it is an error. If the path refers to a regular
        -: 2081:**   file or symbolic link, it returns a single row. Or, if the path refers
        -: 2082:**   to a directory, it returns one row for the directory, and one row for each
        -: 2083:**   file within the hierarchy rooted at $path.
        -: 2084:**
        -: 2085:**   Each row has the following columns:
        -: 2086:**
        -: 2087:**     name:  Path to file or directory (text value).
        -: 2088:**     mode:  Value of stat.st_mode for directory entry (an integer).
        -: 2089:**     mtime: Value of stat.st_mtime for directory entry (an integer).
        -: 2090:**     data:  For a regular file, a blob containing the file data. For a
        -: 2091:**            symlink, a text value containing the text of the link. For a
        -: 2092:**            directory, NULL.
        -: 2093:**
        -: 2094:**   If a non-NULL value is specified for the optional $dir parameter and
        -: 2095:**   $path is a relative path, then $path is interpreted relative to $dir. 
        -: 2096:**   And the paths returned in the "name" column of the table are also 
        -: 2097:**   relative to directory $dir.
        -: 2098:*/
        -: 2099:SQLITE_EXTENSION_INIT1
        -: 2100:#include <stdio.h>
        -: 2101:#include <string.h>
        -: 2102:#include <assert.h>
        -: 2103:
        -: 2104:#include <sys/types.h>
        -: 2105:#include <sys/stat.h>
        -: 2106:#include <fcntl.h>
        -: 2107:#if !defined(_WIN32) && !defined(WIN32)
        -: 2108:#  include <unistd.h>
        -: 2109:#  include <dirent.h>
        -: 2110:#  include <utime.h>
        -: 2111:#  include <sys/time.h>
        -: 2112:#else
        -: 2113:#  include "windows.h"
        -: 2114:#  include <io.h>
        -: 2115:#  include <direct.h>
        -: 2116:/* #  include "test_windirent.h" */
        -: 2117:#  define dirent DIRENT
        -: 2118:#  ifndef chmod
        -: 2119:#    define chmod _chmod
        -: 2120:#  endif
        -: 2121:#  ifndef stat
        -: 2122:#    define stat _stat
        -: 2123:#  endif
        -: 2124:#  define mkdir(path,mode) _mkdir(path)
        -: 2125:#  define lstat(path,buf) stat(path,buf)
        -: 2126:#endif
        -: 2127:#include <time.h>
        -: 2128:#include <errno.h>
        -: 2129:
        -: 2130:
        -: 2131:/*
        -: 2132:** Structure of the fsdir() table-valued function
        -: 2133:*/
        -: 2134:                 /*    0    1    2     3    4           5             */
        -: 2135:#define FSDIR_SCHEMA "(name,mode,mtime,data,path HIDDEN,dir HIDDEN)"
        -: 2136:#define FSDIR_COLUMN_NAME     0     /* Name of the file */
        -: 2137:#define FSDIR_COLUMN_MODE     1     /* Access mode */
        -: 2138:#define FSDIR_COLUMN_MTIME    2     /* Last modification time */
        -: 2139:#define FSDIR_COLUMN_DATA     3     /* File content */
        -: 2140:#define FSDIR_COLUMN_PATH     4     /* Path to top of search */
        -: 2141:#define FSDIR_COLUMN_DIR      5     /* Path is relative to this directory */
        -: 2142:
        -: 2143:
        -: 2144:/*
        -: 2145:** Set the result stored by context ctx to a blob containing the 
        -: 2146:** contents of file zName.
        -: 2147:*/
    #####: 2148:static void readFileContents(sqlite3_context *ctx, const char *zName){
        -: 2149:  FILE *in;
        -: 2150:  long nIn;
        -: 2151:  void *pBuf;
        -: 2152:
    #####: 2153:  in = fopen(zName, "rb");
    #####: 2154:  if( in==0 ) return;
    #####: 2155:  fseek(in, 0, SEEK_END);
    #####: 2156:  nIn = ftell(in);
    #####: 2157:  rewind(in);
    #####: 2158:  pBuf = sqlite3_malloc( nIn );
    #####: 2159:  if( pBuf && 1==fread(pBuf, nIn, 1, in) ){
    #####: 2160:    sqlite3_result_blob(ctx, pBuf, nIn, sqlite3_free);
        -: 2161:  }else{
    #####: 2162:    sqlite3_free(pBuf);
        -: 2163:  }
    #####: 2164:  fclose(in);
        -: 2165:}
        -: 2166:
        -: 2167:/*
        -: 2168:** Implementation of the "readfile(X)" SQL function.  The entire content
        -: 2169:** of the file named X is read and returned as a BLOB.  NULL is returned
        -: 2170:** if the file does not exist or is unreadable.
        -: 2171:*/
    #####: 2172:static void readfileFunc(
        -: 2173:  sqlite3_context *context,
        -: 2174:  int argc,
        -: 2175:  sqlite3_value **argv
        -: 2176:){
        -: 2177:  const char *zName;
        -: 2178:  (void)(argc);  /* Unused parameter */
    #####: 2179:  zName = (const char*)sqlite3_value_text(argv[0]);
    #####: 2180:  if( zName==0 ) return;
    #####: 2181:  readFileContents(context, zName);
        -: 2182:}
        -: 2183:
        -: 2184:/*
        -: 2185:** Set the error message contained in context ctx to the results of
        -: 2186:** vprintf(zFmt, ...).
        -: 2187:*/
    #####: 2188:static void ctxErrorMsg(sqlite3_context *ctx, const char *zFmt, ...){
    #####: 2189:  char *zMsg = 0;
        -: 2190:  va_list ap;
    #####: 2191:  va_start(ap, zFmt);
    #####: 2192:  zMsg = sqlite3_vmprintf(zFmt, ap);
    #####: 2193:  sqlite3_result_error(ctx, zMsg, -1);
    #####: 2194:  sqlite3_free(zMsg);
    #####: 2195:  va_end(ap);
    #####: 2196:}
        -: 2197:
        -: 2198:#if defined(_WIN32)
        -: 2199:/*
        -: 2200:** This function is designed to convert a Win32 FILETIME structure into the
        -: 2201:** number of seconds since the Unix Epoch (1970-01-01 00:00:00 UTC).
        -: 2202:*/
        -: 2203:static sqlite3_uint64 fileTimeToUnixTime(
        -: 2204:  LPFILETIME pFileTime
        -: 2205:){
        -: 2206:  SYSTEMTIME epochSystemTime;
        -: 2207:  ULARGE_INTEGER epochIntervals;
        -: 2208:  FILETIME epochFileTime;
        -: 2209:  ULARGE_INTEGER fileIntervals;
        -: 2210:
        -: 2211:  memset(&epochSystemTime, 0, sizeof(SYSTEMTIME));
        -: 2212:  epochSystemTime.wYear = 1970;
        -: 2213:  epochSystemTime.wMonth = 1;
        -: 2214:  epochSystemTime.wDay = 1;
        -: 2215:  SystemTimeToFileTime(&epochSystemTime, &epochFileTime);
        -: 2216:  epochIntervals.LowPart = epochFileTime.dwLowDateTime;
        -: 2217:  epochIntervals.HighPart = epochFileTime.dwHighDateTime;
        -: 2218:
        -: 2219:  fileIntervals.LowPart = pFileTime->dwLowDateTime;
        -: 2220:  fileIntervals.HighPart = pFileTime->dwHighDateTime;
        -: 2221:
        -: 2222:  return (fileIntervals.QuadPart - epochIntervals.QuadPart) / 10000000;
        -: 2223:}
        -: 2224:
        -: 2225:/*
        -: 2226:** This function attempts to normalize the time values found in the stat()
        -: 2227:** buffer to UTC.  This is necessary on Win32, where the runtime library
        -: 2228:** appears to return these values as local times.
        -: 2229:*/
        -: 2230:static void statTimesToUtc(
        -: 2231:  const char *zPath,
        -: 2232:  struct stat *pStatBuf
        -: 2233:){
        -: 2234:  HANDLE hFindFile;
        -: 2235:  WIN32_FIND_DATAW fd;
        -: 2236:  LPWSTR zUnicodeName;
        -: 2237:  extern LPWSTR sqlite3_win32_utf8_to_unicode(const char*);
        -: 2238:  zUnicodeName = sqlite3_win32_utf8_to_unicode(zPath);
        -: 2239:  if( zUnicodeName ){
        -: 2240:    memset(&fd, 0, sizeof(WIN32_FIND_DATAW));
        -: 2241:    hFindFile = FindFirstFileW(zUnicodeName, &fd);
        -: 2242:    if( hFindFile!=NULL ){
        -: 2243:      pStatBuf->st_ctime = (time_t)fileTimeToUnixTime(&fd.ftCreationTime);
        -: 2244:      pStatBuf->st_atime = (time_t)fileTimeToUnixTime(&fd.ftLastAccessTime);
        -: 2245:      pStatBuf->st_mtime = (time_t)fileTimeToUnixTime(&fd.ftLastWriteTime);
        -: 2246:      FindClose(hFindFile);
        -: 2247:    }
        -: 2248:    sqlite3_free(zUnicodeName);
        -: 2249:  }
        -: 2250:}
        -: 2251:#endif
        -: 2252:
        -: 2253:/*
        -: 2254:** This function is used in place of stat().  On Windows, special handling
        -: 2255:** is required in order for the included time to be returned as UTC.  On all
        -: 2256:** other systems, this function simply calls stat().
        -: 2257:*/
    #####: 2258:static int fileStat(
        -: 2259:  const char *zPath,
        -: 2260:  struct stat *pStatBuf
        -: 2261:){
        -: 2262:#if defined(_WIN32)
        -: 2263:  int rc = stat(zPath, pStatBuf);
        -: 2264:  if( rc==0 ) statTimesToUtc(zPath, pStatBuf);
        -: 2265:  return rc;
        -: 2266:#else
    #####: 2267:  return stat(zPath, pStatBuf);
        -: 2268:#endif
        -: 2269:}
        -: 2270:
        -: 2271:/*
        -: 2272:** This function is used in place of lstat().  On Windows, special handling
        -: 2273:** is required in order for the included time to be returned as UTC.  On all
        -: 2274:** other systems, this function simply calls lstat().
        -: 2275:*/
    #####: 2276:static int fileLinkStat(
        -: 2277:  const char *zPath,
        -: 2278:  struct stat *pStatBuf
        -: 2279:){
        -: 2280:#if defined(_WIN32)
        -: 2281:  int rc = lstat(zPath, pStatBuf);
        -: 2282:  if( rc==0 ) statTimesToUtc(zPath, pStatBuf);
        -: 2283:  return rc;
        -: 2284:#else
    #####: 2285:  return lstat(zPath, pStatBuf);
        -: 2286:#endif
        -: 2287:}
        -: 2288:
        -: 2289:/*
        -: 2290:** Argument zFile is the name of a file that will be created and/or written
        -: 2291:** by SQL function writefile(). This function ensures that the directory
        -: 2292:** zFile will be written to exists, creating it if required. The permissions
        -: 2293:** for any path components created by this function are set to (mode&0777).
        -: 2294:**
        -: 2295:** If an OOM condition is encountered, SQLITE_NOMEM is returned. Otherwise,
        -: 2296:** SQLITE_OK is returned if the directory is successfully created, or
        -: 2297:** SQLITE_ERROR otherwise.
        -: 2298:*/
    #####: 2299:static int makeDirectory(
        -: 2300:  const char *zFile,
        -: 2301:  mode_t mode
        -: 2302:){
    #####: 2303:  char *zCopy = sqlite3_mprintf("%s", zFile);
    #####: 2304:  int rc = SQLITE_OK;
        -: 2305:
    #####: 2306:  if( zCopy==0 ){
    #####: 2307:    rc = SQLITE_NOMEM;
        -: 2308:  }else{
    #####: 2309:    int nCopy = (int)strlen(zCopy);
    #####: 2310:    int i = 1;
        -: 2311:
    #####: 2312:    while( rc==SQLITE_OK ){
        -: 2313:      struct stat sStat;
        -: 2314:      int rc2;
        -: 2315:
    #####: 2316:      for(; zCopy[i]!='/' && i<nCopy; i++);
    #####: 2317:      if( i==nCopy ) break;
    #####: 2318:      zCopy[i] = '\0';
        -: 2319:
    #####: 2320:      rc2 = fileStat(zCopy, &sStat);
    #####: 2321:      if( rc2!=0 ){
    #####: 2322:        if( mkdir(zCopy, mode & 0777) ) rc = SQLITE_ERROR;
        -: 2323:      }else{
    #####: 2324:        if( !S_ISDIR(sStat.st_mode) ) rc = SQLITE_ERROR;
        -: 2325:      }
    #####: 2326:      zCopy[i] = '/';
    #####: 2327:      i++;
        -: 2328:    }
        -: 2329:
    #####: 2330:    sqlite3_free(zCopy);
        -: 2331:  }
        -: 2332:
    #####: 2333:  return rc;
        -: 2334:}
        -: 2335:
        -: 2336:/*
        -: 2337:** This function does the work for the writefile() UDF. Refer to 
        -: 2338:** header comments at the top of this file for details.
        -: 2339:*/
    #####: 2340:static int writeFile(
        -: 2341:  sqlite3_context *pCtx,          /* Context to return bytes written in */
        -: 2342:  const char *zFile,              /* File to write */
        -: 2343:  sqlite3_value *pData,           /* Data to write */
        -: 2344:  mode_t mode,                    /* MODE parameter passed to writefile() */
        -: 2345:  sqlite3_int64 mtime             /* MTIME parameter (or -1 to not set time) */
        -: 2346:){
        -: 2347:#if !defined(_WIN32) && !defined(WIN32)
    #####: 2348:  if( S_ISLNK(mode) ){
    #####: 2349:    const char *zTo = (const char*)sqlite3_value_text(pData);
    #####: 2350:    if( symlink(zTo, zFile)<0 ) return 1;
        -: 2351:  }else
        -: 2352:#endif
        -: 2353:  {
    #####: 2354:    if( S_ISDIR(mode) ){
    #####: 2355:      if( mkdir(zFile, mode) ){
        -: 2356:        /* The mkdir() call to create the directory failed. This might not
        -: 2357:        ** be an error though - if there is already a directory at the same
        -: 2358:        ** path and either the permissions already match or can be changed
        -: 2359:        ** to do so using chmod(), it is not an error.  */
        -: 2360:        struct stat sStat;
    #####: 2361:        if( errno!=EEXIST
    #####: 2362:         || 0!=fileStat(zFile, &sStat)
    #####: 2363:         || !S_ISDIR(sStat.st_mode)
    #####: 2364:         || ((sStat.st_mode&0777)!=(mode&0777) && 0!=chmod(zFile, mode&0777))
        -: 2365:        ){
    #####: 2366:          return 1;
        -: 2367:        }
        -: 2368:      }
        -: 2369:    }else{
    #####: 2370:      sqlite3_int64 nWrite = 0;
        -: 2371:      const char *z;
    #####: 2372:      int rc = 0;
    #####: 2373:      FILE *out = fopen(zFile, "wb");
    #####: 2374:      if( out==0 ) return 1;
    #####: 2375:      z = (const char*)sqlite3_value_blob(pData);
    #####: 2376:      if( z ){
    #####: 2377:        sqlite3_int64 n = fwrite(z, 1, sqlite3_value_bytes(pData), out);
    #####: 2378:        nWrite = sqlite3_value_bytes(pData);
    #####: 2379:        if( nWrite!=n ){
    #####: 2380:          rc = 1;
        -: 2381:        }
        -: 2382:      }
    #####: 2383:      fclose(out);
    #####: 2384:      if( rc==0 && mode && chmod(zFile, mode & 0777) ){
    #####: 2385:        rc = 1;
        -: 2386:      }
    #####: 2387:      if( rc ) return 2;
    #####: 2388:      sqlite3_result_int64(pCtx, nWrite);
        -: 2389:    }
        -: 2390:  }
        -: 2391:
    #####: 2392:  if( mtime>=0 ){
        -: 2393:#if defined(_WIN32)
        -: 2394:    /* Windows */
        -: 2395:    FILETIME lastAccess;
        -: 2396:    FILETIME lastWrite;
        -: 2397:    SYSTEMTIME currentTime;
        -: 2398:    LONGLONG intervals;
        -: 2399:    HANDLE hFile;
        -: 2400:    LPWSTR zUnicodeName;
        -: 2401:    extern LPWSTR sqlite3_win32_utf8_to_unicode(const char*);
        -: 2402:
        -: 2403:    GetSystemTime(&currentTime);
        -: 2404:    SystemTimeToFileTime(&currentTime, &lastAccess);
        -: 2405:    intervals = Int32x32To64(mtime, 10000000) + 116444736000000000;
        -: 2406:    lastWrite.dwLowDateTime = (DWORD)intervals;
        -: 2407:    lastWrite.dwHighDateTime = intervals >> 32;
        -: 2408:    zUnicodeName = sqlite3_win32_utf8_to_unicode(zFile);
        -: 2409:    if( zUnicodeName==0 ){
        -: 2410:      return 1;
        -: 2411:    }
        -: 2412:    hFile = CreateFileW(
        -: 2413:      zUnicodeName, FILE_WRITE_ATTRIBUTES, 0, NULL, OPEN_EXISTING,
        -: 2414:      FILE_FLAG_BACKUP_SEMANTICS, NULL
        -: 2415:    );
        -: 2416:    sqlite3_free(zUnicodeName);
        -: 2417:    if( hFile!=INVALID_HANDLE_VALUE ){
        -: 2418:      BOOL bResult = SetFileTime(hFile, NULL, &lastAccess, &lastWrite);
        -: 2419:      CloseHandle(hFile);
        -: 2420:      return !bResult;
        -: 2421:    }else{
        -: 2422:      return 1;
        -: 2423:    }
        -: 2424:#elif defined(AT_FDCWD) && 0 /* utimensat() is not universally available */
        -: 2425:    /* Recent unix */
        -: 2426:    struct timespec times[2];
        -: 2427:    times[0].tv_nsec = times[1].tv_nsec = 0;
        -: 2428:    times[0].tv_sec = time(0);
        -: 2429:    times[1].tv_sec = mtime;
        -: 2430:    if( utimensat(AT_FDCWD, zFile, times, AT_SYMLINK_NOFOLLOW) ){
        -: 2431:      return 1;
        -: 2432:    }
        -: 2433:#else
        -: 2434:    /* Legacy unix */
        -: 2435:    struct timeval times[2];
    #####: 2436:    times[0].tv_usec = times[1].tv_usec = 0;
    #####: 2437:    times[0].tv_sec = time(0);
    #####: 2438:    times[1].tv_sec = mtime;
    #####: 2439:    if( utimes(zFile, times) ){
    #####: 2440:      return 1;
        -: 2441:    }
        -: 2442:#endif
        -: 2443:  }
        -: 2444:
    #####: 2445:  return 0;
        -: 2446:}
        -: 2447:
        -: 2448:/*
        -: 2449:** Implementation of the "writefile(W,X[,Y[,Z]]])" SQL function.  
        -: 2450:** Refer to header comments at the top of this file for details.
        -: 2451:*/
    #####: 2452:static void writefileFunc(
        -: 2453:  sqlite3_context *context,
        -: 2454:  int argc,
        -: 2455:  sqlite3_value **argv
        -: 2456:){
        -: 2457:  const char *zFile;
    #####: 2458:  mode_t mode = 0;
        -: 2459:  int res;
    #####: 2460:  sqlite3_int64 mtime = -1;
        -: 2461:
    #####: 2462:  if( argc<2 || argc>4 ){
    #####: 2463:    sqlite3_result_error(context, 
        -: 2464:        "wrong number of arguments to function writefile()", -1
        -: 2465:    );
    #####: 2466:    return;
        -: 2467:  }
        -: 2468:
    #####: 2469:  zFile = (const char*)sqlite3_value_text(argv[0]);
    #####: 2470:  if( zFile==0 ) return;
    #####: 2471:  if( argc>=3 ){
    #####: 2472:    mode = (mode_t)sqlite3_value_int(argv[2]);
        -: 2473:  }
    #####: 2474:  if( argc==4 ){
    #####: 2475:    mtime = sqlite3_value_int64(argv[3]);
        -: 2476:  }
        -: 2477:
    #####: 2478:  res = writeFile(context, zFile, argv[1], mode, mtime);
    #####: 2479:  if( res==1 && errno==ENOENT ){
    #####: 2480:    if( makeDirectory(zFile, mode)==SQLITE_OK ){
    #####: 2481:      res = writeFile(context, zFile, argv[1], mode, mtime);
        -: 2482:    }
        -: 2483:  }
        -: 2484:
    #####: 2485:  if( argc>2 && res!=0 ){
    #####: 2486:    if( S_ISLNK(mode) ){
    #####: 2487:      ctxErrorMsg(context, "failed to create symlink: %s", zFile);
    #####: 2488:    }else if( S_ISDIR(mode) ){
    #####: 2489:      ctxErrorMsg(context, "failed to create directory: %s", zFile);
        -: 2490:    }else{
    #####: 2491:      ctxErrorMsg(context, "failed to write file: %s", zFile);
        -: 2492:    }
        -: 2493:  }
        -: 2494:}
        -: 2495:
        -: 2496:/*
        -: 2497:** SQL function:   lsmode(MODE)
        -: 2498:**
        -: 2499:** Given a numberic st_mode from stat(), convert it into a human-readable
        -: 2500:** text string in the style of "ls -l".
        -: 2501:*/
    #####: 2502:static void lsModeFunc(
        -: 2503:  sqlite3_context *context,
        -: 2504:  int argc,
        -: 2505:  sqlite3_value **argv
        -: 2506:){
        -: 2507:  int i;
    #####: 2508:  int iMode = sqlite3_value_int(argv[0]);
        -: 2509:  char z[16];
        -: 2510:  (void)argc;
    #####: 2511:  if( S_ISLNK(iMode) ){
    #####: 2512:    z[0] = 'l';
    #####: 2513:  }else if( S_ISREG(iMode) ){
    #####: 2514:    z[0] = '-';
    #####: 2515:  }else if( S_ISDIR(iMode) ){
    #####: 2516:    z[0] = 'd';
        -: 2517:  }else{
    #####: 2518:    z[0] = '?';
        -: 2519:  }
    #####: 2520:  for(i=0; i<3; i++){
    #####: 2521:    int m = (iMode >> ((2-i)*3));
    #####: 2522:    char *a = &z[1 + i*3];
    #####: 2523:    a[0] = (m & 0x4) ? 'r' : '-';
    #####: 2524:    a[1] = (m & 0x2) ? 'w' : '-';
    #####: 2525:    a[2] = (m & 0x1) ? 'x' : '-';
        -: 2526:  }
    #####: 2527:  z[10] = '\0';
    #####: 2528:  sqlite3_result_text(context, z, -1, SQLITE_TRANSIENT);
    #####: 2529:}
        -: 2530:
        -: 2531:#ifndef SQLITE_OMIT_VIRTUALTABLE
        -: 2532:
        -: 2533:/* 
        -: 2534:** Cursor type for recursively iterating through a directory structure.
        -: 2535:*/
        -: 2536:typedef struct fsdir_cursor fsdir_cursor;
        -: 2537:typedef struct FsdirLevel FsdirLevel;
        -: 2538:
        -: 2539:struct FsdirLevel {
        -: 2540:  DIR *pDir;                 /* From opendir() */
        -: 2541:  char *zDir;                /* Name of directory (nul-terminated) */
        -: 2542:};
        -: 2543:
        -: 2544:struct fsdir_cursor {
        -: 2545:  sqlite3_vtab_cursor base;  /* Base class - must be first */
        -: 2546:
        -: 2547:  int nLvl;                  /* Number of entries in aLvl[] array */
        -: 2548:  int iLvl;                  /* Index of current entry */
        -: 2549:  FsdirLevel *aLvl;          /* Hierarchy of directories being traversed */
        -: 2550:
        -: 2551:  const char *zBase;
        -: 2552:  int nBase;
        -: 2553:
        -: 2554:  struct stat sStat;         /* Current lstat() results */
        -: 2555:  char *zPath;               /* Path to current entry */
        -: 2556:  sqlite3_int64 iRowid;      /* Current rowid */
        -: 2557:};
        -: 2558:
        -: 2559:typedef struct fsdir_tab fsdir_tab;
        -: 2560:struct fsdir_tab {
        -: 2561:  sqlite3_vtab base;         /* Base class - must be first */
        -: 2562:};
        -: 2563:
        -: 2564:/*
        -: 2565:** Construct a new fsdir virtual table object.
        -: 2566:*/
    #####: 2567:static int fsdirConnect(
        -: 2568:  sqlite3 *db,
        -: 2569:  void *pAux,
        -: 2570:  int argc, const char *const*argv,
        -: 2571:  sqlite3_vtab **ppVtab,
        -: 2572:  char **pzErr
        -: 2573:){
    #####: 2574:  fsdir_tab *pNew = 0;
        -: 2575:  int rc;
        -: 2576:  (void)pAux;
        -: 2577:  (void)argc;
        -: 2578:  (void)argv;
        -: 2579:  (void)pzErr;
    #####: 2580:  rc = sqlite3_declare_vtab(db, "CREATE TABLE x" FSDIR_SCHEMA);
    #####: 2581:  if( rc==SQLITE_OK ){
    #####: 2582:    pNew = (fsdir_tab*)sqlite3_malloc( sizeof(*pNew) );
    #####: 2583:    if( pNew==0 ) return SQLITE_NOMEM;
    #####: 2584:    memset(pNew, 0, sizeof(*pNew));
        -: 2585:  }
    #####: 2586:  *ppVtab = (sqlite3_vtab*)pNew;
    #####: 2587:  return rc;
        -: 2588:}
        -: 2589:
        -: 2590:/*
        -: 2591:** This method is the destructor for fsdir vtab objects.
        -: 2592:*/
    #####: 2593:static int fsdirDisconnect(sqlite3_vtab *pVtab){
    #####: 2594:  sqlite3_free(pVtab);
    #####: 2595:  return SQLITE_OK;
        -: 2596:}
        -: 2597:
        -: 2598:/*
        -: 2599:** Constructor for a new fsdir_cursor object.
        -: 2600:*/
    #####: 2601:static int fsdirOpen(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCursor){
        -: 2602:  fsdir_cursor *pCur;
        -: 2603:  (void)p;
    #####: 2604:  pCur = sqlite3_malloc( sizeof(*pCur) );
    #####: 2605:  if( pCur==0 ) return SQLITE_NOMEM;
    #####: 2606:  memset(pCur, 0, sizeof(*pCur));
    #####: 2607:  pCur->iLvl = -1;
    #####: 2608:  *ppCursor = &pCur->base;
    #####: 2609:  return SQLITE_OK;
        -: 2610:}
        -: 2611:
        -: 2612:/*
        -: 2613:** Reset a cursor back to the state it was in when first returned
        -: 2614:** by fsdirOpen().
        -: 2615:*/
    #####: 2616:static void fsdirResetCursor(fsdir_cursor *pCur){
        -: 2617:  int i;
    #####: 2618:  for(i=0; i<=pCur->iLvl; i++){
    #####: 2619:    FsdirLevel *pLvl = &pCur->aLvl[i];
    #####: 2620:    if( pLvl->pDir ) closedir(pLvl->pDir);
    #####: 2621:    sqlite3_free(pLvl->zDir);
        -: 2622:  }
    #####: 2623:  sqlite3_free(pCur->zPath);
    #####: 2624:  sqlite3_free(pCur->aLvl);
    #####: 2625:  pCur->aLvl = 0;
    #####: 2626:  pCur->zPath = 0;
    #####: 2627:  pCur->zBase = 0;
    #####: 2628:  pCur->nBase = 0;
    #####: 2629:  pCur->nLvl = 0;
    #####: 2630:  pCur->iLvl = -1;
    #####: 2631:  pCur->iRowid = 1;
    #####: 2632:}
        -: 2633:
        -: 2634:/*
        -: 2635:** Destructor for an fsdir_cursor.
        -: 2636:*/
    #####: 2637:static int fsdirClose(sqlite3_vtab_cursor *cur){
    #####: 2638:  fsdir_cursor *pCur = (fsdir_cursor*)cur;
        -: 2639:
    #####: 2640:  fsdirResetCursor(pCur);
    #####: 2641:  sqlite3_free(pCur);
    #####: 2642:  return SQLITE_OK;
        -: 2643:}
        -: 2644:
        -: 2645:/*
        -: 2646:** Set the error message for the virtual table associated with cursor
        -: 2647:** pCur to the results of vprintf(zFmt, ...).
        -: 2648:*/
    #####: 2649:static void fsdirSetErrmsg(fsdir_cursor *pCur, const char *zFmt, ...){
        -: 2650:  va_list ap;
    #####: 2651:  va_start(ap, zFmt);
    #####: 2652:  pCur->base.pVtab->zErrMsg = sqlite3_vmprintf(zFmt, ap);
    #####: 2653:  va_end(ap);
    #####: 2654:}
        -: 2655:
        -: 2656:
        -: 2657:/*
        -: 2658:** Advance an fsdir_cursor to its next row of output.
        -: 2659:*/
    #####: 2660:static int fsdirNext(sqlite3_vtab_cursor *cur){
    #####: 2661:  fsdir_cursor *pCur = (fsdir_cursor*)cur;
    #####: 2662:  mode_t m = pCur->sStat.st_mode;
        -: 2663:
    #####: 2664:  pCur->iRowid++;
    #####: 2665:  if( S_ISDIR(m) ){
        -: 2666:    /* Descend into this directory */
    #####: 2667:    int iNew = pCur->iLvl + 1;
        -: 2668:    FsdirLevel *pLvl;
    #####: 2669:    if( iNew>=pCur->nLvl ){
    #####: 2670:      int nNew = iNew+1;
    #####: 2671:      int nByte = nNew*sizeof(FsdirLevel);
    #####: 2672:      FsdirLevel *aNew = (FsdirLevel*)sqlite3_realloc(pCur->aLvl, nByte);
    #####: 2673:      if( aNew==0 ) return SQLITE_NOMEM;
    #####: 2674:      memset(&aNew[pCur->nLvl], 0, sizeof(FsdirLevel)*(nNew-pCur->nLvl));
    #####: 2675:      pCur->aLvl = aNew;
    #####: 2676:      pCur->nLvl = nNew;
        -: 2677:    }
    #####: 2678:    pCur->iLvl = iNew;
    #####: 2679:    pLvl = &pCur->aLvl[iNew];
        -: 2680:    
    #####: 2681:    pLvl->zDir = pCur->zPath;
    #####: 2682:    pCur->zPath = 0;
    #####: 2683:    pLvl->pDir = opendir(pLvl->zDir);
    #####: 2684:    if( pLvl->pDir==0 ){
    #####: 2685:      fsdirSetErrmsg(pCur, "cannot read directory: %s", pCur->zPath);
    #####: 2686:      return SQLITE_ERROR;
        -: 2687:    }
        -: 2688:  }
        -: 2689:
    #####: 2690:  while( pCur->iLvl>=0 ){
    #####: 2691:    FsdirLevel *pLvl = &pCur->aLvl[pCur->iLvl];
    #####: 2692:    struct dirent *pEntry = readdir(pLvl->pDir);
    #####: 2693:    if( pEntry ){
    #####: 2694:      if( pEntry->d_name[0]=='.' ){
    #####: 2695:       if( pEntry->d_name[1]=='.' && pEntry->d_name[2]=='\0' ) continue;
    #####: 2696:       if( pEntry->d_name[1]=='\0' ) continue;
        -: 2697:      }
    #####: 2698:      sqlite3_free(pCur->zPath);
    #####: 2699:      pCur->zPath = sqlite3_mprintf("%s/%s", pLvl->zDir, pEntry->d_name);
    #####: 2700:      if( pCur->zPath==0 ) return SQLITE_NOMEM;
    #####: 2701:      if( fileLinkStat(pCur->zPath, &pCur->sStat) ){
    #####: 2702:        fsdirSetErrmsg(pCur, "cannot stat file: %s", pCur->zPath);
    #####: 2703:        return SQLITE_ERROR;
        -: 2704:      }
    #####: 2705:      return SQLITE_OK;
        -: 2706:    }
    #####: 2707:    closedir(pLvl->pDir);
    #####: 2708:    sqlite3_free(pLvl->zDir);
    #####: 2709:    pLvl->pDir = 0;
    #####: 2710:    pLvl->zDir = 0;
    #####: 2711:    pCur->iLvl--;
        -: 2712:  }
        -: 2713:
        -: 2714:  /* EOF */
    #####: 2715:  sqlite3_free(pCur->zPath);
    #####: 2716:  pCur->zPath = 0;
    #####: 2717:  return SQLITE_OK;
        -: 2718:}
        -: 2719:
        -: 2720:/*
        -: 2721:** Return values of columns for the row at which the series_cursor
        -: 2722:** is currently pointing.
        -: 2723:*/
    #####: 2724:static int fsdirColumn(
        -: 2725:  sqlite3_vtab_cursor *cur,   /* The cursor */
        -: 2726:  sqlite3_context *ctx,       /* First argument to sqlite3_result_...() */
        -: 2727:  int i                       /* Which column to return */
        -: 2728:){
    #####: 2729:  fsdir_cursor *pCur = (fsdir_cursor*)cur;
    #####: 2730:  switch( i ){
    #####: 2731:    case FSDIR_COLUMN_NAME: {
    #####: 2732:      sqlite3_result_text(ctx, &pCur->zPath[pCur->nBase], -1, SQLITE_TRANSIENT);
    #####: 2733:      break;
        -: 2734:    }
        -: 2735:
    #####: 2736:    case FSDIR_COLUMN_MODE:
    #####: 2737:      sqlite3_result_int64(ctx, pCur->sStat.st_mode);
    #####: 2738:      break;
        -: 2739:
    #####: 2740:    case FSDIR_COLUMN_MTIME:
    #####: 2741:      sqlite3_result_int64(ctx, pCur->sStat.st_mtime);
    #####: 2742:      break;
        -: 2743:
    #####: 2744:    case FSDIR_COLUMN_DATA: {
    #####: 2745:      mode_t m = pCur->sStat.st_mode;
    #####: 2746:      if( S_ISDIR(m) ){
    #####: 2747:        sqlite3_result_null(ctx);
        -: 2748:#if !defined(_WIN32) && !defined(WIN32)
    #####: 2749:      }else if( S_ISLNK(m) ){
        -: 2750:        char aStatic[64];
    #####: 2751:        char *aBuf = aStatic;
    #####: 2752:        int nBuf = 64;
        -: 2753:        int n;
        -: 2754:
        -: 2755:        while( 1 ){
    #####: 2756:          n = readlink(pCur->zPath, aBuf, nBuf);
    #####: 2757:          if( n<nBuf ) break;
    #####: 2758:          if( aBuf!=aStatic ) sqlite3_free(aBuf);
    #####: 2759:          nBuf = nBuf*2;
    #####: 2760:          aBuf = sqlite3_malloc(nBuf);
    #####: 2761:          if( aBuf==0 ){
    #####: 2762:            sqlite3_result_error_nomem(ctx);
    #####: 2763:            return SQLITE_NOMEM;
        -: 2764:          }
        -: 2765:        }
        -: 2766:
    #####: 2767:        sqlite3_result_text(ctx, aBuf, n, SQLITE_TRANSIENT);
    #####: 2768:        if( aBuf!=aStatic ) sqlite3_free(aBuf);
        -: 2769:#endif
        -: 2770:      }else{
    #####: 2771:        readFileContents(ctx, pCur->zPath);
        -: 2772:      }
        -: 2773:    }
        -: 2774:    case FSDIR_COLUMN_PATH:
        -: 2775:    default: {
        -: 2776:      /* The FSDIR_COLUMN_PATH and FSDIR_COLUMN_DIR are input parameters.
        -: 2777:      ** always return their values as NULL */
    #####: 2778:      break;
        -: 2779:    }
        -: 2780:  }
    #####: 2781:  return SQLITE_OK;
        -: 2782:}
        -: 2783:
        -: 2784:/*
        -: 2785:** Return the rowid for the current row. In this implementation, the
        -: 2786:** first row returned is assigned rowid value 1, and each subsequent
        -: 2787:** row a value 1 more than that of the previous.
        -: 2788:*/
    #####: 2789:static int fsdirRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){
    #####: 2790:  fsdir_cursor *pCur = (fsdir_cursor*)cur;
    #####: 2791:  *pRowid = pCur->iRowid;
    #####: 2792:  return SQLITE_OK;
        -: 2793:}
        -: 2794:
        -: 2795:/*
        -: 2796:** Return TRUE if the cursor has been moved off of the last
        -: 2797:** row of output.
        -: 2798:*/
    #####: 2799:static int fsdirEof(sqlite3_vtab_cursor *cur){
    #####: 2800:  fsdir_cursor *pCur = (fsdir_cursor*)cur;
    #####: 2801:  return (pCur->zPath==0);
        -: 2802:}
        -: 2803:
        -: 2804:/*
        -: 2805:** xFilter callback.
        -: 2806:**
        -: 2807:** idxNum==1   PATH parameter only
        -: 2808:** idxNum==2   Both PATH and DIR supplied
        -: 2809:*/
    #####: 2810:static int fsdirFilter(
        -: 2811:  sqlite3_vtab_cursor *cur, 
        -: 2812:  int idxNum, const char *idxStr,
        -: 2813:  int argc, sqlite3_value **argv
        -: 2814:){
    #####: 2815:  const char *zDir = 0;
    #####: 2816:  fsdir_cursor *pCur = (fsdir_cursor*)cur;
        -: 2817:  (void)idxStr;
    #####: 2818:  fsdirResetCursor(pCur);
        -: 2819:
    #####: 2820:  if( idxNum==0 ){
    #####: 2821:    fsdirSetErrmsg(pCur, "table function fsdir requires an argument");
    #####: 2822:    return SQLITE_ERROR;
        -: 2823:  }
        -: 2824:
        -: 2825:  assert( argc==idxNum && (argc==1 || argc==2) );
    #####: 2826:  zDir = (const char*)sqlite3_value_text(argv[0]);
    #####: 2827:  if( zDir==0 ){
    #####: 2828:    fsdirSetErrmsg(pCur, "table function fsdir requires a non-NULL argument");
    #####: 2829:    return SQLITE_ERROR;
        -: 2830:  }
    #####: 2831:  if( argc==2 ){
    #####: 2832:    pCur->zBase = (const char*)sqlite3_value_text(argv[1]);
        -: 2833:  }
    #####: 2834:  if( pCur->zBase ){
    #####: 2835:    pCur->nBase = (int)strlen(pCur->zBase)+1;
    #####: 2836:    pCur->zPath = sqlite3_mprintf("%s/%s", pCur->zBase, zDir);
        -: 2837:  }else{
    #####: 2838:    pCur->zPath = sqlite3_mprintf("%s", zDir);
        -: 2839:  }
        -: 2840:
    #####: 2841:  if( pCur->zPath==0 ){
    #####: 2842:    return SQLITE_NOMEM;
        -: 2843:  }
    #####: 2844:  if( fileLinkStat(pCur->zPath, &pCur->sStat) ){
    #####: 2845:    fsdirSetErrmsg(pCur, "cannot stat file: %s", pCur->zPath);
    #####: 2846:    return SQLITE_ERROR;
        -: 2847:  }
        -: 2848:
    #####: 2849:  return SQLITE_OK;
        -: 2850:}
        -: 2851:
        -: 2852:/*
        -: 2853:** SQLite will invoke this method one or more times while planning a query
        -: 2854:** that uses the generate_series virtual table.  This routine needs to create
        -: 2855:** a query plan for each invocation and compute an estimated cost for that
        -: 2856:** plan.
        -: 2857:**
        -: 2858:** In this implementation idxNum is used to represent the
        -: 2859:** query plan.  idxStr is unused.
        -: 2860:**
        -: 2861:** The query plan is represented by values of idxNum:
        -: 2862:**
        -: 2863:**  (1)  The path value is supplied by argv[0]
        -: 2864:**  (2)  Path is in argv[0] and dir is in argv[1]
        -: 2865:*/
    #####: 2866:static int fsdirBestIndex(
        -: 2867:  sqlite3_vtab *tab,
        -: 2868:  sqlite3_index_info *pIdxInfo
        -: 2869:){
        -: 2870:  int i;                 /* Loop over constraints */
    #####: 2871:  int idxPath = -1;      /* Index in pIdxInfo->aConstraint of PATH= */
    #####: 2872:  int idxDir = -1;       /* Index in pIdxInfo->aConstraint of DIR= */
    #####: 2873:  int seenPath = 0;      /* True if an unusable PATH= constraint is seen */
    #####: 2874:  int seenDir = 0;       /* True if an unusable DIR= constraint is seen */
        -: 2875:  const struct sqlite3_index_constraint *pConstraint;
        -: 2876:
        -: 2877:  (void)tab;
    #####: 2878:  pConstraint = pIdxInfo->aConstraint;
    #####: 2879:  for(i=0; i<pIdxInfo->nConstraint; i++, pConstraint++){
    #####: 2880:    if( pConstraint->op!=SQLITE_INDEX_CONSTRAINT_EQ ) continue;
    #####: 2881:    switch( pConstraint->iColumn ){
    #####: 2882:      case FSDIR_COLUMN_PATH: {
    #####: 2883:        if( pConstraint->usable ){
    #####: 2884:          idxPath = i;
    #####: 2885:          seenPath = 0;
    #####: 2886:        }else if( idxPath<0 ){
    #####: 2887:          seenPath = 1;
        -: 2888:        }
    #####: 2889:        break;
        -: 2890:      }
    #####: 2891:      case FSDIR_COLUMN_DIR: {
    #####: 2892:        if( pConstraint->usable ){
    #####: 2893:          idxDir = i;
    #####: 2894:          seenDir = 0;
    #####: 2895:        }else if( idxDir<0 ){
    #####: 2896:          seenDir = 1;
        -: 2897:        }
    #####: 2898:        break;
        -: 2899:      }
        -: 2900:    } 
        -: 2901:  }
    #####: 2902:  if( seenPath || seenDir ){
        -: 2903:    /* If input parameters are unusable, disallow this plan */
    #####: 2904:    return SQLITE_CONSTRAINT;
        -: 2905:  }
        -: 2906:
    #####: 2907:  if( idxPath<0 ){
    #####: 2908:    pIdxInfo->idxNum = 0;
        -: 2909:    /* The pIdxInfo->estimatedCost should have been initialized to a huge
        -: 2910:    ** number.  Leave it unchanged. */
    #####: 2911:    pIdxInfo->estimatedRows = 0x7fffffff;
        -: 2912:  }else{
    #####: 2913:    pIdxInfo->aConstraintUsage[idxPath].omit = 1;
    #####: 2914:    pIdxInfo->aConstraintUsage[idxPath].argvIndex = 1;
    #####: 2915:    if( idxDir>=0 ){
    #####: 2916:      pIdxInfo->aConstraintUsage[idxDir].omit = 1;
    #####: 2917:      pIdxInfo->aConstraintUsage[idxDir].argvIndex = 2;
    #####: 2918:      pIdxInfo->idxNum = 2;
    #####: 2919:      pIdxInfo->estimatedCost = 10.0;
        -: 2920:    }else{
    #####: 2921:      pIdxInfo->idxNum = 1;
    #####: 2922:      pIdxInfo->estimatedCost = 100.0;
        -: 2923:    }
        -: 2924:  }
        -: 2925:
    #####: 2926:  return SQLITE_OK;
        -: 2927:}
        -: 2928:
        -: 2929:/*
        -: 2930:** Register the "fsdir" virtual table.
        -: 2931:*/
        2: 2932:static int fsdirRegister(sqlite3 *db){
        -: 2933:  static sqlite3_module fsdirModule = {
        -: 2934:    0,                         /* iVersion */
        -: 2935:    0,                         /* xCreate */
        -: 2936:    fsdirConnect,              /* xConnect */
        -: 2937:    fsdirBestIndex,            /* xBestIndex */
        -: 2938:    fsdirDisconnect,           /* xDisconnect */
        -: 2939:    0,                         /* xDestroy */
        -: 2940:    fsdirOpen,                 /* xOpen - open a cursor */
        -: 2941:    fsdirClose,                /* xClose - close a cursor */
        -: 2942:    fsdirFilter,               /* xFilter - configure scan constraints */
        -: 2943:    fsdirNext,                 /* xNext - advance a cursor */
        -: 2944:    fsdirEof,                  /* xEof - check for end of scan */
        -: 2945:    fsdirColumn,               /* xColumn - read data */
        -: 2946:    fsdirRowid,                /* xRowid - read data */
        -: 2947:    0,                         /* xUpdate */
        -: 2948:    0,                         /* xBegin */
        -: 2949:    0,                         /* xSync */
        -: 2950:    0,                         /* xCommit */
        -: 2951:    0,                         /* xRollback */
        -: 2952:    0,                         /* xFindMethod */
        -: 2953:    0,                         /* xRename */
        -: 2954:    0,                         /* xSavepoint */
        -: 2955:    0,                         /* xRelease */
        -: 2956:    0,                         /* xRollbackTo */
        -: 2957:    0,                         /* xShadowName */
        -: 2958:  };
        -: 2959:
        2: 2960:  int rc = sqlite3_create_module(db, "fsdir", &fsdirModule, 0);
        2: 2961:  return rc;
        -: 2962:}
        -: 2963:#else         /* SQLITE_OMIT_VIRTUALTABLE */
        -: 2964:# define fsdirRegister(x) SQLITE_OK
        -: 2965:#endif
        -: 2966:
        -: 2967:#ifdef _WIN32
        -: 2968:
        -: 2969:#endif
        2: 2970:int sqlite3_fileio_init(
        -: 2971:  sqlite3 *db, 
        -: 2972:  char **pzErrMsg, 
        -: 2973:  const sqlite3_api_routines *pApi
        -: 2974:){
        2: 2975:  int rc = SQLITE_OK;
        -: 2976:  SQLITE_EXTENSION_INIT2(pApi);
        -: 2977:  (void)pzErrMsg;  /* Unused parameter */
        2: 2978:  rc = sqlite3_create_function(db, "readfile", 1, SQLITE_UTF8, 0,
        -: 2979:                               readfileFunc, 0, 0);
        2: 2980:  if( rc==SQLITE_OK ){
        2: 2981:    rc = sqlite3_create_function(db, "writefile", -1, SQLITE_UTF8, 0,
        -: 2982:                                 writefileFunc, 0, 0);
        -: 2983:  }
        2: 2984:  if( rc==SQLITE_OK ){
        2: 2985:    rc = sqlite3_create_function(db, "lsmode", 1, SQLITE_UTF8, 0,
        -: 2986:                                 lsModeFunc, 0, 0);
        -: 2987:  }
        2: 2988:  if( rc==SQLITE_OK ){
        2: 2989:    rc = fsdirRegister(db);
        -: 2990:  }
        2: 2991:  return rc;
        -: 2992:}
        -: 2993:
        -: 2994:/************************* End ../ext/misc/fileio.c ********************/
        -: 2995:/************************* Begin ../ext/misc/completion.c ******************/
        -: 2996:/*
        -: 2997:** 2017-07-10
        -: 2998:**
        -: 2999:** The author disclaims copyright to this source code.  In place of
        -: 3000:** a legal notice, here is a blessing:
        -: 3001:**
        -: 3002:**    May you do good and not evil.
        -: 3003:**    May you find forgiveness for yourself and forgive others.
        -: 3004:**    May you share freely, never taking more than you give.
        -: 3005:**
        -: 3006:*************************************************************************
        -: 3007:**
        -: 3008:** This file implements an eponymous virtual table that returns suggested
        -: 3009:** completions for a partial SQL input.
        -: 3010:**
        -: 3011:** Suggested usage:
        -: 3012:**
        -: 3013:**     SELECT DISTINCT candidate COLLATE nocase
        -: 3014:**       FROM completion($prefix,$wholeline)
        -: 3015:**      ORDER BY 1;
        -: 3016:**
        -: 3017:** The two query parameters are optional.  $prefix is the text of the
        -: 3018:** current word being typed and that is to be completed.  $wholeline is
        -: 3019:** the complete input line, used for context.
        -: 3020:**
        -: 3021:** The raw completion() table might return the same candidate multiple
        -: 3022:** times, for example if the same column name is used to two or more
        -: 3023:** tables.  And the candidates are returned in an arbitrary order.  Hence,
        -: 3024:** the DISTINCT and ORDER BY are recommended.
        -: 3025:**
        -: 3026:** This virtual table operates at the speed of human typing, and so there
        -: 3027:** is no attempt to make it fast.  Even a slow implementation will be much
        -: 3028:** faster than any human can type.
        -: 3029:**
        -: 3030:*/
        -: 3031:SQLITE_EXTENSION_INIT1
        -: 3032:#include <assert.h>
        -: 3033:#include <string.h>
        -: 3034:#include <ctype.h>
        -: 3035:
        -: 3036:#ifndef SQLITE_OMIT_VIRTUALTABLE
        -: 3037:
        -: 3038:/* completion_vtab is a subclass of sqlite3_vtab which will
        -: 3039:** serve as the underlying representation of a completion virtual table
        -: 3040:*/
        -: 3041:typedef struct completion_vtab completion_vtab;
        -: 3042:struct completion_vtab {
        -: 3043:  sqlite3_vtab base;  /* Base class - must be first */
        -: 3044:  sqlite3 *db;        /* Database connection for this completion vtab */
        -: 3045:};
        -: 3046:
        -: 3047:/* completion_cursor is a subclass of sqlite3_vtab_cursor which will
        -: 3048:** serve as the underlying representation of a cursor that scans
        -: 3049:** over rows of the result
        -: 3050:*/
        -: 3051:typedef struct completion_cursor completion_cursor;
        -: 3052:struct completion_cursor {
        -: 3053:  sqlite3_vtab_cursor base;  /* Base class - must be first */
        -: 3054:  sqlite3 *db;               /* Database connection for this cursor */
        -: 3055:  int nPrefix, nLine;        /* Number of bytes in zPrefix and zLine */
        -: 3056:  char *zPrefix;             /* The prefix for the word we want to complete */
        -: 3057:  char *zLine;               /* The whole that we want to complete */
        -: 3058:  const char *zCurrentRow;   /* Current output row */
        -: 3059:  int szRow;                 /* Length of the zCurrentRow string */
        -: 3060:  sqlite3_stmt *pStmt;       /* Current statement */
        -: 3061:  sqlite3_int64 iRowid;      /* The rowid */
        -: 3062:  int ePhase;                /* Current phase */
        -: 3063:  int j;                     /* inter-phase counter */
        -: 3064:};
        -: 3065:
        -: 3066:/* Values for ePhase:
        -: 3067:*/
        -: 3068:#define COMPLETION_FIRST_PHASE   1
        -: 3069:#define COMPLETION_KEYWORDS      1
        -: 3070:#define COMPLETION_PRAGMAS       2
        -: 3071:#define COMPLETION_FUNCTIONS     3
        -: 3072:#define COMPLETION_COLLATIONS    4
        -: 3073:#define COMPLETION_INDEXES       5
        -: 3074:#define COMPLETION_TRIGGERS      6
        -: 3075:#define COMPLETION_DATABASES     7
        -: 3076:#define COMPLETION_TABLES        8    /* Also VIEWs and TRIGGERs */
        -: 3077:#define COMPLETION_COLUMNS       9
        -: 3078:#define COMPLETION_MODULES       10
        -: 3079:#define COMPLETION_EOF           11
        -: 3080:
        -: 3081:/*
        -: 3082:** The completionConnect() method is invoked to create a new
        -: 3083:** completion_vtab that describes the completion virtual table.
        -: 3084:**
        -: 3085:** Think of this routine as the constructor for completion_vtab objects.
        -: 3086:**
        -: 3087:** All this routine needs to do is:
        -: 3088:**
        -: 3089:**    (1) Allocate the completion_vtab object and initialize all fields.
        -: 3090:**
        -: 3091:**    (2) Tell SQLite (via the sqlite3_declare_vtab() interface) what the
        -: 3092:**        result set of queries against completion will look like.
        -: 3093:*/
    #####: 3094:static int completionConnect(
        -: 3095:  sqlite3 *db,
        -: 3096:  void *pAux,
        -: 3097:  int argc, const char *const*argv,
        -: 3098:  sqlite3_vtab **ppVtab,
        -: 3099:  char **pzErr
        -: 3100:){
        -: 3101:  completion_vtab *pNew;
        -: 3102:  int rc;
        -: 3103:
        -: 3104:  (void)(pAux);    /* Unused parameter */
        -: 3105:  (void)(argc);    /* Unused parameter */
        -: 3106:  (void)(argv);    /* Unused parameter */
        -: 3107:  (void)(pzErr);   /* Unused parameter */
        -: 3108:
        -: 3109:/* Column numbers */
        -: 3110:#define COMPLETION_COLUMN_CANDIDATE 0  /* Suggested completion of the input */
        -: 3111:#define COMPLETION_COLUMN_PREFIX    1  /* Prefix of the word to be completed */
        -: 3112:#define COMPLETION_COLUMN_WHOLELINE 2  /* Entire line seen so far */
        -: 3113:#define COMPLETION_COLUMN_PHASE     3  /* ePhase - used for debugging only */
        -: 3114:
    #####: 3115:  rc = sqlite3_declare_vtab(db,
        -: 3116:      "CREATE TABLE x("
        -: 3117:      "  candidate TEXT,"
        -: 3118:      "  prefix TEXT HIDDEN,"
        -: 3119:      "  wholeline TEXT HIDDEN,"
        -: 3120:      "  phase INT HIDDEN"        /* Used for debugging only */
        -: 3121:      ")");
    #####: 3122:  if( rc==SQLITE_OK ){
    #####: 3123:    pNew = sqlite3_malloc( sizeof(*pNew) );
    #####: 3124:    *ppVtab = (sqlite3_vtab*)pNew;
    #####: 3125:    if( pNew==0 ) return SQLITE_NOMEM;
    #####: 3126:    memset(pNew, 0, sizeof(*pNew));
    #####: 3127:    pNew->db = db;
        -: 3128:  }
    #####: 3129:  return rc;
        -: 3130:}
        -: 3131:
        -: 3132:/*
        -: 3133:** This method is the destructor for completion_cursor objects.
        -: 3134:*/
    #####: 3135:static int completionDisconnect(sqlite3_vtab *pVtab){
    #####: 3136:  sqlite3_free(pVtab);
    #####: 3137:  return SQLITE_OK;
        -: 3138:}
        -: 3139:
        -: 3140:/*
        -: 3141:** Constructor for a new completion_cursor object.
        -: 3142:*/
    #####: 3143:static int completionOpen(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCursor){
        -: 3144:  completion_cursor *pCur;
    #####: 3145:  pCur = sqlite3_malloc( sizeof(*pCur) );
    #####: 3146:  if( pCur==0 ) return SQLITE_NOMEM;
    #####: 3147:  memset(pCur, 0, sizeof(*pCur));
    #####: 3148:  pCur->db = ((completion_vtab*)p)->db;
    #####: 3149:  *ppCursor = &pCur->base;
    #####: 3150:  return SQLITE_OK;
        -: 3151:}
        -: 3152:
        -: 3153:/*
        -: 3154:** Reset the completion_cursor.
        -: 3155:*/
    #####: 3156:static void completionCursorReset(completion_cursor *pCur){
    #####: 3157:  sqlite3_free(pCur->zPrefix);   pCur->zPrefix = 0;  pCur->nPrefix = 0;
    #####: 3158:  sqlite3_free(pCur->zLine);     pCur->zLine = 0;    pCur->nLine = 0;
    #####: 3159:  sqlite3_finalize(pCur->pStmt); pCur->pStmt = 0;
    #####: 3160:  pCur->j = 0;
    #####: 3161:}
        -: 3162:
        -: 3163:/*
        -: 3164:** Destructor for a completion_cursor.
        -: 3165:*/
    #####: 3166:static int completionClose(sqlite3_vtab_cursor *cur){
    #####: 3167:  completionCursorReset((completion_cursor*)cur);
    #####: 3168:  sqlite3_free(cur);
    #####: 3169:  return SQLITE_OK;
        -: 3170:}
        -: 3171:
        -: 3172:/*
        -: 3173:** Advance a completion_cursor to its next row of output.
        -: 3174:**
        -: 3175:** The ->ePhase, ->j, and ->pStmt fields of the completion_cursor object
        -: 3176:** record the current state of the scan.  This routine sets ->zCurrentRow
        -: 3177:** to the current row of output and then returns.  If no more rows remain,
        -: 3178:** then ->ePhase is set to COMPLETION_EOF which will signal the virtual
        -: 3179:** table that has reached the end of its scan.
        -: 3180:**
        -: 3181:** The current implementation just lists potential identifiers and
        -: 3182:** keywords and filters them by zPrefix.  Future enhancements should
        -: 3183:** take zLine into account to try to restrict the set of identifiers and
        -: 3184:** keywords based on what would be legal at the current point of input.
        -: 3185:*/
    #####: 3186:static int completionNext(sqlite3_vtab_cursor *cur){
    #####: 3187:  completion_cursor *pCur = (completion_cursor*)cur;
    #####: 3188:  int eNextPhase = 0;  /* Next phase to try if current phase reaches end */
    #####: 3189:  int iCol = -1;       /* If >=0, step pCur->pStmt and use the i-th column */
    #####: 3190:  pCur->iRowid++;
    #####: 3191:  while( pCur->ePhase!=COMPLETION_EOF ){
    #####: 3192:    switch( pCur->ePhase ){
    #####: 3193:      case COMPLETION_KEYWORDS: {
    #####: 3194:        if( pCur->j >= sqlite3_keyword_count() ){
    #####: 3195:          pCur->zCurrentRow = 0;
    #####: 3196:          pCur->ePhase = COMPLETION_DATABASES;
        -: 3197:        }else{
    #####: 3198:          sqlite3_keyword_name(pCur->j++, &pCur->zCurrentRow, &pCur->szRow);
        -: 3199:        }
    #####: 3200:        iCol = -1;
    #####: 3201:        break;
        -: 3202:      }
    #####: 3203:      case COMPLETION_DATABASES: {
    #####: 3204:        if( pCur->pStmt==0 ){
    #####: 3205:          sqlite3_prepare_v2(pCur->db, "PRAGMA database_list", -1,
        -: 3206:                             &pCur->pStmt, 0);
        -: 3207:        }
    #####: 3208:        iCol = 1;
    #####: 3209:        eNextPhase = COMPLETION_TABLES;
    #####: 3210:        break;
        -: 3211:      }
    #####: 3212:      case COMPLETION_TABLES: {
    #####: 3213:        if( pCur->pStmt==0 ){
        -: 3214:          sqlite3_stmt *pS2;
    #####: 3215:          char *zSql = 0;
    #####: 3216:          const char *zSep = "";
    #####: 3217:          sqlite3_prepare_v2(pCur->db, "PRAGMA database_list", -1, &pS2, 0);
    #####: 3218:          while( sqlite3_step(pS2)==SQLITE_ROW ){
    #####: 3219:            const char *zDb = (const char*)sqlite3_column_text(pS2, 1);
    #####: 3220:            zSql = sqlite3_mprintf(
        -: 3221:               "%z%s"
        -: 3222:               "SELECT name FROM \"%w\".sqlite_master",
        -: 3223:               zSql, zSep, zDb
        -: 3224:            );
    #####: 3225:            if( zSql==0 ) return SQLITE_NOMEM;
    #####: 3226:            zSep = " UNION ";
        -: 3227:          }
    #####: 3228:          sqlite3_finalize(pS2);
    #####: 3229:          sqlite3_prepare_v2(pCur->db, zSql, -1, &pCur->pStmt, 0);
    #####: 3230:          sqlite3_free(zSql);
        -: 3231:        }
    #####: 3232:        iCol = 0;
    #####: 3233:        eNextPhase = COMPLETION_COLUMNS;
    #####: 3234:        break;
        -: 3235:      }
    #####: 3236:      case COMPLETION_COLUMNS: {
    #####: 3237:        if( pCur->pStmt==0 ){
        -: 3238:          sqlite3_stmt *pS2;
    #####: 3239:          char *zSql = 0;
    #####: 3240:          const char *zSep = "";
    #####: 3241:          sqlite3_prepare_v2(pCur->db, "PRAGMA database_list", -1, &pS2, 0);
    #####: 3242:          while( sqlite3_step(pS2)==SQLITE_ROW ){
    #####: 3243:            const char *zDb = (const char*)sqlite3_column_text(pS2, 1);
    #####: 3244:            zSql = sqlite3_mprintf(
        -: 3245:               "%z%s"
        -: 3246:               "SELECT pti.name FROM \"%w\".sqlite_master AS sm"
        -: 3247:                       " JOIN pragma_table_info(sm.name,%Q) AS pti"
        -: 3248:               " WHERE sm.type='table'",
        -: 3249:               zSql, zSep, zDb, zDb
        -: 3250:            );
    #####: 3251:            if( zSql==0 ) return SQLITE_NOMEM;
    #####: 3252:            zSep = " UNION ";
        -: 3253:          }
    #####: 3254:          sqlite3_finalize(pS2);
    #####: 3255:          sqlite3_prepare_v2(pCur->db, zSql, -1, &pCur->pStmt, 0);
    #####: 3256:          sqlite3_free(zSql);
        -: 3257:        }
    #####: 3258:        iCol = 0;
    #####: 3259:        eNextPhase = COMPLETION_EOF;
    #####: 3260:        break;
        -: 3261:      }
        -: 3262:    }
    #####: 3263:    if( iCol<0 ){
        -: 3264:      /* This case is when the phase presets zCurrentRow */
    #####: 3265:      if( pCur->zCurrentRow==0 ) continue;
        -: 3266:    }else{
    #####: 3267:      if( sqlite3_step(pCur->pStmt)==SQLITE_ROW ){
        -: 3268:        /* Extract the next row of content */
    #####: 3269:        pCur->zCurrentRow = (const char*)sqlite3_column_text(pCur->pStmt, iCol);
    #####: 3270:        pCur->szRow = sqlite3_column_bytes(pCur->pStmt, iCol);
        -: 3271:      }else{
        -: 3272:        /* When all rows are finished, advance to the next phase */
    #####: 3273:        sqlite3_finalize(pCur->pStmt);
    #####: 3274:        pCur->pStmt = 0;
    #####: 3275:        pCur->ePhase = eNextPhase;
    #####: 3276:        continue;
        -: 3277:      }
        -: 3278:    }
    #####: 3279:    if( pCur->nPrefix==0 ) break;
    #####: 3280:    if( pCur->nPrefix<=pCur->szRow
    #####: 3281:     && sqlite3_strnicmp(pCur->zPrefix, pCur->zCurrentRow, pCur->nPrefix)==0
        -: 3282:    ){
    #####: 3283:      break;
        -: 3284:    }
        -: 3285:  }
        -: 3286:
    #####: 3287:  return SQLITE_OK;
        -: 3288:}
        -: 3289:
        -: 3290:/*
        -: 3291:** Return values of columns for the row at which the completion_cursor
        -: 3292:** is currently pointing.
        -: 3293:*/
    #####: 3294:static int completionColumn(
        -: 3295:  sqlite3_vtab_cursor *cur,   /* The cursor */
        -: 3296:  sqlite3_context *ctx,       /* First argument to sqlite3_result_...() */
        -: 3297:  int i                       /* Which column to return */
        -: 3298:){
    #####: 3299:  completion_cursor *pCur = (completion_cursor*)cur;
    #####: 3300:  switch( i ){
    #####: 3301:    case COMPLETION_COLUMN_CANDIDATE: {
    #####: 3302:      sqlite3_result_text(ctx, pCur->zCurrentRow, pCur->szRow,SQLITE_TRANSIENT);
    #####: 3303:      break;
        -: 3304:    }
    #####: 3305:    case COMPLETION_COLUMN_PREFIX: {
    #####: 3306:      sqlite3_result_text(ctx, pCur->zPrefix, -1, SQLITE_TRANSIENT);
    #####: 3307:      break;
        -: 3308:    }
    #####: 3309:    case COMPLETION_COLUMN_WHOLELINE: {
    #####: 3310:      sqlite3_result_text(ctx, pCur->zLine, -1, SQLITE_TRANSIENT);
    #####: 3311:      break;
        -: 3312:    }
    #####: 3313:    case COMPLETION_COLUMN_PHASE: {
    #####: 3314:      sqlite3_result_int(ctx, pCur->ePhase);
    #####: 3315:      break;
        -: 3316:    }
        -: 3317:  }
    #####: 3318:  return SQLITE_OK;
        -: 3319:}
        -: 3320:
        -: 3321:/*
        -: 3322:** Return the rowid for the current row.  In this implementation, the
        -: 3323:** rowid is the same as the output value.
        -: 3324:*/
    #####: 3325:static int completionRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){
    #####: 3326:  completion_cursor *pCur = (completion_cursor*)cur;
    #####: 3327:  *pRowid = pCur->iRowid;
    #####: 3328:  return SQLITE_OK;
        -: 3329:}
        -: 3330:
        -: 3331:/*
        -: 3332:** Return TRUE if the cursor has been moved off of the last
        -: 3333:** row of output.
        -: 3334:*/
    #####: 3335:static int completionEof(sqlite3_vtab_cursor *cur){
    #####: 3336:  completion_cursor *pCur = (completion_cursor*)cur;
    #####: 3337:  return pCur->ePhase >= COMPLETION_EOF;
        -: 3338:}
        -: 3339:
        -: 3340:/*
        -: 3341:** This method is called to "rewind" the completion_cursor object back
        -: 3342:** to the first row of output.  This method is always called at least
        -: 3343:** once prior to any call to completionColumn() or completionRowid() or 
        -: 3344:** completionEof().
        -: 3345:*/
    #####: 3346:static int completionFilter(
        -: 3347:  sqlite3_vtab_cursor *pVtabCursor, 
        -: 3348:  int idxNum, const char *idxStr,
        -: 3349:  int argc, sqlite3_value **argv
        -: 3350:){
    #####: 3351:  completion_cursor *pCur = (completion_cursor *)pVtabCursor;
    #####: 3352:  int iArg = 0;
        -: 3353:  (void)(idxStr);   /* Unused parameter */
        -: 3354:  (void)(argc);     /* Unused parameter */
    #####: 3355:  completionCursorReset(pCur);
    #####: 3356:  if( idxNum & 1 ){
    #####: 3357:    pCur->nPrefix = sqlite3_value_bytes(argv[iArg]);
    #####: 3358:    if( pCur->nPrefix>0 ){
    #####: 3359:      pCur->zPrefix = sqlite3_mprintf("%s", sqlite3_value_text(argv[iArg]));
    #####: 3360:      if( pCur->zPrefix==0 ) return SQLITE_NOMEM;
        -: 3361:    }
    #####: 3362:    iArg = 1;
        -: 3363:  }
    #####: 3364:  if( idxNum & 2 ){
    #####: 3365:    pCur->nLine = sqlite3_value_bytes(argv[iArg]);
    #####: 3366:    if( pCur->nLine>0 ){
    #####: 3367:      pCur->zLine = sqlite3_mprintf("%s", sqlite3_value_text(argv[iArg]));
    #####: 3368:      if( pCur->zLine==0 ) return SQLITE_NOMEM;
        -: 3369:    }
        -: 3370:  }
    #####: 3371:  if( pCur->zLine!=0 && pCur->zPrefix==0 ){
    #####: 3372:    int i = pCur->nLine;
    #####: 3373:    while( i>0 && (isalnum(pCur->zLine[i-1]) || pCur->zLine[i-1]=='_') ){
    #####: 3374:      i--;
        -: 3375:    }
    #####: 3376:    pCur->nPrefix = pCur->nLine - i;
    #####: 3377:    if( pCur->nPrefix>0 ){
    #####: 3378:      pCur->zPrefix = sqlite3_mprintf("%.*s", pCur->nPrefix, pCur->zLine + i);
    #####: 3379:      if( pCur->zPrefix==0 ) return SQLITE_NOMEM;
        -: 3380:    }
        -: 3381:  }
    #####: 3382:  pCur->iRowid = 0;
    #####: 3383:  pCur->ePhase = COMPLETION_FIRST_PHASE;
    #####: 3384:  return completionNext(pVtabCursor);
        -: 3385:}
        -: 3386:
        -: 3387:/*
        -: 3388:** SQLite will invoke this method one or more times while planning a query
        -: 3389:** that uses the completion virtual table.  This routine needs to create
        -: 3390:** a query plan for each invocation and compute an estimated cost for that
        -: 3391:** plan.
        -: 3392:**
        -: 3393:** There are two hidden parameters that act as arguments to the table-valued
        -: 3394:** function:  "prefix" and "wholeline".  Bit 0 of idxNum is set if "prefix"
        -: 3395:** is available and bit 1 is set if "wholeline" is available.
        -: 3396:*/
    #####: 3397:static int completionBestIndex(
        -: 3398:  sqlite3_vtab *tab,
        -: 3399:  sqlite3_index_info *pIdxInfo
        -: 3400:){
        -: 3401:  int i;                 /* Loop over constraints */
    #####: 3402:  int idxNum = 0;        /* The query plan bitmask */
    #####: 3403:  int prefixIdx = -1;    /* Index of the start= constraint, or -1 if none */
    #####: 3404:  int wholelineIdx = -1; /* Index of the stop= constraint, or -1 if none */
    #####: 3405:  int nArg = 0;          /* Number of arguments that completeFilter() expects */
        -: 3406:  const struct sqlite3_index_constraint *pConstraint;
        -: 3407:
        -: 3408:  (void)(tab);    /* Unused parameter */
    #####: 3409:  pConstraint = pIdxInfo->aConstraint;
    #####: 3410:  for(i=0; i<pIdxInfo->nConstraint; i++, pConstraint++){
    #####: 3411:    if( pConstraint->usable==0 ) continue;
    #####: 3412:    if( pConstraint->op!=SQLITE_INDEX_CONSTRAINT_EQ ) continue;
    #####: 3413:    switch( pConstraint->iColumn ){
    #####: 3414:      case COMPLETION_COLUMN_PREFIX:
    #####: 3415:        prefixIdx = i;
    #####: 3416:        idxNum |= 1;
    #####: 3417:        break;
    #####: 3418:      case COMPLETION_COLUMN_WHOLELINE:
    #####: 3419:        wholelineIdx = i;
    #####: 3420:        idxNum |= 2;
    #####: 3421:        break;
        -: 3422:    }
        -: 3423:  }
    #####: 3424:  if( prefixIdx>=0 ){
    #####: 3425:    pIdxInfo->aConstraintUsage[prefixIdx].argvIndex = ++nArg;
    #####: 3426:    pIdxInfo->aConstraintUsage[prefixIdx].omit = 1;
        -: 3427:  }
    #####: 3428:  if( wholelineIdx>=0 ){
    #####: 3429:    pIdxInfo->aConstraintUsage[wholelineIdx].argvIndex = ++nArg;
    #####: 3430:    pIdxInfo->aConstraintUsage[wholelineIdx].omit = 1;
        -: 3431:  }
    #####: 3432:  pIdxInfo->idxNum = idxNum;
    #####: 3433:  pIdxInfo->estimatedCost = (double)5000 - 1000*nArg;
    #####: 3434:  pIdxInfo->estimatedRows = 500 - 100*nArg;
    #####: 3435:  return SQLITE_OK;
        -: 3436:}
        -: 3437:
        -: 3438:/*
        -: 3439:** This following structure defines all the methods for the 
        -: 3440:** completion virtual table.
        -: 3441:*/
        -: 3442:static sqlite3_module completionModule = {
        -: 3443:  0,                         /* iVersion */
        -: 3444:  0,                         /* xCreate */
        -: 3445:  completionConnect,         /* xConnect */
        -: 3446:  completionBestIndex,       /* xBestIndex */
        -: 3447:  completionDisconnect,      /* xDisconnect */
        -: 3448:  0,                         /* xDestroy */
        -: 3449:  completionOpen,            /* xOpen - open a cursor */
        -: 3450:  completionClose,           /* xClose - close a cursor */
        -: 3451:  completionFilter,          /* xFilter - configure scan constraints */
        -: 3452:  completionNext,            /* xNext - advance a cursor */
        -: 3453:  completionEof,             /* xEof - check for end of scan */
        -: 3454:  completionColumn,          /* xColumn - read data */
        -: 3455:  completionRowid,           /* xRowid - read data */
        -: 3456:  0,                         /* xUpdate */
        -: 3457:  0,                         /* xBegin */
        -: 3458:  0,                         /* xSync */
        -: 3459:  0,                         /* xCommit */
        -: 3460:  0,                         /* xRollback */
        -: 3461:  0,                         /* xFindMethod */
        -: 3462:  0,                         /* xRename */
        -: 3463:  0,                         /* xSavepoint */
        -: 3464:  0,                         /* xRelease */
        -: 3465:  0,                         /* xRollbackTo */
        -: 3466:  0                          /* xShadowName */
        -: 3467:};
        -: 3468:
        -: 3469:#endif /* SQLITE_OMIT_VIRTUALTABLE */
        -: 3470:
        2: 3471:int sqlite3CompletionVtabInit(sqlite3 *db){
        2: 3472:  int rc = SQLITE_OK;
        -: 3473:#ifndef SQLITE_OMIT_VIRTUALTABLE
        2: 3474:  rc = sqlite3_create_module(db, "completion", &completionModule, 0);
        -: 3475:#endif
        2: 3476:  return rc;
        -: 3477:}
        -: 3478:
        -: 3479:#ifdef _WIN32
        -: 3480:
        -: 3481:#endif
        2: 3482:int sqlite3_completion_init(
        -: 3483:  sqlite3 *db, 
        -: 3484:  char **pzErrMsg, 
        -: 3485:  const sqlite3_api_routines *pApi
        -: 3486:){
        2: 3487:  int rc = SQLITE_OK;
        -: 3488:  SQLITE_EXTENSION_INIT2(pApi);
        -: 3489:  (void)(pzErrMsg);  /* Unused parameter */
        -: 3490:#ifndef SQLITE_OMIT_VIRTUALTABLE
        2: 3491:  rc = sqlite3CompletionVtabInit(db);
        -: 3492:#endif
        2: 3493:  return rc;
        -: 3494:}
        -: 3495:
        -: 3496:/************************* End ../ext/misc/completion.c ********************/
        -: 3497:/************************* Begin ../ext/misc/appendvfs.c ******************/
        -: 3498:/*
        -: 3499:** 2017-10-20
        -: 3500:**
        -: 3501:** The author disclaims copyright to this source code.  In place of
        -: 3502:** a legal notice, here is a blessing:
        -: 3503:**
        -: 3504:**    May you do good and not evil.
        -: 3505:**    May you find forgiveness for yourself and forgive others.
        -: 3506:**    May you share freely, never taking more than you give.
        -: 3507:**
        -: 3508:******************************************************************************
        -: 3509:**
        -: 3510:** This file implements a VFS shim that allows an SQLite database to be
        -: 3511:** appended onto the end of some other file, such as an executable.
        -: 3512:**
        -: 3513:** A special record must appear at the end of the file that identifies the
        -: 3514:** file as an appended database and provides an offset to page 1.  For
        -: 3515:** best performance page 1 should be located at a disk page boundary, though
        -: 3516:** that is not required.
        -: 3517:**
        -: 3518:** When opening a database using this VFS, the connection might treat
        -: 3519:** the file as an ordinary SQLite database, or it might treat is as a
        -: 3520:** database appended onto some other file.  Here are the rules:
        -: 3521:**
        -: 3522:**  (1)  When opening a new empty file, that file is treated as an ordinary
        -: 3523:**       database.
        -: 3524:**
        -: 3525:**  (2)  When opening a file that begins with the standard SQLite prefix
        -: 3526:**       string "SQLite format 3", that file is treated as an ordinary
        -: 3527:**       database.
        -: 3528:**
        -: 3529:**  (3)  When opening a file that ends with the appendvfs trailer string
        -: 3530:**       "Start-Of-SQLite3-NNNNNNNN" that file is treated as an appended
        -: 3531:**       database.
        -: 3532:**
        -: 3533:**  (4)  If none of the above apply and the SQLITE_OPEN_CREATE flag is
        -: 3534:**       set, then a new database is appended to the already existing file.
        -: 3535:**
        -: 3536:**  (5)  Otherwise, SQLITE_CANTOPEN is returned.
        -: 3537:**
        -: 3538:** To avoid unnecessary complications with the PENDING_BYTE, the size of
        -: 3539:** the file containing the database is limited to 1GB.  This VFS will refuse
        -: 3540:** to read or write past the 1GB mark.  This restriction might be lifted in
        -: 3541:** future versions.  For now, if you need a large database, then keep the
        -: 3542:** database in a separate file.
        -: 3543:**
        -: 3544:** If the file being opened is not an appended database, then this shim is
        -: 3545:** a pass-through into the default underlying VFS.
        -: 3546:**/
        -: 3547:SQLITE_EXTENSION_INIT1
        -: 3548:#include <string.h>
        -: 3549:#include <assert.h>
        -: 3550:
        -: 3551:/* The append mark at the end of the database is:
        -: 3552:**
        -: 3553:**     Start-Of-SQLite3-NNNNNNNN
        -: 3554:**     123456789 123456789 12345
        -: 3555:**
        -: 3556:** The NNNNNNNN represents a 64-bit big-endian unsigned integer which is
        -: 3557:** the offset to page 1.
        -: 3558:*/
        -: 3559:#define APND_MARK_PREFIX     "Start-Of-SQLite3-"
        -: 3560:#define APND_MARK_PREFIX_SZ  17
        -: 3561:#define APND_MARK_SIZE       25
        -: 3562:
        -: 3563:/*
        -: 3564:** Maximum size of the combined prefix + database + append-mark.  This
        -: 3565:** must be less than 0x40000000 to avoid locking issues on Windows.
        -: 3566:*/
        -: 3567:#define APND_MAX_SIZE  (65536*15259)
        -: 3568:
        -: 3569:/*
        -: 3570:** Forward declaration of objects used by this utility
        -: 3571:*/
        -: 3572:typedef struct sqlite3_vfs ApndVfs;
        -: 3573:typedef struct ApndFile ApndFile;
        -: 3574:
        -: 3575:/* Access to a lower-level VFS that (might) implement dynamic loading,
        -: 3576:** access to randomness, etc.
        -: 3577:*/
        -: 3578:#define ORIGVFS(p)  ((sqlite3_vfs*)((p)->pAppData))
        -: 3579:#define ORIGFILE(p) ((sqlite3_file*)(((ApndFile*)(p))+1))
        -: 3580:
        -: 3581:/* An open file */
        -: 3582:struct ApndFile {
        -: 3583:  sqlite3_file base;              /* IO methods */
        -: 3584:  sqlite3_int64 iPgOne;           /* File offset to page 1 */
        -: 3585:  sqlite3_int64 iMark;            /* Start of the append-mark */
        -: 3586:};
        -: 3587:
        -: 3588:/*
        -: 3589:** Methods for ApndFile
        -: 3590:*/
        -: 3591:static int apndClose(sqlite3_file*);
        -: 3592:static int apndRead(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);
        -: 3593:static int apndWrite(sqlite3_file*,const void*,int iAmt, sqlite3_int64 iOfst);
        -: 3594:static int apndTruncate(sqlite3_file*, sqlite3_int64 size);
        -: 3595:static int apndSync(sqlite3_file*, int flags);
        -: 3596:static int apndFileSize(sqlite3_file*, sqlite3_int64 *pSize);
        -: 3597:static int apndLock(sqlite3_file*, int);
        -: 3598:static int apndUnlock(sqlite3_file*, int);
        -: 3599:static int apndCheckReservedLock(sqlite3_file*, int *pResOut);
        -: 3600:static int apndFileControl(sqlite3_file*, int op, void *pArg);
        -: 3601:static int apndSectorSize(sqlite3_file*);
        -: 3602:static int apndDeviceCharacteristics(sqlite3_file*);
        -: 3603:static int apndShmMap(sqlite3_file*, int iPg, int pgsz, int, void volatile**);
        -: 3604:static int apndShmLock(sqlite3_file*, int offset, int n, int flags);
        -: 3605:static void apndShmBarrier(sqlite3_file*);
        -: 3606:static int apndShmUnmap(sqlite3_file*, int deleteFlag);
        -: 3607:static int apndFetch(sqlite3_file*, sqlite3_int64 iOfst, int iAmt, void **pp);
        -: 3608:static int apndUnfetch(sqlite3_file*, sqlite3_int64 iOfst, void *p);
        -: 3609:
        -: 3610:/*
        -: 3611:** Methods for ApndVfs
        -: 3612:*/
        -: 3613:static int apndOpen(sqlite3_vfs*, const char *, sqlite3_file*, int , int *);
        -: 3614:static int apndDelete(sqlite3_vfs*, const char *zName, int syncDir);
        -: 3615:static int apndAccess(sqlite3_vfs*, const char *zName, int flags, int *);
        -: 3616:static int apndFullPathname(sqlite3_vfs*, const char *zName, int, char *zOut);
        -: 3617:static void *apndDlOpen(sqlite3_vfs*, const char *zFilename);
        -: 3618:static void apndDlError(sqlite3_vfs*, int nByte, char *zErrMsg);
        -: 3619:static void (*apndDlSym(sqlite3_vfs *pVfs, void *p, const char*zSym))(void);
        -: 3620:static void apndDlClose(sqlite3_vfs*, void*);
        -: 3621:static int apndRandomness(sqlite3_vfs*, int nByte, char *zOut);
        -: 3622:static int apndSleep(sqlite3_vfs*, int microseconds);
        -: 3623:static int apndCurrentTime(sqlite3_vfs*, double*);
        -: 3624:static int apndGetLastError(sqlite3_vfs*, int, char *);
        -: 3625:static int apndCurrentTimeInt64(sqlite3_vfs*, sqlite3_int64*);
        -: 3626:static int apndSetSystemCall(sqlite3_vfs*, const char*,sqlite3_syscall_ptr);
        -: 3627:static sqlite3_syscall_ptr apndGetSystemCall(sqlite3_vfs*, const char *z);
        -: 3628:static const char *apndNextSystemCall(sqlite3_vfs*, const char *zName);
        -: 3629:
        -: 3630:static sqlite3_vfs apnd_vfs = {
        -: 3631:  3,                            /* iVersion (set when registered) */
        -: 3632:  0,                            /* szOsFile (set when registered) */
        -: 3633:  1024,                         /* mxPathname */
        -: 3634:  0,                            /* pNext */
        -: 3635:  "apndvfs",                    /* zName */
        -: 3636:  0,                            /* pAppData (set when registered) */ 
        -: 3637:  apndOpen,                     /* xOpen */
        -: 3638:  apndDelete,                   /* xDelete */
        -: 3639:  apndAccess,                   /* xAccess */
        -: 3640:  apndFullPathname,             /* xFullPathname */
        -: 3641:  apndDlOpen,                   /* xDlOpen */
        -: 3642:  apndDlError,                  /* xDlError */
        -: 3643:  apndDlSym,                    /* xDlSym */
        -: 3644:  apndDlClose,                  /* xDlClose */
        -: 3645:  apndRandomness,               /* xRandomness */
        -: 3646:  apndSleep,                    /* xSleep */
        -: 3647:  apndCurrentTime,              /* xCurrentTime */
        -: 3648:  apndGetLastError,             /* xGetLastError */
        -: 3649:  apndCurrentTimeInt64,         /* xCurrentTimeInt64 */
        -: 3650:  apndSetSystemCall,            /* xSetSystemCall */
        -: 3651:  apndGetSystemCall,            /* xGetSystemCall */
        -: 3652:  apndNextSystemCall            /* xNextSystemCall */
        -: 3653:};
        -: 3654:
        -: 3655:static const sqlite3_io_methods apnd_io_methods = {
        -: 3656:  3,                              /* iVersion */
        -: 3657:  apndClose,                      /* xClose */
        -: 3658:  apndRead,                       /* xRead */
        -: 3659:  apndWrite,                      /* xWrite */
        -: 3660:  apndTruncate,                   /* xTruncate */
        -: 3661:  apndSync,                       /* xSync */
        -: 3662:  apndFileSize,                   /* xFileSize */
        -: 3663:  apndLock,                       /* xLock */
        -: 3664:  apndUnlock,                     /* xUnlock */
        -: 3665:  apndCheckReservedLock,          /* xCheckReservedLock */
        -: 3666:  apndFileControl,                /* xFileControl */
        -: 3667:  apndSectorSize,                 /* xSectorSize */
        -: 3668:  apndDeviceCharacteristics,      /* xDeviceCharacteristics */
        -: 3669:  apndShmMap,                     /* xShmMap */
        -: 3670:  apndShmLock,                    /* xShmLock */
        -: 3671:  apndShmBarrier,                 /* xShmBarrier */
        -: 3672:  apndShmUnmap,                   /* xShmUnmap */
        -: 3673:  apndFetch,                      /* xFetch */
        -: 3674:  apndUnfetch                     /* xUnfetch */
        -: 3675:};
        -: 3676:
        -: 3677:
        -: 3678:
        -: 3679:/*
        -: 3680:** Close an apnd-file.
        -: 3681:*/
    #####: 3682:static int apndClose(sqlite3_file *pFile){
    #####: 3683:  pFile = ORIGFILE(pFile);
    #####: 3684:  return pFile->pMethods->xClose(pFile);
        -: 3685:}
        -: 3686:
        -: 3687:/*
        -: 3688:** Read data from an apnd-file.
        -: 3689:*/
    #####: 3690:static int apndRead(
        -: 3691:  sqlite3_file *pFile, 
        -: 3692:  void *zBuf, 
        -: 3693:  int iAmt, 
        -: 3694:  sqlite_int64 iOfst
        -: 3695:){
    #####: 3696:  ApndFile *p = (ApndFile *)pFile;
    #####: 3697:  pFile = ORIGFILE(pFile);
    #####: 3698:  return pFile->pMethods->xRead(pFile, zBuf, iAmt, iOfst+p->iPgOne);
        -: 3699:}
        -: 3700:
        -: 3701:/*
        -: 3702:** Add the append-mark onto the end of the file.
        -: 3703:*/
    #####: 3704:static int apndWriteMark(ApndFile *p, sqlite3_file *pFile){
        -: 3705:  int i;
        -: 3706:  unsigned char a[APND_MARK_SIZE];
    #####: 3707:  memcpy(a, APND_MARK_PREFIX, APND_MARK_PREFIX_SZ);
    #####: 3708:  for(i=0; i<8; i++){
    #####: 3709:    a[APND_MARK_PREFIX_SZ+i] = (p->iPgOne >> (56 - i*8)) & 0xff;
        -: 3710:  }
    #####: 3711:  return pFile->pMethods->xWrite(pFile, a, APND_MARK_SIZE, p->iMark);
        -: 3712:}
        -: 3713:
        -: 3714:/*
        -: 3715:** Write data to an apnd-file.
        -: 3716:*/
    #####: 3717:static int apndWrite(
        -: 3718:  sqlite3_file *pFile,
        -: 3719:  const void *zBuf,
        -: 3720:  int iAmt,
        -: 3721:  sqlite_int64 iOfst
        -: 3722:){
        -: 3723:  int rc;
    #####: 3724:  ApndFile *p = (ApndFile *)pFile;
    #####: 3725:  pFile = ORIGFILE(pFile);
    #####: 3726:  if( iOfst+iAmt>=APND_MAX_SIZE ) return SQLITE_FULL;
    #####: 3727:  rc = pFile->pMethods->xWrite(pFile, zBuf, iAmt, iOfst+p->iPgOne);
    #####: 3728:  if( rc==SQLITE_OK &&  iOfst + iAmt + p->iPgOne > p->iMark ){
    #####: 3729:    sqlite3_int64 sz = 0;
    #####: 3730:    rc = pFile->pMethods->xFileSize(pFile, &sz);
    #####: 3731:    if( rc==SQLITE_OK ){
    #####: 3732:      p->iMark = sz - APND_MARK_SIZE;
    #####: 3733:      if( iOfst + iAmt + p->iPgOne > p->iMark ){
    #####: 3734:        p->iMark = p->iPgOne + iOfst + iAmt;
    #####: 3735:        rc = apndWriteMark(p, pFile);
        -: 3736:      }
        -: 3737:    }
        -: 3738:  }
    #####: 3739:  return rc;
        -: 3740:}
        -: 3741:
        -: 3742:/*
        -: 3743:** Truncate an apnd-file.
        -: 3744:*/
    #####: 3745:static int apndTruncate(sqlite3_file *pFile, sqlite_int64 size){
        -: 3746:  int rc;
    #####: 3747:  ApndFile *p = (ApndFile *)pFile;
    #####: 3748:  pFile = ORIGFILE(pFile);
    #####: 3749:  rc = pFile->pMethods->xTruncate(pFile, size+p->iPgOne+APND_MARK_SIZE);
    #####: 3750:  if( rc==SQLITE_OK ){
    #####: 3751:    p->iMark = p->iPgOne+size;
    #####: 3752:    rc = apndWriteMark(p, pFile);
        -: 3753:  }
    #####: 3754:  return rc;
        -: 3755:}
        -: 3756:
        -: 3757:/*
        -: 3758:** Sync an apnd-file.
        -: 3759:*/
    #####: 3760:static int apndSync(sqlite3_file *pFile, int flags){
    #####: 3761:  pFile = ORIGFILE(pFile);
    #####: 3762:  return pFile->pMethods->xSync(pFile, flags);
        -: 3763:}
        -: 3764:
        -: 3765:/*
        -: 3766:** Return the current file-size of an apnd-file.
        -: 3767:*/
    #####: 3768:static int apndFileSize(sqlite3_file *pFile, sqlite_int64 *pSize){
    #####: 3769:  ApndFile *p = (ApndFile *)pFile;
        -: 3770:  int rc;
    #####: 3771:  pFile = ORIGFILE(p);
    #####: 3772:  rc = pFile->pMethods->xFileSize(pFile, pSize);
    #####: 3773:  if( rc==SQLITE_OK && p->iPgOne ){
    #####: 3774:    *pSize -= p->iPgOne + APND_MARK_SIZE;
        -: 3775:  }
    #####: 3776:  return rc;
        -: 3777:}
        -: 3778:
        -: 3779:/*
        -: 3780:** Lock an apnd-file.
        -: 3781:*/
    #####: 3782:static int apndLock(sqlite3_file *pFile, int eLock){
    #####: 3783:  pFile = ORIGFILE(pFile);
    #####: 3784:  return pFile->pMethods->xLock(pFile, eLock);
        -: 3785:}
        -: 3786:
        -: 3787:/*
        -: 3788:** Unlock an apnd-file.
        -: 3789:*/
    #####: 3790:static int apndUnlock(sqlite3_file *pFile, int eLock){
    #####: 3791:  pFile = ORIGFILE(pFile);
    #####: 3792:  return pFile->pMethods->xUnlock(pFile, eLock);
        -: 3793:}
        -: 3794:
        -: 3795:/*
        -: 3796:** Check if another file-handle holds a RESERVED lock on an apnd-file.
        -: 3797:*/
    #####: 3798:static int apndCheckReservedLock(sqlite3_file *pFile, int *pResOut){
    #####: 3799:  pFile = ORIGFILE(pFile);
    #####: 3800:  return pFile->pMethods->xCheckReservedLock(pFile, pResOut);
        -: 3801:}
        -: 3802:
        -: 3803:/*
        -: 3804:** File control method. For custom operations on an apnd-file.
        -: 3805:*/
    #####: 3806:static int apndFileControl(sqlite3_file *pFile, int op, void *pArg){
    #####: 3807:  ApndFile *p = (ApndFile *)pFile;
        -: 3808:  int rc;
    #####: 3809:  pFile = ORIGFILE(pFile);
    #####: 3810:  rc = pFile->pMethods->xFileControl(pFile, op, pArg);
    #####: 3811:  if( rc==SQLITE_OK && op==SQLITE_FCNTL_VFSNAME ){
    #####: 3812:    *(char**)pArg = sqlite3_mprintf("apnd(%lld)/%z", p->iPgOne, *(char**)pArg);
        -: 3813:  }
    #####: 3814:  return rc;
        -: 3815:}
        -: 3816:
        -: 3817:/*
        -: 3818:** Return the sector-size in bytes for an apnd-file.
        -: 3819:*/
    #####: 3820:static int apndSectorSize(sqlite3_file *pFile){
    #####: 3821:  pFile = ORIGFILE(pFile);
    #####: 3822:  return pFile->pMethods->xSectorSize(pFile);
        -: 3823:}
        -: 3824:
        -: 3825:/*
        -: 3826:** Return the device characteristic flags supported by an apnd-file.
        -: 3827:*/
    #####: 3828:static int apndDeviceCharacteristics(sqlite3_file *pFile){
    #####: 3829:  pFile = ORIGFILE(pFile);
    #####: 3830:  return pFile->pMethods->xDeviceCharacteristics(pFile);
        -: 3831:}
        -: 3832:
        -: 3833:/* Create a shared memory file mapping */
    #####: 3834:static int apndShmMap(
        -: 3835:  sqlite3_file *pFile,
        -: 3836:  int iPg,
        -: 3837:  int pgsz,
        -: 3838:  int bExtend,
        -: 3839:  void volatile **pp
        -: 3840:){
    #####: 3841:  pFile = ORIGFILE(pFile);
    #####: 3842:  return pFile->pMethods->xShmMap(pFile,iPg,pgsz,bExtend,pp);
        -: 3843:}
        -: 3844:
        -: 3845:/* Perform locking on a shared-memory segment */
    #####: 3846:static int apndShmLock(sqlite3_file *pFile, int offset, int n, int flags){
    #####: 3847:  pFile = ORIGFILE(pFile);
    #####: 3848:  return pFile->pMethods->xShmLock(pFile,offset,n,flags);
        -: 3849:}
        -: 3850:
        -: 3851:/* Memory barrier operation on shared memory */
    #####: 3852:static void apndShmBarrier(sqlite3_file *pFile){
    #####: 3853:  pFile = ORIGFILE(pFile);
    #####: 3854:  pFile->pMethods->xShmBarrier(pFile);
    #####: 3855:}
        -: 3856:
        -: 3857:/* Unmap a shared memory segment */
    #####: 3858:static int apndShmUnmap(sqlite3_file *pFile, int deleteFlag){
    #####: 3859:  pFile = ORIGFILE(pFile);
    #####: 3860:  return pFile->pMethods->xShmUnmap(pFile,deleteFlag);
        -: 3861:}
        -: 3862:
        -: 3863:/* Fetch a page of a memory-mapped file */
    #####: 3864:static int apndFetch(
        -: 3865:  sqlite3_file *pFile,
        -: 3866:  sqlite3_int64 iOfst,
        -: 3867:  int iAmt,
        -: 3868:  void **pp
        -: 3869:){
    #####: 3870:  ApndFile *p = (ApndFile *)pFile;
    #####: 3871:  pFile = ORIGFILE(pFile);
    #####: 3872:  return pFile->pMethods->xFetch(pFile, iOfst+p->iPgOne, iAmt, pp);
        -: 3873:}
        -: 3874:
        -: 3875:/* Release a memory-mapped page */
    #####: 3876:static int apndUnfetch(sqlite3_file *pFile, sqlite3_int64 iOfst, void *pPage){
    #####: 3877:  ApndFile *p = (ApndFile *)pFile;
    #####: 3878:  pFile = ORIGFILE(pFile);
    #####: 3879:  return pFile->pMethods->xUnfetch(pFile, iOfst+p->iPgOne, pPage);
        -: 3880:}
        -: 3881:
        -: 3882:/*
        -: 3883:** Check to see if the file is an ordinary SQLite database file.
        -: 3884:*/
    #####: 3885:static int apndIsOrdinaryDatabaseFile(sqlite3_int64 sz, sqlite3_file *pFile){
        -: 3886:  int rc;
        -: 3887:  char zHdr[16];
        -: 3888:  static const char aSqliteHdr[] = "SQLite format 3";
    #####: 3889:  if( sz<512 ) return 0;
    #####: 3890:  rc = pFile->pMethods->xRead(pFile, zHdr, sizeof(zHdr), 0);
    #####: 3891:  if( rc ) return 0;
    #####: 3892:  return memcmp(zHdr, aSqliteHdr, sizeof(zHdr))==0;
        -: 3893:}
        -: 3894:
        -: 3895:/*
        -: 3896:** Try to read the append-mark off the end of a file.  Return the
        -: 3897:** start of the appended database if the append-mark is present.  If
        -: 3898:** there is no append-mark, return -1;
        -: 3899:*/
    #####: 3900:static sqlite3_int64 apndReadMark(sqlite3_int64 sz, sqlite3_file *pFile){
        -: 3901:  int rc, i;
        -: 3902:  sqlite3_int64 iMark;
        -: 3903:  unsigned char a[APND_MARK_SIZE];
        -: 3904:
    #####: 3905:  if( sz<=APND_MARK_SIZE ) return -1;
    #####: 3906:  rc = pFile->pMethods->xRead(pFile, a, APND_MARK_SIZE, sz-APND_MARK_SIZE);
    #####: 3907:  if( rc ) return -1;
    #####: 3908:  if( memcmp(a, APND_MARK_PREFIX, APND_MARK_PREFIX_SZ)!=0 ) return -1;
    #####: 3909:  iMark = ((sqlite3_int64)(a[APND_MARK_PREFIX_SZ]&0x7f))<<56;
    #####: 3910:  for(i=1; i<8; i++){    
    #####: 3911:    iMark += (sqlite3_int64)a[APND_MARK_PREFIX_SZ+i]<<(56-8*i);
        -: 3912:  }
    #####: 3913:  return iMark;
        -: 3914:}
        -: 3915:
        -: 3916:/*
        -: 3917:** Open an apnd file handle.
        -: 3918:*/
    #####: 3919:static int apndOpen(
        -: 3920:  sqlite3_vfs *pVfs,
        -: 3921:  const char *zName,
        -: 3922:  sqlite3_file *pFile,
        -: 3923:  int flags,
        -: 3924:  int *pOutFlags
        -: 3925:){
        -: 3926:  ApndFile *p;
        -: 3927:  sqlite3_file *pSubFile;
        -: 3928:  sqlite3_vfs *pSubVfs;
        -: 3929:  int rc;
        -: 3930:  sqlite3_int64 sz;
    #####: 3931:  pSubVfs = ORIGVFS(pVfs);
    #####: 3932:  if( (flags & SQLITE_OPEN_MAIN_DB)==0 ){
    #####: 3933:    return pSubVfs->xOpen(pSubVfs, zName, pFile, flags, pOutFlags);
        -: 3934:  }
    #####: 3935:  p = (ApndFile*)pFile;
    #####: 3936:  memset(p, 0, sizeof(*p));
    #####: 3937:  pSubFile = ORIGFILE(pFile);
    #####: 3938:  p->base.pMethods = &apnd_io_methods;
    #####: 3939:  rc = pSubVfs->xOpen(pSubVfs, zName, pSubFile, flags, pOutFlags);
    #####: 3940:  if( rc ) goto apnd_open_done;
    #####: 3941:  rc = pSubFile->pMethods->xFileSize(pSubFile, &sz);
    #####: 3942:  if( rc ){
    #####: 3943:    pSubFile->pMethods->xClose(pSubFile);
    #####: 3944:    goto apnd_open_done;
        -: 3945:  }
    #####: 3946:  if( apndIsOrdinaryDatabaseFile(sz, pSubFile) ){
    #####: 3947:    memmove(pFile, pSubFile, pSubVfs->szOsFile);
    #####: 3948:    return SQLITE_OK;
        -: 3949:  }
    #####: 3950:  p->iMark = 0;
    #####: 3951:  p->iPgOne = apndReadMark(sz, pFile);
    #####: 3952:  if( p->iPgOne>0 ){
    #####: 3953:    return SQLITE_OK;
        -: 3954:  }
    #####: 3955:  if( (flags & SQLITE_OPEN_CREATE)==0 ){
    #####: 3956:    pSubFile->pMethods->xClose(pSubFile);
    #####: 3957:    rc = SQLITE_CANTOPEN;
        -: 3958:  }
    #####: 3959:  p->iPgOne = (sz+0xfff) & ~(sqlite3_int64)0xfff;
    #####: 3960:apnd_open_done:
    #####: 3961:  if( rc ) pFile->pMethods = 0;
    #####: 3962:  return rc;
        -: 3963:}
        -: 3964:
        -: 3965:/*
        -: 3966:** All other VFS methods are pass-thrus.
        -: 3967:*/
    #####: 3968:static int apndDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){
    #####: 3969:  return ORIGVFS(pVfs)->xDelete(ORIGVFS(pVfs), zPath, dirSync);
        -: 3970:}
    #####: 3971:static int apndAccess(
        -: 3972:  sqlite3_vfs *pVfs, 
        -: 3973:  const char *zPath, 
        -: 3974:  int flags, 
        -: 3975:  int *pResOut
        -: 3976:){
    #####: 3977:  return ORIGVFS(pVfs)->xAccess(ORIGVFS(pVfs), zPath, flags, pResOut);
        -: 3978:}
    #####: 3979:static int apndFullPathname(
        -: 3980:  sqlite3_vfs *pVfs, 
        -: 3981:  const char *zPath, 
        -: 3982:  int nOut, 
        -: 3983:  char *zOut
        -: 3984:){
    #####: 3985:  return ORIGVFS(pVfs)->xFullPathname(ORIGVFS(pVfs),zPath,nOut,zOut);
        -: 3986:}
    #####: 3987:static void *apndDlOpen(sqlite3_vfs *pVfs, const char *zPath){
    #####: 3988:  return ORIGVFS(pVfs)->xDlOpen(ORIGVFS(pVfs), zPath);
        -: 3989:}
    #####: 3990:static void apndDlError(sqlite3_vfs *pVfs, int nByte, char *zErrMsg){
    #####: 3991:  ORIGVFS(pVfs)->xDlError(ORIGVFS(pVfs), nByte, zErrMsg);
    #####: 3992:}
    #####: 3993:static void (*apndDlSym(sqlite3_vfs *pVfs, void *p, const char *zSym))(void){
    #####: 3994:  return ORIGVFS(pVfs)->xDlSym(ORIGVFS(pVfs), p, zSym);
        -: 3995:}
    #####: 3996:static void apndDlClose(sqlite3_vfs *pVfs, void *pHandle){
    #####: 3997:  ORIGVFS(pVfs)->xDlClose(ORIGVFS(pVfs), pHandle);
    #####: 3998:}
    #####: 3999:static int apndRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){
    #####: 4000:  return ORIGVFS(pVfs)->xRandomness(ORIGVFS(pVfs), nByte, zBufOut);
        -: 4001:}
    #####: 4002:static int apndSleep(sqlite3_vfs *pVfs, int nMicro){
    #####: 4003:  return ORIGVFS(pVfs)->xSleep(ORIGVFS(pVfs), nMicro);
        -: 4004:}
    #####: 4005:static int apndCurrentTime(sqlite3_vfs *pVfs, double *pTimeOut){
    #####: 4006:  return ORIGVFS(pVfs)->xCurrentTime(ORIGVFS(pVfs), pTimeOut);
        -: 4007:}
    #####: 4008:static int apndGetLastError(sqlite3_vfs *pVfs, int a, char *b){
    #####: 4009:  return ORIGVFS(pVfs)->xGetLastError(ORIGVFS(pVfs), a, b);
        -: 4010:}
    #####: 4011:static int apndCurrentTimeInt64(sqlite3_vfs *pVfs, sqlite3_int64 *p){
    #####: 4012:  return ORIGVFS(pVfs)->xCurrentTimeInt64(ORIGVFS(pVfs), p);
        -: 4013:}
    #####: 4014:static int apndSetSystemCall(
        -: 4015:  sqlite3_vfs *pVfs,
        -: 4016:  const char *zName,
        -: 4017:  sqlite3_syscall_ptr pCall
        -: 4018:){
    #####: 4019:  return ORIGVFS(pVfs)->xSetSystemCall(ORIGVFS(pVfs),zName,pCall);
        -: 4020:}
    #####: 4021:static sqlite3_syscall_ptr apndGetSystemCall(
        -: 4022:  sqlite3_vfs *pVfs,
        -: 4023:  const char *zName
        -: 4024:){
    #####: 4025:  return ORIGVFS(pVfs)->xGetSystemCall(ORIGVFS(pVfs),zName);
        -: 4026:}
    #####: 4027:static const char *apndNextSystemCall(sqlite3_vfs *pVfs, const char *zName){
    #####: 4028:  return ORIGVFS(pVfs)->xNextSystemCall(ORIGVFS(pVfs), zName);
        -: 4029:}
        -: 4030:
        -: 4031:  
        -: 4032:#ifdef _WIN32
        -: 4033:
        -: 4034:#endif
        -: 4035:/* 
        -: 4036:** This routine is called when the extension is loaded.
        -: 4037:** Register the new VFS.
        -: 4038:*/
        2: 4039:int sqlite3_appendvfs_init(
        -: 4040:  sqlite3 *db, 
        -: 4041:  char **pzErrMsg, 
        -: 4042:  const sqlite3_api_routines *pApi
        -: 4043:){
        2: 4044:  int rc = SQLITE_OK;
        -: 4045:  sqlite3_vfs *pOrig;
        -: 4046:  SQLITE_EXTENSION_INIT2(pApi);
        -: 4047:  (void)pzErrMsg;
        -: 4048:  (void)db;
        2: 4049:  pOrig = sqlite3_vfs_find(0);
        2: 4050:  apnd_vfs.iVersion = pOrig->iVersion;
        2: 4051:  apnd_vfs.pAppData = pOrig;
        2: 4052:  apnd_vfs.szOsFile = pOrig->szOsFile + sizeof(ApndFile);
        2: 4053:  rc = sqlite3_vfs_register(&apnd_vfs, 0);
        -: 4054:#ifdef APPENDVFS_TEST
        -: 4055:  if( rc==SQLITE_OK ){
        -: 4056:    rc = sqlite3_auto_extension((void(*)(void))apndvfsRegister);
        -: 4057:  }
        -: 4058:#endif
        2: 4059:  if( rc==SQLITE_OK ) rc = SQLITE_OK_LOAD_PERMANENTLY;
        2: 4060:  return rc;
        -: 4061:}
        -: 4062:
        -: 4063:/************************* End ../ext/misc/appendvfs.c ********************/
        -: 4064:#ifdef SQLITE_HAVE_ZLIB
        -: 4065:/************************* Begin ../ext/misc/zipfile.c ******************/
        -: 4066:/*
        -: 4067:** 2017-12-26
        -: 4068:**
        -: 4069:** The author disclaims copyright to this source code.  In place of
        -: 4070:** a legal notice, here is a blessing:
        -: 4071:**
        -: 4072:**    May you do good and not evil.
        -: 4073:**    May you find forgiveness for yourself and forgive others.
        -: 4074:**    May you share freely, never taking more than you give.
        -: 4075:**
        -: 4076:******************************************************************************
        -: 4077:**
        -: 4078:** This file implements a virtual table for reading and writing ZIP archive
        -: 4079:** files.
        -: 4080:**
        -: 4081:** Usage example:
        -: 4082:**
        -: 4083:**     SELECT name, sz, datetime(mtime,'unixepoch') FROM zipfile($filename);
        -: 4084:**
        -: 4085:** Current limitations:
        -: 4086:**
        -: 4087:**    *  No support for encryption
        -: 4088:**    *  No support for ZIP archives spanning multiple files
        -: 4089:**    *  No support for zip64 extensions
        -: 4090:**    *  Only the "inflate/deflate" (zlib) compression method is supported
        -: 4091:*/
        -: 4092:SQLITE_EXTENSION_INIT1
        -: 4093:#include <stdio.h>
        -: 4094:#include <string.h>
        -: 4095:#include <assert.h>
        -: 4096:
        -: 4097:#include <zlib.h>
        -: 4098:
        -: 4099:#ifndef SQLITE_OMIT_VIRTUALTABLE
        -: 4100:
        -: 4101:#ifndef SQLITE_AMALGAMATION
        -: 4102:
        -: 4103:/* typedef sqlite3_int64 i64; */
        -: 4104:/* typedef unsigned char u8; */
        -: 4105:typedef unsigned short u16;
        -: 4106:typedef unsigned long u32;
        -: 4107:#define MIN(a,b) ((a)<(b) ? (a) : (b))
        -: 4108:
        -: 4109:#if defined(SQLITE_COVERAGE_TEST) || defined(SQLITE_MUTATION_TEST)
        -: 4110:# define ALWAYS(X)      (1)
        -: 4111:# define NEVER(X)       (0)
        -: 4112:#elif !defined(NDEBUG)
        -: 4113:# define ALWAYS(X)      ((X)?1:(assert(0),0))
        -: 4114:# define NEVER(X)       ((X)?(assert(0),1):0)
        -: 4115:#else
        -: 4116:# define ALWAYS(X)      (X)
        -: 4117:# define NEVER(X)       (X)
        -: 4118:#endif
        -: 4119:
        -: 4120:#endif   /* SQLITE_AMALGAMATION */
        -: 4121:
        -: 4122:/*
        -: 4123:** Definitions for mode bitmasks S_IFDIR, S_IFREG and S_IFLNK.
        -: 4124:**
        -: 4125:** In some ways it would be better to obtain these values from system 
        -: 4126:** header files. But, the dependency is undesirable and (a) these
        -: 4127:** have been stable for decades, (b) the values are part of POSIX and
        -: 4128:** are also made explicit in [man stat], and (c) are part of the 
        -: 4129:** file format for zip archives.
        -: 4130:*/
        -: 4131:#ifndef S_IFDIR
        -: 4132:# define S_IFDIR 0040000
        -: 4133:#endif
        -: 4134:#ifndef S_IFREG
        -: 4135:# define S_IFREG 0100000
        -: 4136:#endif
        -: 4137:#ifndef S_IFLNK
        -: 4138:# define S_IFLNK 0120000
        -: 4139:#endif
        -: 4140:
        -: 4141:static const char ZIPFILE_SCHEMA[] = 
        -: 4142:  "CREATE TABLE y("
        -: 4143:    "name PRIMARY KEY,"  /* 0: Name of file in zip archive */
        -: 4144:    "mode,"              /* 1: POSIX mode for file */
        -: 4145:    "mtime,"             /* 2: Last modification time (secs since 1970)*/
        -: 4146:    "sz,"                /* 3: Size of object */
        -: 4147:    "rawdata,"           /* 4: Raw data */
        -: 4148:    "data,"              /* 5: Uncompressed data */
        -: 4149:    "method,"            /* 6: Compression method (integer) */
        -: 4150:    "z HIDDEN"           /* 7: Name of zip file */
        -: 4151:  ") WITHOUT ROWID;";
        -: 4152:
        -: 4153:#define ZIPFILE_F_COLUMN_IDX 7    /* Index of column "file" in the above */
        -: 4154:#define ZIPFILE_BUFFER_SIZE (64*1024)
        -: 4155:
        -: 4156:
        -: 4157:/*
        -: 4158:** Magic numbers used to read and write zip files.
        -: 4159:**
        -: 4160:** ZIPFILE_NEWENTRY_MADEBY:
        -: 4161:**   Use this value for the "version-made-by" field in new zip file
        -: 4162:**   entries. The upper byte indicates "unix", and the lower byte 
        -: 4163:**   indicates that the zip file matches pkzip specification 3.0. 
        -: 4164:**   This is what info-zip seems to do.
        -: 4165:**
        -: 4166:** ZIPFILE_NEWENTRY_REQUIRED:
        -: 4167:**   Value for "version-required-to-extract" field of new entries.
        -: 4168:**   Version 2.0 is required to support folders and deflate compression.
        -: 4169:**
        -: 4170:** ZIPFILE_NEWENTRY_FLAGS:
        -: 4171:**   Value for "general-purpose-bit-flags" field of new entries. Bit
        -: 4172:**   11 means "utf-8 filename and comment".
        -: 4173:**
        -: 4174:** ZIPFILE_SIGNATURE_CDS:
        -: 4175:**   First 4 bytes of a valid CDS record.
        -: 4176:**
        -: 4177:** ZIPFILE_SIGNATURE_LFH:
        -: 4178:**   First 4 bytes of a valid LFH record.
        -: 4179:**
        -: 4180:** ZIPFILE_SIGNATURE_EOCD
        -: 4181:**   First 4 bytes of a valid EOCD record.
        -: 4182:*/
        -: 4183:#define ZIPFILE_EXTRA_TIMESTAMP   0x5455
        -: 4184:#define ZIPFILE_NEWENTRY_MADEBY   ((3<<8) + 30)
        -: 4185:#define ZIPFILE_NEWENTRY_REQUIRED 20
        -: 4186:#define ZIPFILE_NEWENTRY_FLAGS    0x800
        -: 4187:#define ZIPFILE_SIGNATURE_CDS     0x02014b50
        -: 4188:#define ZIPFILE_SIGNATURE_LFH     0x04034b50
        -: 4189:#define ZIPFILE_SIGNATURE_EOCD    0x06054b50
        -: 4190:
        -: 4191:/*
        -: 4192:** The sizes of the fixed-size part of each of the three main data 
        -: 4193:** structures in a zip archive.
        -: 4194:*/
        -: 4195:#define ZIPFILE_LFH_FIXED_SZ      30
        -: 4196:#define ZIPFILE_EOCD_FIXED_SZ     22
        -: 4197:#define ZIPFILE_CDS_FIXED_SZ      46
        -: 4198:
        -: 4199:/*
        -: 4200:*** 4.3.16  End of central directory record:
        -: 4201:***
        -: 4202:***   end of central dir signature    4 bytes  (0x06054b50)
        -: 4203:***   number of this disk             2 bytes
        -: 4204:***   number of the disk with the
        -: 4205:***   start of the central directory  2 bytes
        -: 4206:***   total number of entries in the
        -: 4207:***   central directory on this disk  2 bytes
        -: 4208:***   total number of entries in
        -: 4209:***   the central directory           2 bytes
        -: 4210:***   size of the central directory   4 bytes
        -: 4211:***   offset of start of central
        -: 4212:***   directory with respect to
        -: 4213:***   the starting disk number        4 bytes
        -: 4214:***   .ZIP file comment length        2 bytes
        -: 4215:***   .ZIP file comment       (variable size)
        -: 4216:*/
        -: 4217:typedef struct ZipfileEOCD ZipfileEOCD;
        -: 4218:struct ZipfileEOCD {
        -: 4219:  u16 iDisk;
        -: 4220:  u16 iFirstDisk;
        -: 4221:  u16 nEntry;
        -: 4222:  u16 nEntryTotal;
        -: 4223:  u32 nSize;
        -: 4224:  u32 iOffset;
        -: 4225:};
        -: 4226:
        -: 4227:/*
        -: 4228:*** 4.3.12  Central directory structure:
        -: 4229:***
        -: 4230:*** ...
        -: 4231:***
        -: 4232:***   central file header signature   4 bytes  (0x02014b50)
        -: 4233:***   version made by                 2 bytes
        -: 4234:***   version needed to extract       2 bytes
        -: 4235:***   general purpose bit flag        2 bytes
        -: 4236:***   compression method              2 bytes
        -: 4237:***   last mod file time              2 bytes
        -: 4238:***   last mod file date              2 bytes
        -: 4239:***   crc-32                          4 bytes
        -: 4240:***   compressed size                 4 bytes
        -: 4241:***   uncompressed size               4 bytes
        -: 4242:***   file name length                2 bytes
        -: 4243:***   extra field length              2 bytes
        -: 4244:***   file comment length             2 bytes
        -: 4245:***   disk number start               2 bytes
        -: 4246:***   internal file attributes        2 bytes
        -: 4247:***   external file attributes        4 bytes
        -: 4248:***   relative offset of local header 4 bytes
        -: 4249:*/
        -: 4250:typedef struct ZipfileCDS ZipfileCDS;
        -: 4251:struct ZipfileCDS {
        -: 4252:  u16 iVersionMadeBy;
        -: 4253:  u16 iVersionExtract;
        -: 4254:  u16 flags;
        -: 4255:  u16 iCompression;
        -: 4256:  u16 mTime;
        -: 4257:  u16 mDate;
        -: 4258:  u32 crc32;
        -: 4259:  u32 szCompressed;
        -: 4260:  u32 szUncompressed;
        -: 4261:  u16 nFile;
        -: 4262:  u16 nExtra;
        -: 4263:  u16 nComment;
        -: 4264:  u16 iDiskStart;
        -: 4265:  u16 iInternalAttr;
        -: 4266:  u32 iExternalAttr;
        -: 4267:  u32 iOffset;
        -: 4268:  char *zFile;                    /* Filename (sqlite3_malloc()) */
        -: 4269:};
        -: 4270:
        -: 4271:/*
        -: 4272:*** 4.3.7  Local file header:
        -: 4273:***
        -: 4274:***   local file header signature     4 bytes  (0x04034b50)
        -: 4275:***   version needed to extract       2 bytes
        -: 4276:***   general purpose bit flag        2 bytes
        -: 4277:***   compression method              2 bytes
        -: 4278:***   last mod file time              2 bytes
        -: 4279:***   last mod file date              2 bytes
        -: 4280:***   crc-32                          4 bytes
        -: 4281:***   compressed size                 4 bytes
        -: 4282:***   uncompressed size               4 bytes
        -: 4283:***   file name length                2 bytes
        -: 4284:***   extra field length              2 bytes
        -: 4285:***   
        -: 4286:*/
        -: 4287:typedef struct ZipfileLFH ZipfileLFH;
        -: 4288:struct ZipfileLFH {
        -: 4289:  u16 iVersionExtract;
        -: 4290:  u16 flags;
        -: 4291:  u16 iCompression;
        -: 4292:  u16 mTime;
        -: 4293:  u16 mDate;
        -: 4294:  u32 crc32;
        -: 4295:  u32 szCompressed;
        -: 4296:  u32 szUncompressed;
        -: 4297:  u16 nFile;
        -: 4298:  u16 nExtra;
        -: 4299:};
        -: 4300:
        -: 4301:typedef struct ZipfileEntry ZipfileEntry;
        -: 4302:struct ZipfileEntry {
        -: 4303:  ZipfileCDS cds;            /* Parsed CDS record */
        -: 4304:  u32 mUnixTime;             /* Modification time, in UNIX format */
        -: 4305:  u8 *aExtra;                /* cds.nExtra+cds.nComment bytes of extra data */
        -: 4306:  i64 iDataOff;              /* Offset to data in file (if aData==0) */
        -: 4307:  u8 *aData;                 /* cds.szCompressed bytes of compressed data */
        -: 4308:  ZipfileEntry *pNext;       /* Next element in in-memory CDS */
        -: 4309:};
        -: 4310:
        -: 4311:/* 
        -: 4312:** Cursor type for zipfile tables.
        -: 4313:*/
        -: 4314:typedef struct ZipfileCsr ZipfileCsr;
        -: 4315:struct ZipfileCsr {
        -: 4316:  sqlite3_vtab_cursor base;  /* Base class - must be first */
        -: 4317:  i64 iId;                   /* Cursor ID */
        -: 4318:  u8 bEof;                   /* True when at EOF */
        -: 4319:  u8 bNoop;                  /* If next xNext() call is no-op */
        -: 4320:
        -: 4321:  /* Used outside of write transactions */
        -: 4322:  FILE *pFile;               /* Zip file */
        -: 4323:  i64 iNextOff;              /* Offset of next record in central directory */
        -: 4324:  ZipfileEOCD eocd;          /* Parse of central directory record */
        -: 4325:
        -: 4326:  ZipfileEntry *pFreeEntry;  /* Free this list when cursor is closed or reset */
        -: 4327:  ZipfileEntry *pCurrent;    /* Current entry */
        -: 4328:  ZipfileCsr *pCsrNext;      /* Next cursor on same virtual table */
        -: 4329:};
        -: 4330:
        -: 4331:typedef struct ZipfileTab ZipfileTab;
        -: 4332:struct ZipfileTab {
        -: 4333:  sqlite3_vtab base;         /* Base class - must be first */
        -: 4334:  char *zFile;               /* Zip file this table accesses (may be NULL) */
        -: 4335:  sqlite3 *db;               /* Host database connection */
        -: 4336:  u8 *aBuffer;               /* Temporary buffer used for various tasks */
        -: 4337:
        -: 4338:  ZipfileCsr *pCsrList;      /* List of cursors */
        -: 4339:  i64 iNextCsrid;
        -: 4340:
        -: 4341:  /* The following are used by write transactions only */
        -: 4342:  ZipfileEntry *pFirstEntry; /* Linked list of all files (if pWriteFd!=0) */
        -: 4343:  ZipfileEntry *pLastEntry;  /* Last element in pFirstEntry list */
        -: 4344:  FILE *pWriteFd;            /* File handle open on zip archive */
        -: 4345:  i64 szCurrent;             /* Current size of zip archive */
        -: 4346:  i64 szOrig;                /* Size of archive at start of transaction */
        -: 4347:};
        -: 4348:
        -: 4349:/*
        -: 4350:** Set the error message contained in context ctx to the results of
        -: 4351:** vprintf(zFmt, ...).
        -: 4352:*/
    #####: 4353:static void zipfileCtxErrorMsg(sqlite3_context *ctx, const char *zFmt, ...){
    #####: 4354:  char *zMsg = 0;
        -: 4355:  va_list ap;
    #####: 4356:  va_start(ap, zFmt);
    #####: 4357:  zMsg = sqlite3_vmprintf(zFmt, ap);
    #####: 4358:  sqlite3_result_error(ctx, zMsg, -1);
    #####: 4359:  sqlite3_free(zMsg);
    #####: 4360:  va_end(ap);
    #####: 4361:}
        -: 4362:
        -: 4363:/*
        -: 4364:** If string zIn is quoted, dequote it in place. Otherwise, if the string
        -: 4365:** is not quoted, do nothing.
        -: 4366:*/
    #####: 4367:static void zipfileDequote(char *zIn){
    #####: 4368:  char q = zIn[0];
    #####: 4369:  if( q=='"' || q=='\'' || q=='`' || q=='[' ){
    #####: 4370:    int iIn = 1;
    #####: 4371:    int iOut = 0;
    #####: 4372:    if( q=='[' ) q = ']';
    #####: 4373:    while( ALWAYS(zIn[iIn]) ){
    #####: 4374:      char c = zIn[iIn++];
    #####: 4375:      if( c==q && zIn[iIn++]!=q ) break;
    #####: 4376:      zIn[iOut++] = c;
        -: 4377:    }
    #####: 4378:    zIn[iOut] = '\0';
        -: 4379:  }
    #####: 4380:}
        -: 4381:
        -: 4382:/*
        -: 4383:** Construct a new ZipfileTab virtual table object.
        -: 4384:** 
        -: 4385:**   argv[0]   -> module name  ("zipfile")
        -: 4386:**   argv[1]   -> database name
        -: 4387:**   argv[2]   -> table name
        -: 4388:**   argv[...] -> "column name" and other module argument fields.
        -: 4389:*/
    #####: 4390:static int zipfileConnect(
        -: 4391:  sqlite3 *db,
        -: 4392:  void *pAux,
        -: 4393:  int argc, const char *const*argv,
        -: 4394:  sqlite3_vtab **ppVtab,
        -: 4395:  char **pzErr
        -: 4396:){
    #####: 4397:  int nByte = sizeof(ZipfileTab) + ZIPFILE_BUFFER_SIZE;
    #####: 4398:  int nFile = 0;
    #####: 4399:  const char *zFile = 0;
    #####: 4400:  ZipfileTab *pNew = 0;
        -: 4401:  int rc;
        -: 4402:
        -: 4403:  /* If the table name is not "zipfile", require that the argument be
        -: 4404:  ** specified. This stops zipfile tables from being created as:
        -: 4405:  **
        -: 4406:  **   CREATE VIRTUAL TABLE zzz USING zipfile();
        -: 4407:  **
        -: 4408:  ** It does not prevent:
        -: 4409:  **
        -: 4410:  **   CREATE VIRTUAL TABLE zipfile USING zipfile();
        -: 4411:  */
        -: 4412:  assert( 0==sqlite3_stricmp(argv[0], "zipfile") );
    #####: 4413:  if( (0!=sqlite3_stricmp(argv[2], "zipfile") && argc<4) || argc>4 ){
    #####: 4414:    *pzErr = sqlite3_mprintf("zipfile constructor requires one argument");
    #####: 4415:    return SQLITE_ERROR;
        -: 4416:  }
        -: 4417:
    #####: 4418:  if( argc>3 ){
    #####: 4419:    zFile = argv[3];
    #####: 4420:    nFile = (int)strlen(zFile)+1;
        -: 4421:  }
        -: 4422:
    #####: 4423:  rc = sqlite3_declare_vtab(db, ZIPFILE_SCHEMA);
    #####: 4424:  if( rc==SQLITE_OK ){
    #####: 4425:    pNew = (ZipfileTab*)sqlite3_malloc(nByte+nFile);
    #####: 4426:    if( pNew==0 ) return SQLITE_NOMEM;
    #####: 4427:    memset(pNew, 0, nByte+nFile);
    #####: 4428:    pNew->db = db;
    #####: 4429:    pNew->aBuffer = (u8*)&pNew[1];
    #####: 4430:    if( zFile ){
    #####: 4431:      pNew->zFile = (char*)&pNew->aBuffer[ZIPFILE_BUFFER_SIZE];
    #####: 4432:      memcpy(pNew->zFile, zFile, nFile);
    #####: 4433:      zipfileDequote(pNew->zFile);
        -: 4434:    }
        -: 4435:  }
    #####: 4436:  *ppVtab = (sqlite3_vtab*)pNew;
    #####: 4437:  return rc;
        -: 4438:}
        -: 4439:
        -: 4440:/*
        -: 4441:** Free the ZipfileEntry structure indicated by the only argument.
        -: 4442:*/
    #####: 4443:static void zipfileEntryFree(ZipfileEntry *p){
    #####: 4444:  if( p ){
    #####: 4445:    sqlite3_free(p->cds.zFile);
    #####: 4446:    sqlite3_free(p);
        -: 4447:  }
    #####: 4448:}
        -: 4449:
        -: 4450:/*
        -: 4451:** Release resources that should be freed at the end of a write 
        -: 4452:** transaction.
        -: 4453:*/
    #####: 4454:static void zipfileCleanupTransaction(ZipfileTab *pTab){
        -: 4455:  ZipfileEntry *pEntry;
        -: 4456:  ZipfileEntry *pNext;
        -: 4457:
    #####: 4458:  if( pTab->pWriteFd ){
    #####: 4459:    fclose(pTab->pWriteFd);
    #####: 4460:    pTab->pWriteFd = 0;
        -: 4461:  }
    #####: 4462:  for(pEntry=pTab->pFirstEntry; pEntry; pEntry=pNext){
    #####: 4463:    pNext = pEntry->pNext;
    #####: 4464:    zipfileEntryFree(pEntry);
        -: 4465:  }
    #####: 4466:  pTab->pFirstEntry = 0;
    #####: 4467:  pTab->pLastEntry = 0;
    #####: 4468:  pTab->szCurrent = 0;
    #####: 4469:  pTab->szOrig = 0;
    #####: 4470:}
        -: 4471:
        -: 4472:/*
        -: 4473:** This method is the destructor for zipfile vtab objects.
        -: 4474:*/
    #####: 4475:static int zipfileDisconnect(sqlite3_vtab *pVtab){
    #####: 4476:  zipfileCleanupTransaction((ZipfileTab*)pVtab);
    #####: 4477:  sqlite3_free(pVtab);
    #####: 4478:  return SQLITE_OK;
        -: 4479:}
        -: 4480:
        -: 4481:/*
        -: 4482:** Constructor for a new ZipfileCsr object.
        -: 4483:*/
    #####: 4484:static int zipfileOpen(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCsr){
    #####: 4485:  ZipfileTab *pTab = (ZipfileTab*)p;
        -: 4486:  ZipfileCsr *pCsr;
    #####: 4487:  pCsr = sqlite3_malloc(sizeof(*pCsr));
    #####: 4488:  *ppCsr = (sqlite3_vtab_cursor*)pCsr;
    #####: 4489:  if( pCsr==0 ){
    #####: 4490:    return SQLITE_NOMEM;
        -: 4491:  }
    #####: 4492:  memset(pCsr, 0, sizeof(*pCsr));
    #####: 4493:  pCsr->iId = ++pTab->iNextCsrid;
    #####: 4494:  pCsr->pCsrNext = pTab->pCsrList;
    #####: 4495:  pTab->pCsrList = pCsr;
    #####: 4496:  return SQLITE_OK;
        -: 4497:}
        -: 4498:
        -: 4499:/*
        -: 4500:** Reset a cursor back to the state it was in when first returned
        -: 4501:** by zipfileOpen().
        -: 4502:*/
    #####: 4503:static void zipfileResetCursor(ZipfileCsr *pCsr){
        -: 4504:  ZipfileEntry *p;
        -: 4505:  ZipfileEntry *pNext;
        -: 4506:
    #####: 4507:  pCsr->bEof = 0;
    #####: 4508:  if( pCsr->pFile ){
    #####: 4509:    fclose(pCsr->pFile);
    #####: 4510:    pCsr->pFile = 0;
    #####: 4511:    zipfileEntryFree(pCsr->pCurrent);
    #####: 4512:    pCsr->pCurrent = 0;
        -: 4513:  }
        -: 4514:
    #####: 4515:  for(p=pCsr->pFreeEntry; p; p=pNext){
    #####: 4516:    pNext = p->pNext;
    #####: 4517:    zipfileEntryFree(p);
        -: 4518:  }
    #####: 4519:}
        -: 4520:
        -: 4521:/*
        -: 4522:** Destructor for an ZipfileCsr.
        -: 4523:*/
    #####: 4524:static int zipfileClose(sqlite3_vtab_cursor *cur){
    #####: 4525:  ZipfileCsr *pCsr = (ZipfileCsr*)cur;
    #####: 4526:  ZipfileTab *pTab = (ZipfileTab*)(pCsr->base.pVtab);
        -: 4527:  ZipfileCsr **pp;
    #####: 4528:  zipfileResetCursor(pCsr);
        -: 4529:
        -: 4530:  /* Remove this cursor from the ZipfileTab.pCsrList list. */
    #####: 4531:  for(pp=&pTab->pCsrList; *pp!=pCsr; pp=&((*pp)->pCsrNext));
    #####: 4532:  *pp = pCsr->pCsrNext;
        -: 4533:
    #####: 4534:  sqlite3_free(pCsr);
    #####: 4535:  return SQLITE_OK;
        -: 4536:}
        -: 4537:
        -: 4538:/*
        -: 4539:** Set the error message for the virtual table associated with cursor
        -: 4540:** pCsr to the results of vprintf(zFmt, ...).
        -: 4541:*/
    #####: 4542:static void zipfileTableErr(ZipfileTab *pTab, const char *zFmt, ...){
        -: 4543:  va_list ap;
    #####: 4544:  va_start(ap, zFmt);
    #####: 4545:  sqlite3_free(pTab->base.zErrMsg);
    #####: 4546:  pTab->base.zErrMsg = sqlite3_vmprintf(zFmt, ap);
    #####: 4547:  va_end(ap);
    #####: 4548:}
    #####: 4549:static void zipfileCursorErr(ZipfileCsr *pCsr, const char *zFmt, ...){
        -: 4550:  va_list ap;
    #####: 4551:  va_start(ap, zFmt);
    #####: 4552:  sqlite3_free(pCsr->base.pVtab->zErrMsg);
    #####: 4553:  pCsr->base.pVtab->zErrMsg = sqlite3_vmprintf(zFmt, ap);
    #####: 4554:  va_end(ap);
    #####: 4555:}
        -: 4556:
        -: 4557:/*
        -: 4558:** Read nRead bytes of data from offset iOff of file pFile into buffer
        -: 4559:** aRead[]. Return SQLITE_OK if successful, or an SQLite error code
        -: 4560:** otherwise. 
        -: 4561:**
        -: 4562:** If an error does occur, output variable (*pzErrmsg) may be set to point
        -: 4563:** to an English language error message. It is the responsibility of the
        -: 4564:** caller to eventually free this buffer using
        -: 4565:** sqlite3_free().
        -: 4566:*/
    #####: 4567:static int zipfileReadData(
        -: 4568:  FILE *pFile,                    /* Read from this file */
        -: 4569:  u8 *aRead,                      /* Read into this buffer */
        -: 4570:  int nRead,                      /* Number of bytes to read */
        -: 4571:  i64 iOff,                       /* Offset to read from */
        -: 4572:  char **pzErrmsg                 /* OUT: Error message (from sqlite3_malloc) */
        -: 4573:){
        -: 4574:  size_t n;
    #####: 4575:  fseek(pFile, (long)iOff, SEEK_SET);
    #####: 4576:  n = fread(aRead, 1, nRead, pFile);
    #####: 4577:  if( (int)n!=nRead ){
    #####: 4578:    *pzErrmsg = sqlite3_mprintf("error in fread()");
    #####: 4579:    return SQLITE_ERROR;
        -: 4580:  }
    #####: 4581:  return SQLITE_OK;
        -: 4582:}
        -: 4583:
    #####: 4584:static int zipfileAppendData(
        -: 4585:  ZipfileTab *pTab,
        -: 4586:  const u8 *aWrite,
        -: 4587:  int nWrite
        -: 4588:){
        -: 4589:  size_t n;
    #####: 4590:  fseek(pTab->pWriteFd, (long)pTab->szCurrent, SEEK_SET);
    #####: 4591:  n = fwrite(aWrite, 1, nWrite, pTab->pWriteFd);
    #####: 4592:  if( (int)n!=nWrite ){
    #####: 4593:    pTab->base.zErrMsg = sqlite3_mprintf("error in fwrite()");
    #####: 4594:    return SQLITE_ERROR;
        -: 4595:  }
    #####: 4596:  pTab->szCurrent += nWrite;
    #####: 4597:  return SQLITE_OK;
        -: 4598:}
        -: 4599:
        -: 4600:/*
        -: 4601:** Read and return a 16-bit little-endian unsigned integer from buffer aBuf.
        -: 4602:*/
    #####: 4603:static u16 zipfileGetU16(const u8 *aBuf){
    #####: 4604:  return (aBuf[1] << 8) + aBuf[0];
        -: 4605:}
        -: 4606:
        -: 4607:/*
        -: 4608:** Read and return a 32-bit little-endian unsigned integer from buffer aBuf.
        -: 4609:*/
    #####: 4610:static u32 zipfileGetU32(const u8 *aBuf){
    #####: 4611:  return ((u32)(aBuf[3]) << 24)
    #####: 4612:       + ((u32)(aBuf[2]) << 16)
    #####: 4613:       + ((u32)(aBuf[1]) <<  8)
    #####: 4614:       + ((u32)(aBuf[0]) <<  0);
        -: 4615:}
        -: 4616:
        -: 4617:/*
        -: 4618:** Write a 16-bit little endiate integer into buffer aBuf.
        -: 4619:*/
    #####: 4620:static void zipfilePutU16(u8 *aBuf, u16 val){
    #####: 4621:  aBuf[0] = val & 0xFF;
    #####: 4622:  aBuf[1] = (val>>8) & 0xFF;
    #####: 4623:}
        -: 4624:
        -: 4625:/*
        -: 4626:** Write a 32-bit little endiate integer into buffer aBuf.
        -: 4627:*/
    #####: 4628:static void zipfilePutU32(u8 *aBuf, u32 val){
    #####: 4629:  aBuf[0] = val & 0xFF;
    #####: 4630:  aBuf[1] = (val>>8) & 0xFF;
    #####: 4631:  aBuf[2] = (val>>16) & 0xFF;
    #####: 4632:  aBuf[3] = (val>>24) & 0xFF;
    #####: 4633:}
        -: 4634:
        -: 4635:#define zipfileRead32(aBuf) ( aBuf+=4, zipfileGetU32(aBuf-4) )
        -: 4636:#define zipfileRead16(aBuf) ( aBuf+=2, zipfileGetU16(aBuf-2) )
        -: 4637:
        -: 4638:#define zipfileWrite32(aBuf,val) { zipfilePutU32(aBuf,val); aBuf+=4; }
        -: 4639:#define zipfileWrite16(aBuf,val) { zipfilePutU16(aBuf,val); aBuf+=2; }
        -: 4640:
        -: 4641:/*
        -: 4642:** Magic numbers used to read CDS records.
        -: 4643:*/
        -: 4644:#define ZIPFILE_CDS_NFILE_OFF        28
        -: 4645:#define ZIPFILE_CDS_SZCOMPRESSED_OFF 20
        -: 4646:
        -: 4647:/*
        -: 4648:** Decode the CDS record in buffer aBuf into (*pCDS). Return SQLITE_ERROR
        -: 4649:** if the record is not well-formed, or SQLITE_OK otherwise.
        -: 4650:*/
    #####: 4651:static int zipfileReadCDS(u8 *aBuf, ZipfileCDS *pCDS){
    #####: 4652:  u8 *aRead = aBuf;
    #####: 4653:  u32 sig = zipfileRead32(aRead);
    #####: 4654:  int rc = SQLITE_OK;
    #####: 4655:  if( sig!=ZIPFILE_SIGNATURE_CDS ){
    #####: 4656:    rc = SQLITE_ERROR;
        -: 4657:  }else{
    #####: 4658:    pCDS->iVersionMadeBy = zipfileRead16(aRead);
    #####: 4659:    pCDS->iVersionExtract = zipfileRead16(aRead);
    #####: 4660:    pCDS->flags = zipfileRead16(aRead);
    #####: 4661:    pCDS->iCompression = zipfileRead16(aRead);
    #####: 4662:    pCDS->mTime = zipfileRead16(aRead);
    #####: 4663:    pCDS->mDate = zipfileRead16(aRead);
    #####: 4664:    pCDS->crc32 = zipfileRead32(aRead);
    #####: 4665:    pCDS->szCompressed = zipfileRead32(aRead);
    #####: 4666:    pCDS->szUncompressed = zipfileRead32(aRead);
        -: 4667:    assert( aRead==&aBuf[ZIPFILE_CDS_NFILE_OFF] );
    #####: 4668:    pCDS->nFile = zipfileRead16(aRead);
    #####: 4669:    pCDS->nExtra = zipfileRead16(aRead);
    #####: 4670:    pCDS->nComment = zipfileRead16(aRead);
    #####: 4671:    pCDS->iDiskStart = zipfileRead16(aRead);
    #####: 4672:    pCDS->iInternalAttr = zipfileRead16(aRead);
    #####: 4673:    pCDS->iExternalAttr = zipfileRead32(aRead);
    #####: 4674:    pCDS->iOffset = zipfileRead32(aRead);
        -: 4675:    assert( aRead==&aBuf[ZIPFILE_CDS_FIXED_SZ] );
        -: 4676:  }
        -: 4677:
    #####: 4678:  return rc;
        -: 4679:}
        -: 4680:
        -: 4681:/*
        -: 4682:** Decode the LFH record in buffer aBuf into (*pLFH). Return SQLITE_ERROR
        -: 4683:** if the record is not well-formed, or SQLITE_OK otherwise.
        -: 4684:*/
    #####: 4685:static int zipfileReadLFH(
        -: 4686:  u8 *aBuffer,
        -: 4687:  ZipfileLFH *pLFH
        -: 4688:){
    #####: 4689:  u8 *aRead = aBuffer;
    #####: 4690:  int rc = SQLITE_OK;
        -: 4691:
    #####: 4692:  u32 sig = zipfileRead32(aRead);
    #####: 4693:  if( sig!=ZIPFILE_SIGNATURE_LFH ){
    #####: 4694:    rc = SQLITE_ERROR;
        -: 4695:  }else{
    #####: 4696:    pLFH->iVersionExtract = zipfileRead16(aRead);
    #####: 4697:    pLFH->flags = zipfileRead16(aRead);
    #####: 4698:    pLFH->iCompression = zipfileRead16(aRead);
    #####: 4699:    pLFH->mTime = zipfileRead16(aRead);
    #####: 4700:    pLFH->mDate = zipfileRead16(aRead);
    #####: 4701:    pLFH->crc32 = zipfileRead32(aRead);
    #####: 4702:    pLFH->szCompressed = zipfileRead32(aRead);
    #####: 4703:    pLFH->szUncompressed = zipfileRead32(aRead);
    #####: 4704:    pLFH->nFile = zipfileRead16(aRead);
    #####: 4705:    pLFH->nExtra = zipfileRead16(aRead);
        -: 4706:  }
    #####: 4707:  return rc;
        -: 4708:}
        -: 4709:
        -: 4710:
        -: 4711:/*
        -: 4712:** Buffer aExtra (size nExtra bytes) contains zip archive "extra" fields.
        -: 4713:** Scan through this buffer to find an "extra-timestamp" field. If one
        -: 4714:** exists, extract the 32-bit modification-timestamp from it and store
        -: 4715:** the value in output parameter *pmTime.
        -: 4716:**
        -: 4717:** Zero is returned if no extra-timestamp record could be found (and so
        -: 4718:** *pmTime is left unchanged), or non-zero otherwise.
        -: 4719:**
        -: 4720:** The general format of an extra field is:
        -: 4721:**
        -: 4722:**   Header ID    2 bytes
        -: 4723:**   Data Size    2 bytes
        -: 4724:**   Data         N bytes
        -: 4725:*/
    #####: 4726:static int zipfileScanExtra(u8 *aExtra, int nExtra, u32 *pmTime){
    #####: 4727:  int ret = 0;
    #####: 4728:  u8 *p = aExtra;
    #####: 4729:  u8 *pEnd = &aExtra[nExtra];
        -: 4730:
    #####: 4731:  while( p<pEnd ){
    #####: 4732:    u16 id = zipfileRead16(p);
    #####: 4733:    u16 nByte = zipfileRead16(p);
        -: 4734:
    #####: 4735:    switch( id ){
    #####: 4736:      case ZIPFILE_EXTRA_TIMESTAMP: {
    #####: 4737:        u8 b = p[0];
    #####: 4738:        if( b & 0x01 ){     /* 0x01 -> modtime is present */
    #####: 4739:          *pmTime = zipfileGetU32(&p[1]);
    #####: 4740:          ret = 1;
        -: 4741:        }
    #####: 4742:        break;
        -: 4743:      }
        -: 4744:    }
        -: 4745:
    #####: 4746:    p += nByte;
        -: 4747:  }
    #####: 4748:  return ret;
        -: 4749:}
        -: 4750:
        -: 4751:/*
        -: 4752:** Convert the standard MS-DOS timestamp stored in the mTime and mDate
        -: 4753:** fields of the CDS structure passed as the only argument to a 32-bit
        -: 4754:** UNIX seconds-since-the-epoch timestamp. Return the result.
        -: 4755:**
        -: 4756:** "Standard" MS-DOS time format:
        -: 4757:**
        -: 4758:**   File modification time:
        -: 4759:**     Bits 00-04: seconds divided by 2
        -: 4760:**     Bits 05-10: minute
        -: 4761:**     Bits 11-15: hour
        -: 4762:**   File modification date:
        -: 4763:**     Bits 00-04: day
        -: 4764:**     Bits 05-08: month (1-12)
        -: 4765:**     Bits 09-15: years from 1980 
        -: 4766:**
        -: 4767:** https://msdn.microsoft.com/en-us/library/9kkf9tah.aspx
        -: 4768:*/
    #####: 4769:static u32 zipfileMtime(ZipfileCDS *pCDS){
    #####: 4770:  int Y = (1980 + ((pCDS->mDate >> 9) & 0x7F));
    #####: 4771:  int M = ((pCDS->mDate >> 5) & 0x0F);
    #####: 4772:  int D = (pCDS->mDate & 0x1F);
    #####: 4773:  int B = -13;
        -: 4774:
    #####: 4775:  int sec = (pCDS->mTime & 0x1F)*2;
    #####: 4776:  int min = (pCDS->mTime >> 5) & 0x3F;
    #####: 4777:  int hr = (pCDS->mTime >> 11) & 0x1F;
        -: 4778:  i64 JD;
        -: 4779:
        -: 4780:  /* JD = INT(365.25 * (Y+4716)) + INT(30.6001 * (M+1)) + D + B - 1524.5 */
        -: 4781:
        -: 4782:  /* Calculate the JD in seconds for noon on the day in question */
    #####: 4783:  if( M<3 ){
    #####: 4784:    Y = Y-1;
    #####: 4785:    M = M+12;
        -: 4786:  }
    #####: 4787:  JD = (i64)(24*60*60) * (
    #####: 4788:      (int)(365.25 * (Y + 4716))
    #####: 4789:    + (int)(30.6001 * (M + 1))
    #####: 4790:    + D + B - 1524
        -: 4791:  );
        -: 4792:
        -: 4793:  /* Correct the JD for the time within the day */
    #####: 4794:  JD += (hr-12) * 3600 + min * 60 + sec;
        -: 4795:
        -: 4796:  /* Convert JD to unix timestamp (the JD epoch is 2440587.5) */
    #####: 4797:  return (u32)(JD - (i64)(24405875) * 24*60*6);
        -: 4798:}
        -: 4799:
        -: 4800:/*
        -: 4801:** The opposite of zipfileMtime(). This function populates the mTime and
        -: 4802:** mDate fields of the CDS structure passed as the first argument according
        -: 4803:** to the UNIX timestamp value passed as the second.
        -: 4804:*/
    #####: 4805:static void zipfileMtimeToDos(ZipfileCDS *pCds, u32 mUnixTime){
        -: 4806:  /* Convert unix timestamp to JD (2440588 is noon on 1/1/1970) */
    #####: 4807:  i64 JD = (i64)2440588 + mUnixTime / (24*60*60);
        -: 4808:
        -: 4809:  int A, B, C, D, E;
        -: 4810:  int yr, mon, day;
        -: 4811:  int hr, min, sec;
        -: 4812:
    #####: 4813:  A = (int)((JD - 1867216.25)/36524.25);
    #####: 4814:  A = (int)(JD + 1 + A - (A/4));
    #####: 4815:  B = A + 1524;
    #####: 4816:  C = (int)((B - 122.1)/365.25);
    #####: 4817:  D = (36525*(C&32767))/100;
    #####: 4818:  E = (int)((B-D)/30.6001);
        -: 4819:
    #####: 4820:  day = B - D - (int)(30.6001*E);
    #####: 4821:  mon = (E<14 ? E-1 : E-13);
    #####: 4822:  yr = mon>2 ? C-4716 : C-4715;
        -: 4823:
    #####: 4824:  hr = (mUnixTime % (24*60*60)) / (60*60);
    #####: 4825:  min = (mUnixTime % (60*60)) / 60;
    #####: 4826:  sec = (mUnixTime % 60);
        -: 4827:
    #####: 4828:  if( yr>=1980 ){
    #####: 4829:    pCds->mDate = (u16)(day + (mon << 5) + ((yr-1980) << 9));
    #####: 4830:    pCds->mTime = (u16)(sec/2 + (min<<5) + (hr<<11));
        -: 4831:  }else{
    #####: 4832:    pCds->mDate = pCds->mTime = 0;
        -: 4833:  }
        -: 4834:
        -: 4835:  assert( mUnixTime<315507600 
        -: 4836:       || mUnixTime==zipfileMtime(pCds) 
        -: 4837:       || ((mUnixTime % 2) && mUnixTime-1==zipfileMtime(pCds)) 
        -: 4838:       /* || (mUnixTime % 2) */
        -: 4839:  );
    #####: 4840:}
        -: 4841:
        -: 4842:/*
        -: 4843:** If aBlob is not NULL, then it is a pointer to a buffer (nBlob bytes in
        -: 4844:** size) containing an entire zip archive image. Or, if aBlob is NULL,
        -: 4845:** then pFile is a file-handle open on a zip file. In either case, this
        -: 4846:** function creates a ZipfileEntry object based on the zip archive entry
        -: 4847:** for which the CDS record is at offset iOff.
        -: 4848:**
        -: 4849:** If successful, SQLITE_OK is returned and (*ppEntry) set to point to
        -: 4850:** the new object. Otherwise, an SQLite error code is returned and the
        -: 4851:** final value of (*ppEntry) undefined.
        -: 4852:*/
    #####: 4853:static int zipfileGetEntry(
        -: 4854:  ZipfileTab *pTab,               /* Store any error message here */
        -: 4855:  const u8 *aBlob,                /* Pointer to in-memory file image */
        -: 4856:  int nBlob,                      /* Size of aBlob[] in bytes */
        -: 4857:  FILE *pFile,                    /* If aBlob==0, read from this file */
        -: 4858:  i64 iOff,                       /* Offset of CDS record */
        -: 4859:  ZipfileEntry **ppEntry          /* OUT: Pointer to new object */
        -: 4860:){
        -: 4861:  u8 *aRead;
    #####: 4862:  char **pzErr = &pTab->base.zErrMsg;
    #####: 4863:  int rc = SQLITE_OK;
        -: 4864:
    #####: 4865:  if( aBlob==0 ){
    #####: 4866:    aRead = pTab->aBuffer;
    #####: 4867:    rc = zipfileReadData(pFile, aRead, ZIPFILE_CDS_FIXED_SZ, iOff, pzErr);
        -: 4868:  }else{
    #####: 4869:    aRead = (u8*)&aBlob[iOff];
        -: 4870:  }
        -: 4871:
    #####: 4872:  if( rc==SQLITE_OK ){
        -: 4873:    int nAlloc;
        -: 4874:    ZipfileEntry *pNew;
        -: 4875:
    #####: 4876:    int nFile = zipfileGetU16(&aRead[ZIPFILE_CDS_NFILE_OFF]);
    #####: 4877:    int nExtra = zipfileGetU16(&aRead[ZIPFILE_CDS_NFILE_OFF+2]);
    #####: 4878:    nExtra += zipfileGetU16(&aRead[ZIPFILE_CDS_NFILE_OFF+4]);
        -: 4879:
    #####: 4880:    nAlloc = sizeof(ZipfileEntry) + nExtra;
    #####: 4881:    if( aBlob ){
    #####: 4882:      nAlloc += zipfileGetU32(&aRead[ZIPFILE_CDS_SZCOMPRESSED_OFF]);
        -: 4883:    }
        -: 4884:
    #####: 4885:    pNew = (ZipfileEntry*)sqlite3_malloc(nAlloc);
    #####: 4886:    if( pNew==0 ){
    #####: 4887:      rc = SQLITE_NOMEM;
        -: 4888:    }else{
    #####: 4889:      memset(pNew, 0, sizeof(ZipfileEntry));
    #####: 4890:      rc = zipfileReadCDS(aRead, &pNew->cds);
    #####: 4891:      if( rc!=SQLITE_OK ){
    #####: 4892:        *pzErr = sqlite3_mprintf("failed to read CDS at offset %lld", iOff);
    #####: 4893:      }else if( aBlob==0 ){
    #####: 4894:        rc = zipfileReadData(
        -: 4895:            pFile, aRead, nExtra+nFile, iOff+ZIPFILE_CDS_FIXED_SZ, pzErr
        -: 4896:        );
        -: 4897:      }else{
    #####: 4898:        aRead = (u8*)&aBlob[iOff + ZIPFILE_CDS_FIXED_SZ];
        -: 4899:      }
        -: 4900:    }
        -: 4901:
    #####: 4902:    if( rc==SQLITE_OK ){
    #####: 4903:      u32 *pt = &pNew->mUnixTime;
    #####: 4904:      pNew->cds.zFile = sqlite3_mprintf("%.*s", nFile, aRead); 
    #####: 4905:      pNew->aExtra = (u8*)&pNew[1];
    #####: 4906:      memcpy(pNew->aExtra, &aRead[nFile], nExtra);
    #####: 4907:      if( pNew->cds.zFile==0 ){
    #####: 4908:        rc = SQLITE_NOMEM;
    #####: 4909:      }else if( 0==zipfileScanExtra(&aRead[nFile], pNew->cds.nExtra, pt) ){
    #####: 4910:        pNew->mUnixTime = zipfileMtime(&pNew->cds);
        -: 4911:      }
        -: 4912:    }
        -: 4913:
    #####: 4914:    if( rc==SQLITE_OK ){
        -: 4915:      static const int szFix = ZIPFILE_LFH_FIXED_SZ;
        -: 4916:      ZipfileLFH lfh;
    #####: 4917:      if( pFile ){
    #####: 4918:        rc = zipfileReadData(pFile, aRead, szFix, pNew->cds.iOffset, pzErr);
        -: 4919:      }else{
    #####: 4920:        aRead = (u8*)&aBlob[pNew->cds.iOffset];
        -: 4921:      }
        -: 4922:
    #####: 4923:      rc = zipfileReadLFH(aRead, &lfh);
    #####: 4924:      if( rc==SQLITE_OK ){
    #####: 4925:        pNew->iDataOff =  pNew->cds.iOffset + ZIPFILE_LFH_FIXED_SZ;
    #####: 4926:        pNew->iDataOff += lfh.nFile + lfh.nExtra;
    #####: 4927:        if( aBlob && pNew->cds.szCompressed ){
    #####: 4928:          pNew->aData = &pNew->aExtra[nExtra];
    #####: 4929:          memcpy(pNew->aData, &aBlob[pNew->iDataOff], pNew->cds.szCompressed);
        -: 4930:        }
        -: 4931:      }else{
    #####: 4932:        *pzErr = sqlite3_mprintf("failed to read LFH at offset %d", 
    #####: 4933:            (int)pNew->cds.iOffset
        -: 4934:        );
        -: 4935:      }
        -: 4936:    }
        -: 4937:
    #####: 4938:    if( rc!=SQLITE_OK ){
    #####: 4939:      zipfileEntryFree(pNew);
        -: 4940:    }else{
    #####: 4941:      *ppEntry = pNew;
        -: 4942:    }
        -: 4943:  }
        -: 4944:
    #####: 4945:  return rc;
        -: 4946:}
        -: 4947:
        -: 4948:/*
        -: 4949:** Advance an ZipfileCsr to its next row of output.
        -: 4950:*/
    #####: 4951:static int zipfileNext(sqlite3_vtab_cursor *cur){
    #####: 4952:  ZipfileCsr *pCsr = (ZipfileCsr*)cur;
    #####: 4953:  int rc = SQLITE_OK;
        -: 4954:
    #####: 4955:  if( pCsr->pFile ){
    #####: 4956:    i64 iEof = pCsr->eocd.iOffset + pCsr->eocd.nSize;
    #####: 4957:    zipfileEntryFree(pCsr->pCurrent);
    #####: 4958:    pCsr->pCurrent = 0;
    #####: 4959:    if( pCsr->iNextOff>=iEof ){
    #####: 4960:      pCsr->bEof = 1;
        -: 4961:    }else{
    #####: 4962:      ZipfileEntry *p = 0;
    #####: 4963:      ZipfileTab *pTab = (ZipfileTab*)(cur->pVtab);
    #####: 4964:      rc = zipfileGetEntry(pTab, 0, 0, pCsr->pFile, pCsr->iNextOff, &p);
    #####: 4965:      if( rc==SQLITE_OK ){
    #####: 4966:        pCsr->iNextOff += ZIPFILE_CDS_FIXED_SZ;
    #####: 4967:        pCsr->iNextOff += (int)p->cds.nExtra + p->cds.nFile + p->cds.nComment;
        -: 4968:      }
    #####: 4969:      pCsr->pCurrent = p;
        -: 4970:    }
        -: 4971:  }else{
    #####: 4972:    if( !pCsr->bNoop ){
    #####: 4973:      pCsr->pCurrent = pCsr->pCurrent->pNext;
        -: 4974:    }
    #####: 4975:    if( pCsr->pCurrent==0 ){
    #####: 4976:      pCsr->bEof = 1;
        -: 4977:    }
        -: 4978:  }
        -: 4979:
    #####: 4980:  pCsr->bNoop = 0;
    #####: 4981:  return rc;
        -: 4982:}
        -: 4983:
    #####: 4984:static void zipfileFree(void *p) { 
    #####: 4985:  sqlite3_free(p); 
    #####: 4986:}
        -: 4987:
        -: 4988:/*
        -: 4989:** Buffer aIn (size nIn bytes) contains compressed data. Uncompressed, the
        -: 4990:** size is nOut bytes. This function uncompresses the data and sets the
        -: 4991:** return value in context pCtx to the result (a blob).
        -: 4992:**
        -: 4993:** If an error occurs, an error code is left in pCtx instead.
        -: 4994:*/
    #####: 4995:static void zipfileInflate(
        -: 4996:  sqlite3_context *pCtx,          /* Store result here */
        -: 4997:  const u8 *aIn,                  /* Compressed data */
        -: 4998:  int nIn,                        /* Size of buffer aIn[] in bytes */
        -: 4999:  int nOut                        /* Expected output size */
        -: 5000:){
    #####: 5001:  u8 *aRes = sqlite3_malloc(nOut);
    #####: 5002:  if( aRes==0 ){
    #####: 5003:    sqlite3_result_error_nomem(pCtx);
        -: 5004:  }else{
        -: 5005:    int err;
        -: 5006:    z_stream str;
    #####: 5007:    memset(&str, 0, sizeof(str));
        -: 5008:
    #####: 5009:    str.next_in = (Byte*)aIn;
    #####: 5010:    str.avail_in = nIn;
    #####: 5011:    str.next_out = (Byte*)aRes;
    #####: 5012:    str.avail_out = nOut;
        -: 5013:
    #####: 5014:    err = inflateInit2(&str, -15);
    #####: 5015:    if( err!=Z_OK ){
    #####: 5016:      zipfileCtxErrorMsg(pCtx, "inflateInit2() failed (%d)", err);
        -: 5017:    }else{
    #####: 5018:      err = inflate(&str, Z_NO_FLUSH);
    #####: 5019:      if( err!=Z_STREAM_END ){
    #####: 5020:        zipfileCtxErrorMsg(pCtx, "inflate() failed (%d)", err);
        -: 5021:      }else{
    #####: 5022:        sqlite3_result_blob(pCtx, aRes, nOut, zipfileFree);
    #####: 5023:        aRes = 0;
        -: 5024:      }
        -: 5025:    }
    #####: 5026:    sqlite3_free(aRes);
    #####: 5027:    inflateEnd(&str);
        -: 5028:  }
    #####: 5029:}
        -: 5030:
        -: 5031:/*
        -: 5032:** Buffer aIn (size nIn bytes) contains uncompressed data. This function
        -: 5033:** compresses it and sets (*ppOut) to point to a buffer containing the
        -: 5034:** compressed data. The caller is responsible for eventually calling
        -: 5035:** sqlite3_free() to release buffer (*ppOut). Before returning, (*pnOut) 
        -: 5036:** is set to the size of buffer (*ppOut) in bytes.
        -: 5037:**
        -: 5038:** If no error occurs, SQLITE_OK is returned. Otherwise, an SQLite error
        -: 5039:** code is returned and an error message left in virtual-table handle
        -: 5040:** pTab. The values of (*ppOut) and (*pnOut) are left unchanged in this
        -: 5041:** case.
        -: 5042:*/
    #####: 5043:static int zipfileDeflate(
        -: 5044:  const u8 *aIn, int nIn,         /* Input */
        -: 5045:  u8 **ppOut, int *pnOut,         /* Output */
        -: 5046:  char **pzErr                    /* OUT: Error message */
        -: 5047:){
    #####: 5048:  int nAlloc = (int)compressBound(nIn);
        -: 5049:  u8 *aOut;
    #####: 5050:  int rc = SQLITE_OK;
        -: 5051:
    #####: 5052:  aOut = (u8*)sqlite3_malloc(nAlloc);
    #####: 5053:  if( aOut==0 ){
    #####: 5054:    rc = SQLITE_NOMEM;
        -: 5055:  }else{
        -: 5056:    int res;
        -: 5057:    z_stream str;
    #####: 5058:    memset(&str, 0, sizeof(str));
    #####: 5059:    str.next_in = (Bytef*)aIn;
    #####: 5060:    str.avail_in = nIn;
    #####: 5061:    str.next_out = aOut;
    #####: 5062:    str.avail_out = nAlloc;
        -: 5063:
    #####: 5064:    deflateInit2(&str, 9, Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY);
    #####: 5065:    res = deflate(&str, Z_FINISH);
        -: 5066:
    #####: 5067:    if( res==Z_STREAM_END ){
    #####: 5068:      *ppOut = aOut;
    #####: 5069:      *pnOut = (int)str.total_out;
        -: 5070:    }else{
    #####: 5071:      sqlite3_free(aOut);
    #####: 5072:      *pzErr = sqlite3_mprintf("zipfile: deflate() error");
    #####: 5073:      rc = SQLITE_ERROR;
        -: 5074:    }
    #####: 5075:    deflateEnd(&str);
        -: 5076:  }
        -: 5077:
    #####: 5078:  return rc;
        -: 5079:}
        -: 5080:
        -: 5081:
        -: 5082:/*
        -: 5083:** Return values of columns for the row at which the series_cursor
        -: 5084:** is currently pointing.
        -: 5085:*/
    #####: 5086:static int zipfileColumn(
        -: 5087:  sqlite3_vtab_cursor *cur,   /* The cursor */
        -: 5088:  sqlite3_context *ctx,       /* First argument to sqlite3_result_...() */
        -: 5089:  int i                       /* Which column to return */
        -: 5090:){
    #####: 5091:  ZipfileCsr *pCsr = (ZipfileCsr*)cur;
    #####: 5092:  ZipfileCDS *pCDS = &pCsr->pCurrent->cds;
    #####: 5093:  int rc = SQLITE_OK;
    #####: 5094:  switch( i ){
    #####: 5095:    case 0:   /* name */
    #####: 5096:      sqlite3_result_text(ctx, pCDS->zFile, -1, SQLITE_TRANSIENT);
    #####: 5097:      break;
    #####: 5098:    case 1:   /* mode */
        -: 5099:      /* TODO: Whether or not the following is correct surely depends on
        -: 5100:      ** the platform on which the archive was created.  */
    #####: 5101:      sqlite3_result_int(ctx, pCDS->iExternalAttr >> 16);
    #####: 5102:      break;
    #####: 5103:    case 2: { /* mtime */
    #####: 5104:      sqlite3_result_int64(ctx, pCsr->pCurrent->mUnixTime);
    #####: 5105:      break;
        -: 5106:    }
    #####: 5107:    case 3: { /* sz */
    #####: 5108:      if( sqlite3_vtab_nochange(ctx)==0 ){
    #####: 5109:        sqlite3_result_int64(ctx, pCDS->szUncompressed);
        -: 5110:      }
    #####: 5111:      break;
        -: 5112:    }
    #####: 5113:    case 4:   /* rawdata */
    #####: 5114:      if( sqlite3_vtab_nochange(ctx) ) break;
        -: 5115:    case 5: { /* data */
    #####: 5116:      if( i==4 || pCDS->iCompression==0 || pCDS->iCompression==8 ){
    #####: 5117:        int sz = pCDS->szCompressed;
    #####: 5118:        int szFinal = pCDS->szUncompressed;
    #####: 5119:        if( szFinal>0 ){
        -: 5120:          u8 *aBuf;
    #####: 5121:          u8 *aFree = 0;
    #####: 5122:          if( pCsr->pCurrent->aData ){
    #####: 5123:            aBuf = pCsr->pCurrent->aData;
        -: 5124:          }else{
    #####: 5125:            aBuf = aFree = sqlite3_malloc(sz);
    #####: 5126:            if( aBuf==0 ){
    #####: 5127:              rc = SQLITE_NOMEM;
        -: 5128:            }else{
    #####: 5129:              FILE *pFile = pCsr->pFile;
    #####: 5130:              if( pFile==0 ){
    #####: 5131:                pFile = ((ZipfileTab*)(pCsr->base.pVtab))->pWriteFd;
        -: 5132:              }
    #####: 5133:              rc = zipfileReadData(pFile, aBuf, sz, pCsr->pCurrent->iDataOff,
    #####: 5134:                  &pCsr->base.pVtab->zErrMsg
        -: 5135:              );
        -: 5136:            }
        -: 5137:          }
    #####: 5138:          if( rc==SQLITE_OK ){
    #####: 5139:            if( i==5 && pCDS->iCompression ){
    #####: 5140:              zipfileInflate(ctx, aBuf, sz, szFinal);
        -: 5141:            }else{
    #####: 5142:              sqlite3_result_blob(ctx, aBuf, sz, SQLITE_TRANSIENT);
        -: 5143:            }
        -: 5144:          }
    #####: 5145:          sqlite3_free(aFree);
        -: 5146:        }else{
        -: 5147:          /* Figure out if this is a directory or a zero-sized file. Consider
        -: 5148:          ** it to be a directory either if the mode suggests so, or if
        -: 5149:          ** the final character in the name is '/'.  */
    #####: 5150:          u32 mode = pCDS->iExternalAttr >> 16;
    #####: 5151:          if( !(mode & S_IFDIR) && pCDS->zFile[pCDS->nFile-1]!='/' ){
    #####: 5152:            sqlite3_result_blob(ctx, "", 0, SQLITE_STATIC);
        -: 5153:          }
        -: 5154:        }
        -: 5155:      }
    #####: 5156:      break;
        -: 5157:    }
    #####: 5158:    case 6:   /* method */
    #####: 5159:      sqlite3_result_int(ctx, pCDS->iCompression);
    #####: 5160:      break;
    #####: 5161:    default:  /* z */
        -: 5162:      assert( i==7 );
    #####: 5163:      sqlite3_result_int64(ctx, pCsr->iId);
    #####: 5164:      break;
        -: 5165:  }
        -: 5166:
    #####: 5167:  return rc;
        -: 5168:}
        -: 5169:
        -: 5170:/*
        -: 5171:** Return TRUE if the cursor is at EOF.
        -: 5172:*/
    #####: 5173:static int zipfileEof(sqlite3_vtab_cursor *cur){
    #####: 5174:  ZipfileCsr *pCsr = (ZipfileCsr*)cur;
    #####: 5175:  return pCsr->bEof;
        -: 5176:}
        -: 5177:
        -: 5178:/*
        -: 5179:** If aBlob is not NULL, then it points to a buffer nBlob bytes in size
        -: 5180:** containing an entire zip archive image. Or, if aBlob is NULL, then pFile
        -: 5181:** is guaranteed to be a file-handle open on a zip file.
        -: 5182:**
        -: 5183:** This function attempts to locate the EOCD record within the zip archive
        -: 5184:** and populate *pEOCD with the results of decoding it. SQLITE_OK is
        -: 5185:** returned if successful. Otherwise, an SQLite error code is returned and
        -: 5186:** an English language error message may be left in virtual-table pTab.
        -: 5187:*/
    #####: 5188:static int zipfileReadEOCD(
        -: 5189:  ZipfileTab *pTab,               /* Return errors here */
        -: 5190:  const u8 *aBlob,                /* Pointer to in-memory file image */
        -: 5191:  int nBlob,                      /* Size of aBlob[] in bytes */
        -: 5192:  FILE *pFile,                    /* Read from this file if aBlob==0 */
        -: 5193:  ZipfileEOCD *pEOCD              /* Object to populate */
        -: 5194:){
    #####: 5195:  u8 *aRead = pTab->aBuffer;      /* Temporary buffer */
        -: 5196:  int nRead;                      /* Bytes to read from file */
    #####: 5197:  int rc = SQLITE_OK;
        -: 5198:
    #####: 5199:  if( aBlob==0 ){
        -: 5200:    i64 iOff;                     /* Offset to read from */
        -: 5201:    i64 szFile;                   /* Total size of file in bytes */
    #####: 5202:    fseek(pFile, 0, SEEK_END);
    #####: 5203:    szFile = (i64)ftell(pFile);
    #####: 5204:    if( szFile==0 ){
    #####: 5205:      memset(pEOCD, 0, sizeof(ZipfileEOCD));
    #####: 5206:      return SQLITE_OK;
        -: 5207:    }
    #####: 5208:    nRead = (int)(MIN(szFile, ZIPFILE_BUFFER_SIZE));
    #####: 5209:    iOff = szFile - nRead;
    #####: 5210:    rc = zipfileReadData(pFile, aRead, nRead, iOff, &pTab->base.zErrMsg);
        -: 5211:  }else{
    #####: 5212:    nRead = (int)(MIN(nBlob, ZIPFILE_BUFFER_SIZE));
    #####: 5213:    aRead = (u8*)&aBlob[nBlob-nRead];
        -: 5214:  }
        -: 5215:
    #####: 5216:  if( rc==SQLITE_OK ){
        -: 5217:    int i;
        -: 5218:
        -: 5219:    /* Scan backwards looking for the signature bytes */
    #####: 5220:    for(i=nRead-20; i>=0; i--){
    #####: 5221:      if( aRead[i]==0x50 && aRead[i+1]==0x4b 
    #####: 5222:       && aRead[i+2]==0x05 && aRead[i+3]==0x06 
        -: 5223:      ){
    #####: 5224:        break;
        -: 5225:      }
        -: 5226:    }
    #####: 5227:    if( i<0 ){
    #####: 5228:      pTab->base.zErrMsg = sqlite3_mprintf(
        -: 5229:          "cannot find end of central directory record"
        -: 5230:      );
    #####: 5231:      return SQLITE_ERROR;
        -: 5232:    }
        -: 5233:
    #####: 5234:    aRead += i+4;
    #####: 5235:    pEOCD->iDisk = zipfileRead16(aRead);
    #####: 5236:    pEOCD->iFirstDisk = zipfileRead16(aRead);
    #####: 5237:    pEOCD->nEntry = zipfileRead16(aRead);
    #####: 5238:    pEOCD->nEntryTotal = zipfileRead16(aRead);
    #####: 5239:    pEOCD->nSize = zipfileRead32(aRead);
    #####: 5240:    pEOCD->iOffset = zipfileRead32(aRead);
        -: 5241:  }
        -: 5242:
    #####: 5243:  return rc;
        -: 5244:}
        -: 5245:
        -: 5246:/*
        -: 5247:** Add object pNew to the linked list that begins at ZipfileTab.pFirstEntry 
        -: 5248:** and ends with pLastEntry. If argument pBefore is NULL, then pNew is added
        -: 5249:** to the end of the list. Otherwise, it is added to the list immediately
        -: 5250:** before pBefore (which is guaranteed to be a part of said list).
        -: 5251:*/
    #####: 5252:static void zipfileAddEntry(
        -: 5253:  ZipfileTab *pTab, 
        -: 5254:  ZipfileEntry *pBefore, 
        -: 5255:  ZipfileEntry *pNew
        -: 5256:){
        -: 5257:  assert( (pTab->pFirstEntry==0)==(pTab->pLastEntry==0) );
        -: 5258:  assert( pNew->pNext==0 );
    #####: 5259:  if( pBefore==0 ){
    #####: 5260:    if( pTab->pFirstEntry==0 ){
    #####: 5261:      pTab->pFirstEntry = pTab->pLastEntry = pNew;
        -: 5262:    }else{
        -: 5263:      assert( pTab->pLastEntry->pNext==0 );
    #####: 5264:      pTab->pLastEntry->pNext = pNew;
    #####: 5265:      pTab->pLastEntry = pNew;
        -: 5266:    }
        -: 5267:  }else{
        -: 5268:    ZipfileEntry **pp;
    #####: 5269:    for(pp=&pTab->pFirstEntry; *pp!=pBefore; pp=&((*pp)->pNext));
    #####: 5270:    pNew->pNext = pBefore;
    #####: 5271:    *pp = pNew;
        -: 5272:  }
    #####: 5273:}
        -: 5274:
    #####: 5275:static int zipfileLoadDirectory(ZipfileTab *pTab, const u8 *aBlob, int nBlob){
        -: 5276:  ZipfileEOCD eocd;
        -: 5277:  int rc;
        -: 5278:  int i;
        -: 5279:  i64 iOff;
        -: 5280:
    #####: 5281:  rc = zipfileReadEOCD(pTab, aBlob, nBlob, pTab->pWriteFd, &eocd);
    #####: 5282:  iOff = eocd.iOffset;
    #####: 5283:  for(i=0; rc==SQLITE_OK && i<eocd.nEntry; i++){
    #####: 5284:    ZipfileEntry *pNew = 0;
    #####: 5285:    rc = zipfileGetEntry(pTab, aBlob, nBlob, pTab->pWriteFd, iOff, &pNew);
        -: 5286:
    #####: 5287:    if( rc==SQLITE_OK ){
    #####: 5288:      zipfileAddEntry(pTab, 0, pNew);
    #####: 5289:      iOff += ZIPFILE_CDS_FIXED_SZ;
    #####: 5290:      iOff += (int)pNew->cds.nExtra + pNew->cds.nFile + pNew->cds.nComment;
        -: 5291:    }
        -: 5292:  }
    #####: 5293:  return rc;
        -: 5294:}
        -: 5295:
        -: 5296:/*
        -: 5297:** xFilter callback.
        -: 5298:*/
    #####: 5299:static int zipfileFilter(
        -: 5300:  sqlite3_vtab_cursor *cur, 
        -: 5301:  int idxNum, const char *idxStr,
        -: 5302:  int argc, sqlite3_value **argv
        -: 5303:){
    #####: 5304:  ZipfileTab *pTab = (ZipfileTab*)cur->pVtab;
    #####: 5305:  ZipfileCsr *pCsr = (ZipfileCsr*)cur;
    #####: 5306:  const char *zFile = 0;          /* Zip file to scan */
    #####: 5307:  int rc = SQLITE_OK;             /* Return Code */
    #####: 5308:  int bInMemory = 0;              /* True for an in-memory zipfile */
        -: 5309:
    #####: 5310:  zipfileResetCursor(pCsr);
        -: 5311:
    #####: 5312:  if( pTab->zFile ){
    #####: 5313:    zFile = pTab->zFile;
    #####: 5314:  }else if( idxNum==0 ){
    #####: 5315:    zipfileCursorErr(pCsr, "zipfile() function requires an argument");
    #####: 5316:    return SQLITE_ERROR;
    #####: 5317:  }else if( sqlite3_value_type(argv[0])==SQLITE_BLOB ){
    #####: 5318:    const u8 *aBlob = (const u8*)sqlite3_value_blob(argv[0]);
    #####: 5319:    int nBlob = sqlite3_value_bytes(argv[0]);
        -: 5320:    assert( pTab->pFirstEntry==0 );
    #####: 5321:    rc = zipfileLoadDirectory(pTab, aBlob, nBlob);
    #####: 5322:    pCsr->pFreeEntry = pTab->pFirstEntry;
    #####: 5323:    pTab->pFirstEntry = pTab->pLastEntry = 0;
    #####: 5324:    if( rc!=SQLITE_OK ) return rc;
    #####: 5325:    bInMemory = 1;
        -: 5326:  }else{
    #####: 5327:    zFile = (const char*)sqlite3_value_text(argv[0]);
        -: 5328:  }
        -: 5329:
    #####: 5330:  if( 0==pTab->pWriteFd && 0==bInMemory ){
    #####: 5331:    pCsr->pFile = fopen(zFile, "rb");
    #####: 5332:    if( pCsr->pFile==0 ){
    #####: 5333:      zipfileCursorErr(pCsr, "cannot open file: %s", zFile);
    #####: 5334:      rc = SQLITE_ERROR;
        -: 5335:    }else{
    #####: 5336:      rc = zipfileReadEOCD(pTab, 0, 0, pCsr->pFile, &pCsr->eocd);
    #####: 5337:      if( rc==SQLITE_OK ){
    #####: 5338:        if( pCsr->eocd.nEntry==0 ){
    #####: 5339:          pCsr->bEof = 1;
        -: 5340:        }else{
    #####: 5341:          pCsr->iNextOff = pCsr->eocd.iOffset;
    #####: 5342:          rc = zipfileNext(cur);
        -: 5343:        }
        -: 5344:      }
        -: 5345:    }
        -: 5346:  }else{
    #####: 5347:    pCsr->bNoop = 1;
    #####: 5348:    pCsr->pCurrent = pCsr->pFreeEntry ? pCsr->pFreeEntry : pTab->pFirstEntry;
    #####: 5349:    rc = zipfileNext(cur);
        -: 5350:  }
        -: 5351:
    #####: 5352:  return rc;
        -: 5353:}
        -: 5354:
        -: 5355:/*
        -: 5356:** xBestIndex callback.
        -: 5357:*/
    #####: 5358:static int zipfileBestIndex(
        -: 5359:  sqlite3_vtab *tab,
        -: 5360:  sqlite3_index_info *pIdxInfo
        -: 5361:){
        -: 5362:  int i;
    #####: 5363:  int idx = -1;
    #####: 5364:  int unusable = 0;
        -: 5365:
    #####: 5366:  for(i=0; i<pIdxInfo->nConstraint; i++){
    #####: 5367:    const struct sqlite3_index_constraint *pCons = &pIdxInfo->aConstraint[i];
    #####: 5368:    if( pCons->iColumn!=ZIPFILE_F_COLUMN_IDX ) continue;
    #####: 5369:    if( pCons->usable==0 ){
    #####: 5370:      unusable = 1;
    #####: 5371:    }else if( pCons->op==SQLITE_INDEX_CONSTRAINT_EQ ){
    #####: 5372:      idx = i;
        -: 5373:    }
        -: 5374:  }
    #####: 5375:  if( idx>=0 ){
    #####: 5376:    pIdxInfo->aConstraintUsage[idx].argvIndex = 1;
    #####: 5377:    pIdxInfo->aConstraintUsage[idx].omit = 1;
    #####: 5378:    pIdxInfo->estimatedCost = 1000.0;
    #####: 5379:    pIdxInfo->idxNum = 1;
    #####: 5380:  }else if( unusable ){
    #####: 5381:    return SQLITE_CONSTRAINT;
        -: 5382:  }
    #####: 5383:  return SQLITE_OK;
        -: 5384:}
        -: 5385:
    #####: 5386:static ZipfileEntry *zipfileNewEntry(const char *zPath){
        -: 5387:  ZipfileEntry *pNew;
    #####: 5388:  pNew = sqlite3_malloc(sizeof(ZipfileEntry));
    #####: 5389:  if( pNew ){
    #####: 5390:    memset(pNew, 0, sizeof(ZipfileEntry));
    #####: 5391:    pNew->cds.zFile = sqlite3_mprintf("%s", zPath);
    #####: 5392:    if( pNew->cds.zFile==0 ){
    #####: 5393:      sqlite3_free(pNew);
    #####: 5394:      pNew = 0;
        -: 5395:    }
        -: 5396:  }
    #####: 5397:  return pNew;
        -: 5398:}
        -: 5399:
    #####: 5400:static int zipfileSerializeLFH(ZipfileEntry *pEntry, u8 *aBuf){
    #####: 5401:  ZipfileCDS *pCds = &pEntry->cds;
    #####: 5402:  u8 *a = aBuf;
        -: 5403:
    #####: 5404:  pCds->nExtra = 9;
        -: 5405:
        -: 5406:  /* Write the LFH itself */
    #####: 5407:  zipfileWrite32(a, ZIPFILE_SIGNATURE_LFH);
    #####: 5408:  zipfileWrite16(a, pCds->iVersionExtract);
    #####: 5409:  zipfileWrite16(a, pCds->flags);
    #####: 5410:  zipfileWrite16(a, pCds->iCompression);
    #####: 5411:  zipfileWrite16(a, pCds->mTime);
    #####: 5412:  zipfileWrite16(a, pCds->mDate);
    #####: 5413:  zipfileWrite32(a, pCds->crc32);
    #####: 5414:  zipfileWrite32(a, pCds->szCompressed);
    #####: 5415:  zipfileWrite32(a, pCds->szUncompressed);
    #####: 5416:  zipfileWrite16(a, (u16)pCds->nFile);
    #####: 5417:  zipfileWrite16(a, pCds->nExtra);
        -: 5418:  assert( a==&aBuf[ZIPFILE_LFH_FIXED_SZ] );
        -: 5419:
        -: 5420:  /* Add the file name */
    #####: 5421:  memcpy(a, pCds->zFile, (int)pCds->nFile);
    #####: 5422:  a += (int)pCds->nFile;
        -: 5423:
        -: 5424:  /* The "extra" data */
    #####: 5425:  zipfileWrite16(a, ZIPFILE_EXTRA_TIMESTAMP);
    #####: 5426:  zipfileWrite16(a, 5);
    #####: 5427:  *a++ = 0x01;
    #####: 5428:  zipfileWrite32(a, pEntry->mUnixTime);
        -: 5429:
    #####: 5430:  return a-aBuf;
        -: 5431:}
        -: 5432:
    #####: 5433:static int zipfileAppendEntry(
        -: 5434:  ZipfileTab *pTab,
        -: 5435:  ZipfileEntry *pEntry,
        -: 5436:  const u8 *pData,
        -: 5437:  int nData
        -: 5438:){
    #####: 5439:  u8 *aBuf = pTab->aBuffer;
        -: 5440:  int nBuf;
        -: 5441:  int rc;
        -: 5442:
    #####: 5443:  nBuf = zipfileSerializeLFH(pEntry, aBuf);
    #####: 5444:  rc = zipfileAppendData(pTab, aBuf, nBuf);
    #####: 5445:  if( rc==SQLITE_OK ){
    #####: 5446:    pEntry->iDataOff = pTab->szCurrent;
    #####: 5447:    rc = zipfileAppendData(pTab, pData, nData);
        -: 5448:  }
        -: 5449:
    #####: 5450:  return rc;
        -: 5451:}
        -: 5452:
    #####: 5453:static int zipfileGetMode(
        -: 5454:  sqlite3_value *pVal, 
        -: 5455:  int bIsDir,                     /* If true, default to directory */
        -: 5456:  u32 *pMode,                     /* OUT: Mode value */
        -: 5457:  char **pzErr                    /* OUT: Error message */
        -: 5458:){
    #####: 5459:  const char *z = (const char*)sqlite3_value_text(pVal);
    #####: 5460:  u32 mode = 0;
    #####: 5461:  if( z==0 ){
    #####: 5462:    mode = (bIsDir ? (S_IFDIR + 0755) : (S_IFREG + 0644));
    #####: 5463:  }else if( z[0]>='0' && z[0]<='9' ){
    #####: 5464:    mode = (unsigned int)sqlite3_value_int(pVal);
        -: 5465:  }else{
    #####: 5466:    const char zTemplate[11] = "-rwxrwxrwx";
        -: 5467:    int i;
    #####: 5468:    if( strlen(z)!=10 ) goto parse_error;
    #####: 5469:    switch( z[0] ){
    #####: 5470:      case '-': mode |= S_IFREG; break;
    #####: 5471:      case 'd': mode |= S_IFDIR; break;
    #####: 5472:      case 'l': mode |= S_IFLNK; break;
    #####: 5473:      default: goto parse_error;
        -: 5474:    }
    #####: 5475:    for(i=1; i<10; i++){
    #####: 5476:      if( z[i]==zTemplate[i] ) mode |= 1 << (9-i);
    #####: 5477:      else if( z[i]!='-' ) goto parse_error;
        -: 5478:    }
        -: 5479:  }
    #####: 5480:  if( ((mode & S_IFDIR)==0)==bIsDir ){
        -: 5481:    /* The "mode" attribute is a directory, but data has been specified.
        -: 5482:    ** Or vice-versa - no data but "mode" is a file or symlink.  */
    #####: 5483:    *pzErr = sqlite3_mprintf("zipfile: mode does not match data");
    #####: 5484:    return SQLITE_CONSTRAINT;
        -: 5485:  }
    #####: 5486:  *pMode = mode;
    #####: 5487:  return SQLITE_OK;
        -: 5488:
    #####: 5489: parse_error:
    #####: 5490:  *pzErr = sqlite3_mprintf("zipfile: parse error in mode: %s", z);
    #####: 5491:  return SQLITE_ERROR;
        -: 5492:}
        -: 5493:
        -: 5494:/*
        -: 5495:** Both (const char*) arguments point to nul-terminated strings. Argument
        -: 5496:** nB is the value of strlen(zB). This function returns 0 if the strings are
        -: 5497:** identical, ignoring any trailing '/' character in either path.  */
    #####: 5498:static int zipfileComparePath(const char *zA, const char *zB, int nB){
    #####: 5499:  int nA = (int)strlen(zA);
    #####: 5500:  if( zA[nA-1]=='/' ) nA--;
    #####: 5501:  if( zB[nB-1]=='/' ) nB--;
    #####: 5502:  if( nA==nB && memcmp(zA, zB, nA)==0 ) return 0;
    #####: 5503:  return 1;
        -: 5504:}
        -: 5505:
    #####: 5506:static int zipfileBegin(sqlite3_vtab *pVtab){
    #####: 5507:  ZipfileTab *pTab = (ZipfileTab*)pVtab;
    #####: 5508:  int rc = SQLITE_OK;
        -: 5509:
        -: 5510:  assert( pTab->pWriteFd==0 );
        -: 5511:
        -: 5512:  /* Open a write fd on the file. Also load the entire central directory
        -: 5513:  ** structure into memory. During the transaction any new file data is 
        -: 5514:  ** appended to the archive file, but the central directory is accumulated
        -: 5515:  ** in main-memory until the transaction is committed.  */
    #####: 5516:  pTab->pWriteFd = fopen(pTab->zFile, "ab+");
    #####: 5517:  if( pTab->pWriteFd==0 ){
    #####: 5518:    pTab->base.zErrMsg = sqlite3_mprintf(
        -: 5519:        "zipfile: failed to open file %s for writing", pTab->zFile
        -: 5520:        );
    #####: 5521:    rc = SQLITE_ERROR;
        -: 5522:  }else{
    #####: 5523:    fseek(pTab->pWriteFd, 0, SEEK_END);
    #####: 5524:    pTab->szCurrent = pTab->szOrig = (i64)ftell(pTab->pWriteFd);
    #####: 5525:    rc = zipfileLoadDirectory(pTab, 0, 0);
        -: 5526:  }
        -: 5527:
    #####: 5528:  if( rc!=SQLITE_OK ){
    #####: 5529:    zipfileCleanupTransaction(pTab);
        -: 5530:  }
        -: 5531:
    #####: 5532:  return rc;
        -: 5533:}
        -: 5534:
        -: 5535:/*
        -: 5536:** Return the current time as a 32-bit timestamp in UNIX epoch format (like
        -: 5537:** time(2)).
        -: 5538:*/
    #####: 5539:static u32 zipfileTime(void){
    #####: 5540:  sqlite3_vfs *pVfs = sqlite3_vfs_find(0);
        -: 5541:  u32 ret;
    #####: 5542:  if( pVfs->iVersion>=2 && pVfs->xCurrentTimeInt64 ){
        -: 5543:    i64 ms;
    #####: 5544:    pVfs->xCurrentTimeInt64(pVfs, &ms);
    #####: 5545:    ret = (u32)((ms/1000) - ((i64)24405875 * 8640));
        -: 5546:  }else{
        -: 5547:    double day;
    #####: 5548:    pVfs->xCurrentTime(pVfs, &day);
    #####: 5549:    ret = (u32)((day - 2440587.5) * 86400);
        -: 5550:  }
    #####: 5551:  return ret;
        -: 5552:}
        -: 5553:
        -: 5554:/*
        -: 5555:** Return a 32-bit timestamp in UNIX epoch format.
        -: 5556:**
        -: 5557:** If the value passed as the only argument is either NULL or an SQL NULL,
        -: 5558:** return the current time. Otherwise, return the value stored in (*pVal)
        -: 5559:** cast to a 32-bit unsigned integer.
        -: 5560:*/
    #####: 5561:static u32 zipfileGetTime(sqlite3_value *pVal){
    #####: 5562:  if( pVal==0 || sqlite3_value_type(pVal)==SQLITE_NULL ){
    #####: 5563:    return zipfileTime();
        -: 5564:  }
    #####: 5565:  return (u32)sqlite3_value_int64(pVal);
        -: 5566:}
        -: 5567:
        -: 5568:/*
        -: 5569:** Unless it is NULL, entry pOld is currently part of the pTab->pFirstEntry
        -: 5570:** linked list.  Remove it from the list and free the object.
        -: 5571:*/
    #####: 5572:static void zipfileRemoveEntryFromList(ZipfileTab *pTab, ZipfileEntry *pOld){
    #####: 5573:  if( pOld ){
        -: 5574:    ZipfileEntry **pp;
    #####: 5575:    for(pp=&pTab->pFirstEntry; (*pp)!=pOld; pp=&((*pp)->pNext));
    #####: 5576:    *pp = (*pp)->pNext;
    #####: 5577:    zipfileEntryFree(pOld);
        -: 5578:  }
    #####: 5579:}
        -: 5580:
        -: 5581:/*
        -: 5582:** xUpdate method.
        -: 5583:*/
    #####: 5584:static int zipfileUpdate(
        -: 5585:  sqlite3_vtab *pVtab, 
        -: 5586:  int nVal, 
        -: 5587:  sqlite3_value **apVal, 
        -: 5588:  sqlite_int64 *pRowid
        -: 5589:){
    #####: 5590:  ZipfileTab *pTab = (ZipfileTab*)pVtab;
    #####: 5591:  int rc = SQLITE_OK;             /* Return Code */
    #####: 5592:  ZipfileEntry *pNew = 0;         /* New in-memory CDS entry */
        -: 5593:
    #####: 5594:  u32 mode = 0;                   /* Mode for new entry */
    #####: 5595:  u32 mTime = 0;                  /* Modification time for new entry */
    #####: 5596:  i64 sz = 0;                     /* Uncompressed size */
    #####: 5597:  const char *zPath = 0;          /* Path for new entry */
    #####: 5598:  int nPath = 0;                  /* strlen(zPath) */
    #####: 5599:  const u8 *pData = 0;            /* Pointer to buffer containing content */
    #####: 5600:  int nData = 0;                  /* Size of pData buffer in bytes */
    #####: 5601:  int iMethod = 0;                /* Compression method for new entry */
    #####: 5602:  u8 *pFree = 0;                  /* Free this */
    #####: 5603:  char *zFree = 0;                /* Also free this */
    #####: 5604:  ZipfileEntry *pOld = 0;
    #####: 5605:  ZipfileEntry *pOld2 = 0;
    #####: 5606:  int bUpdate = 0;                /* True for an update that modifies "name" */
    #####: 5607:  int bIsDir = 0;
    #####: 5608:  u32 iCrc32 = 0;
        -: 5609:
    #####: 5610:  if( pTab->pWriteFd==0 ){
    #####: 5611:    rc = zipfileBegin(pVtab);
    #####: 5612:    if( rc!=SQLITE_OK ) return rc;
        -: 5613:  }
        -: 5614:
        -: 5615:  /* If this is a DELETE or UPDATE, find the archive entry to delete. */
    #####: 5616:  if( sqlite3_value_type(apVal[0])!=SQLITE_NULL ){
    #####: 5617:    const char *zDelete = (const char*)sqlite3_value_text(apVal[0]);
    #####: 5618:    int nDelete = (int)strlen(zDelete);
    #####: 5619:    if( nVal>1 ){
    #####: 5620:      const char *zUpdate = (const char*)sqlite3_value_text(apVal[1]);
    #####: 5621:      if( zUpdate && zipfileComparePath(zUpdate, zDelete, nDelete)!=0 ){
    #####: 5622:        bUpdate = 1;
        -: 5623:      }
        -: 5624:    }
    #####: 5625:    for(pOld=pTab->pFirstEntry; 1; pOld=pOld->pNext){
    #####: 5626:      if( zipfileComparePath(pOld->cds.zFile, zDelete, nDelete)==0 ){
    #####: 5627:        break;
        -: 5628:      }
        -: 5629:      assert( pOld->pNext );
        -: 5630:    }
        -: 5631:  }
        -: 5632:
    #####: 5633:  if( nVal>1 ){
        -: 5634:    /* Check that "sz" and "rawdata" are both NULL: */
    #####: 5635:    if( sqlite3_value_type(apVal[5])!=SQLITE_NULL ){
    #####: 5636:      zipfileTableErr(pTab, "sz must be NULL");
    #####: 5637:      rc = SQLITE_CONSTRAINT;
        -: 5638:    }
    #####: 5639:    if( sqlite3_value_type(apVal[6])!=SQLITE_NULL ){
    #####: 5640:      zipfileTableErr(pTab, "rawdata must be NULL"); 
    #####: 5641:      rc = SQLITE_CONSTRAINT;
        -: 5642:    }
        -: 5643:
    #####: 5644:    if( rc==SQLITE_OK ){
    #####: 5645:      if( sqlite3_value_type(apVal[7])==SQLITE_NULL ){
        -: 5646:        /* data=NULL. A directory */
    #####: 5647:        bIsDir = 1;
        -: 5648:      }else{
        -: 5649:        /* Value specified for "data", and possibly "method". This must be
        -: 5650:        ** a regular file or a symlink. */
    #####: 5651:        const u8 *aIn = sqlite3_value_blob(apVal[7]);
    #####: 5652:        int nIn = sqlite3_value_bytes(apVal[7]);
    #####: 5653:        int bAuto = sqlite3_value_type(apVal[8])==SQLITE_NULL;
        -: 5654:
    #####: 5655:        iMethod = sqlite3_value_int(apVal[8]);
    #####: 5656:        sz = nIn;
    #####: 5657:        pData = aIn;
    #####: 5658:        nData = nIn;
    #####: 5659:        if( iMethod!=0 && iMethod!=8 ){
    #####: 5660:          zipfileTableErr(pTab, "unknown compression method: %d", iMethod);
    #####: 5661:          rc = SQLITE_CONSTRAINT;
        -: 5662:        }else{
    #####: 5663:          if( bAuto || iMethod ){
        -: 5664:            int nCmp;
    #####: 5665:            rc = zipfileDeflate(aIn, nIn, &pFree, &nCmp, &pTab->base.zErrMsg);
    #####: 5666:            if( rc==SQLITE_OK ){
    #####: 5667:              if( iMethod || nCmp<nIn ){
    #####: 5668:                iMethod = 8;
    #####: 5669:                pData = pFree;
    #####: 5670:                nData = nCmp;
        -: 5671:              }
        -: 5672:            }
        -: 5673:          }
    #####: 5674:          iCrc32 = crc32(0, aIn, nIn);
        -: 5675:        }
        -: 5676:      }
        -: 5677:    }
        -: 5678:
    #####: 5679:    if( rc==SQLITE_OK ){
    #####: 5680:      rc = zipfileGetMode(apVal[3], bIsDir, &mode, &pTab->base.zErrMsg);
        -: 5681:    }
        -: 5682:
    #####: 5683:    if( rc==SQLITE_OK ){
    #####: 5684:      zPath = (const char*)sqlite3_value_text(apVal[2]);
    #####: 5685:      nPath = (int)strlen(zPath);
    #####: 5686:      mTime = zipfileGetTime(apVal[4]);
        -: 5687:    }
        -: 5688:
    #####: 5689:    if( rc==SQLITE_OK && bIsDir ){
        -: 5690:      /* For a directory, check that the last character in the path is a
        -: 5691:      ** '/'. This appears to be required for compatibility with info-zip
        -: 5692:      ** (the unzip command on unix). It does not create directories
        -: 5693:      ** otherwise.  */
    #####: 5694:      if( zPath[nPath-1]!='/' ){
    #####: 5695:        zFree = sqlite3_mprintf("%s/", zPath);
    #####: 5696:        if( zFree==0 ){ rc = SQLITE_NOMEM; }
    #####: 5697:        zPath = (const char*)zFree;
    #####: 5698:        nPath++;
        -: 5699:      }
        -: 5700:    }
        -: 5701:
        -: 5702:    /* Check that we're not inserting a duplicate entry -OR- updating an
        -: 5703:    ** entry with a path, thereby making it into a duplicate. */
    #####: 5704:    if( (pOld==0 || bUpdate) && rc==SQLITE_OK ){
        -: 5705:      ZipfileEntry *p;
    #####: 5706:      for(p=pTab->pFirstEntry; p; p=p->pNext){
    #####: 5707:        if( zipfileComparePath(p->cds.zFile, zPath, nPath)==0 ){
    #####: 5708:          switch( sqlite3_vtab_on_conflict(pTab->db) ){
    #####: 5709:            case SQLITE_IGNORE: {
    #####: 5710:              goto zipfile_update_done;
        -: 5711:            }
    #####: 5712:            case SQLITE_REPLACE: {
    #####: 5713:              pOld2 = p;
    #####: 5714:              break;
        -: 5715:            }
    #####: 5716:            default: {
    #####: 5717:              zipfileTableErr(pTab, "duplicate name: \"%s\"", zPath);
    #####: 5718:              rc = SQLITE_CONSTRAINT;
    #####: 5719:              break;
        -: 5720:            }
        -: 5721:          }
    #####: 5722:          break;
        -: 5723:        }
        -: 5724:      }
        -: 5725:    }
        -: 5726:
    #####: 5727:    if( rc==SQLITE_OK ){
        -: 5728:      /* Create the new CDS record. */
    #####: 5729:      pNew = zipfileNewEntry(zPath);
    #####: 5730:      if( pNew==0 ){
    #####: 5731:        rc = SQLITE_NOMEM;
        -: 5732:      }else{
    #####: 5733:        pNew->cds.iVersionMadeBy = ZIPFILE_NEWENTRY_MADEBY;
    #####: 5734:        pNew->cds.iVersionExtract = ZIPFILE_NEWENTRY_REQUIRED;
    #####: 5735:        pNew->cds.flags = ZIPFILE_NEWENTRY_FLAGS;
    #####: 5736:        pNew->cds.iCompression = (u16)iMethod;
    #####: 5737:        zipfileMtimeToDos(&pNew->cds, mTime);
    #####: 5738:        pNew->cds.crc32 = iCrc32;
    #####: 5739:        pNew->cds.szCompressed = nData;
    #####: 5740:        pNew->cds.szUncompressed = (u32)sz;
    #####: 5741:        pNew->cds.iExternalAttr = (mode<<16);
    #####: 5742:        pNew->cds.iOffset = (u32)pTab->szCurrent;
    #####: 5743:        pNew->cds.nFile = (u16)nPath;
    #####: 5744:        pNew->mUnixTime = (u32)mTime;
    #####: 5745:        rc = zipfileAppendEntry(pTab, pNew, pData, nData);
    #####: 5746:        zipfileAddEntry(pTab, pOld, pNew);
        -: 5747:      }
        -: 5748:    }
        -: 5749:  }
        -: 5750:
    #####: 5751:  if( rc==SQLITE_OK && (pOld || pOld2) ){
        -: 5752:    ZipfileCsr *pCsr;
    #####: 5753:    for(pCsr=pTab->pCsrList; pCsr; pCsr=pCsr->pCsrNext){
    #####: 5754:      if( pCsr->pCurrent && (pCsr->pCurrent==pOld || pCsr->pCurrent==pOld2) ){
    #####: 5755:        pCsr->pCurrent = pCsr->pCurrent->pNext;
    #####: 5756:        pCsr->bNoop = 1;
        -: 5757:      }
        -: 5758:    }
        -: 5759:
    #####: 5760:    zipfileRemoveEntryFromList(pTab, pOld);
    #####: 5761:    zipfileRemoveEntryFromList(pTab, pOld2);
        -: 5762:  }
        -: 5763:
    #####: 5764:zipfile_update_done:
    #####: 5765:  sqlite3_free(pFree);
    #####: 5766:  sqlite3_free(zFree);
    #####: 5767:  return rc;
        -: 5768:}
        -: 5769:
    #####: 5770:static int zipfileSerializeEOCD(ZipfileEOCD *p, u8 *aBuf){
    #####: 5771:  u8 *a = aBuf;
    #####: 5772:  zipfileWrite32(a, ZIPFILE_SIGNATURE_EOCD);
    #####: 5773:  zipfileWrite16(a, p->iDisk);
    #####: 5774:  zipfileWrite16(a, p->iFirstDisk);
    #####: 5775:  zipfileWrite16(a, p->nEntry);
    #####: 5776:  zipfileWrite16(a, p->nEntryTotal);
    #####: 5777:  zipfileWrite32(a, p->nSize);
    #####: 5778:  zipfileWrite32(a, p->iOffset);
    #####: 5779:  zipfileWrite16(a, 0);        /* Size of trailing comment in bytes*/
        -: 5780:
    #####: 5781:  return a-aBuf;
        -: 5782:}
        -: 5783:
    #####: 5784:static int zipfileAppendEOCD(ZipfileTab *pTab, ZipfileEOCD *p){
    #####: 5785:  int nBuf = zipfileSerializeEOCD(p, pTab->aBuffer);
        -: 5786:  assert( nBuf==ZIPFILE_EOCD_FIXED_SZ );
    #####: 5787:  return zipfileAppendData(pTab, pTab->aBuffer, nBuf);
        -: 5788:}
        -: 5789:
        -: 5790:/*
        -: 5791:** Serialize the CDS structure into buffer aBuf[]. Return the number
        -: 5792:** of bytes written.
        -: 5793:*/
    #####: 5794:static int zipfileSerializeCDS(ZipfileEntry *pEntry, u8 *aBuf){
    #####: 5795:  u8 *a = aBuf;
    #####: 5796:  ZipfileCDS *pCDS = &pEntry->cds;
        -: 5797:
    #####: 5798:  if( pEntry->aExtra==0 ){
    #####: 5799:    pCDS->nExtra = 9;
        -: 5800:  }
        -: 5801:
    #####: 5802:  zipfileWrite32(a, ZIPFILE_SIGNATURE_CDS);
    #####: 5803:  zipfileWrite16(a, pCDS->iVersionMadeBy);
    #####: 5804:  zipfileWrite16(a, pCDS->iVersionExtract);
    #####: 5805:  zipfileWrite16(a, pCDS->flags);
    #####: 5806:  zipfileWrite16(a, pCDS->iCompression);
    #####: 5807:  zipfileWrite16(a, pCDS->mTime);
    #####: 5808:  zipfileWrite16(a, pCDS->mDate);
    #####: 5809:  zipfileWrite32(a, pCDS->crc32);
    #####: 5810:  zipfileWrite32(a, pCDS->szCompressed);
    #####: 5811:  zipfileWrite32(a, pCDS->szUncompressed);
        -: 5812:  assert( a==&aBuf[ZIPFILE_CDS_NFILE_OFF] );
    #####: 5813:  zipfileWrite16(a, pCDS->nFile);
    #####: 5814:  zipfileWrite16(a, pCDS->nExtra);
    #####: 5815:  zipfileWrite16(a, pCDS->nComment);
    #####: 5816:  zipfileWrite16(a, pCDS->iDiskStart);
    #####: 5817:  zipfileWrite16(a, pCDS->iInternalAttr);
    #####: 5818:  zipfileWrite32(a, pCDS->iExternalAttr);
    #####: 5819:  zipfileWrite32(a, pCDS->iOffset);
        -: 5820:
    #####: 5821:  memcpy(a, pCDS->zFile, pCDS->nFile);
    #####: 5822:  a += pCDS->nFile;
        -: 5823:
    #####: 5824:  if( pEntry->aExtra ){
    #####: 5825:    int n = (int)pCDS->nExtra + (int)pCDS->nComment;
    #####: 5826:    memcpy(a, pEntry->aExtra, n);
    #####: 5827:    a += n;
        -: 5828:  }else{
        -: 5829:    assert( pCDS->nExtra==9 );
    #####: 5830:    zipfileWrite16(a, ZIPFILE_EXTRA_TIMESTAMP);
    #####: 5831:    zipfileWrite16(a, 5);
    #####: 5832:    *a++ = 0x01;
    #####: 5833:    zipfileWrite32(a, pEntry->mUnixTime);
        -: 5834:  }
        -: 5835:
    #####: 5836:  return a-aBuf;
        -: 5837:}
        -: 5838:
    #####: 5839:static int zipfileCommit(sqlite3_vtab *pVtab){
    #####: 5840:  ZipfileTab *pTab = (ZipfileTab*)pVtab;
    #####: 5841:  int rc = SQLITE_OK;
    #####: 5842:  if( pTab->pWriteFd ){
    #####: 5843:    i64 iOffset = pTab->szCurrent;
        -: 5844:    ZipfileEntry *p;
        -: 5845:    ZipfileEOCD eocd;
    #####: 5846:    int nEntry = 0;
        -: 5847:
        -: 5848:    /* Write out all entries */
    #####: 5849:    for(p=pTab->pFirstEntry; rc==SQLITE_OK && p; p=p->pNext){
    #####: 5850:      int n = zipfileSerializeCDS(p, pTab->aBuffer);
    #####: 5851:      rc = zipfileAppendData(pTab, pTab->aBuffer, n);
    #####: 5852:      nEntry++;
        -: 5853:    }
        -: 5854:
        -: 5855:    /* Write out the EOCD record */
    #####: 5856:    eocd.iDisk = 0;
    #####: 5857:    eocd.iFirstDisk = 0;
    #####: 5858:    eocd.nEntry = (u16)nEntry;
    #####: 5859:    eocd.nEntryTotal = (u16)nEntry;
    #####: 5860:    eocd.nSize = (u32)(pTab->szCurrent - iOffset);
    #####: 5861:    eocd.iOffset = (u32)iOffset;
    #####: 5862:    rc = zipfileAppendEOCD(pTab, &eocd);
        -: 5863:
    #####: 5864:    zipfileCleanupTransaction(pTab);
        -: 5865:  }
    #####: 5866:  return rc;
        -: 5867:}
        -: 5868:
    #####: 5869:static int zipfileRollback(sqlite3_vtab *pVtab){
    #####: 5870:  return zipfileCommit(pVtab);
        -: 5871:}
        -: 5872:
    #####: 5873:static ZipfileCsr *zipfileFindCursor(ZipfileTab *pTab, i64 iId){
        -: 5874:  ZipfileCsr *pCsr;
    #####: 5875:  for(pCsr=pTab->pCsrList; pCsr; pCsr=pCsr->pCsrNext){
    #####: 5876:    if( iId==pCsr->iId ) break;
        -: 5877:  }
    #####: 5878:  return pCsr;
        -: 5879:}
        -: 5880:
    #####: 5881:static void zipfileFunctionCds(
        -: 5882:  sqlite3_context *context,
        -: 5883:  int argc,
        -: 5884:  sqlite3_value **argv
        -: 5885:){
        -: 5886:  ZipfileCsr *pCsr;
    #####: 5887:  ZipfileTab *pTab = (ZipfileTab*)sqlite3_user_data(context);
        -: 5888:  assert( argc>0 );
        -: 5889:
    #####: 5890:  pCsr = zipfileFindCursor(pTab, sqlite3_value_int64(argv[0]));
    #####: 5891:  if( pCsr ){
    #####: 5892:    ZipfileCDS *p = &pCsr->pCurrent->cds;
    #####: 5893:    char *zRes = sqlite3_mprintf("{"
        -: 5894:        "\"version-made-by\" : %u, "
        -: 5895:        "\"version-to-extract\" : %u, "
        -: 5896:        "\"flags\" : %u, "
        -: 5897:        "\"compression\" : %u, "
        -: 5898:        "\"time\" : %u, "
        -: 5899:        "\"date\" : %u, "
        -: 5900:        "\"crc32\" : %u, "
        -: 5901:        "\"compressed-size\" : %u, "
        -: 5902:        "\"uncompressed-size\" : %u, "
        -: 5903:        "\"file-name-length\" : %u, "
        -: 5904:        "\"extra-field-length\" : %u, "
        -: 5905:        "\"file-comment-length\" : %u, "
        -: 5906:        "\"disk-number-start\" : %u, "
        -: 5907:        "\"internal-attr\" : %u, "
        -: 5908:        "\"external-attr\" : %u, "
        -: 5909:        "\"offset\" : %u }",
    #####: 5910:        (u32)p->iVersionMadeBy, (u32)p->iVersionExtract,
    #####: 5911:        (u32)p->flags, (u32)p->iCompression,
    #####: 5912:        (u32)p->mTime, (u32)p->mDate,
    #####: 5913:        (u32)p->crc32, (u32)p->szCompressed,
    #####: 5914:        (u32)p->szUncompressed, (u32)p->nFile,
    #####: 5915:        (u32)p->nExtra, (u32)p->nComment,
    #####: 5916:        (u32)p->iDiskStart, (u32)p->iInternalAttr,
    #####: 5917:        (u32)p->iExternalAttr, (u32)p->iOffset
        -: 5918:    );
        -: 5919:
    #####: 5920:    if( zRes==0 ){
    #####: 5921:      sqlite3_result_error_nomem(context);
        -: 5922:    }else{
    #####: 5923:      sqlite3_result_text(context, zRes, -1, SQLITE_TRANSIENT);
    #####: 5924:      sqlite3_free(zRes);
        -: 5925:    }
        -: 5926:  }
    #####: 5927:}
        -: 5928:
        -: 5929:/*
        -: 5930:** xFindFunction method.
        -: 5931:*/
    #####: 5932:static int zipfileFindFunction(
        -: 5933:  sqlite3_vtab *pVtab,            /* Virtual table handle */
        -: 5934:  int nArg,                       /* Number of SQL function arguments */
        -: 5935:  const char *zName,              /* Name of SQL function */
        -: 5936:  void (**pxFunc)(sqlite3_context*,int,sqlite3_value**), /* OUT: Result */
        -: 5937:  void **ppArg                    /* OUT: User data for *pxFunc */
        -: 5938:){
    #####: 5939:  if( sqlite3_stricmp("zipfile_cds", zName)==0 ){
    #####: 5940:    *pxFunc = zipfileFunctionCds;
    #####: 5941:    *ppArg = (void*)pVtab;
    #####: 5942:    return 1;
        -: 5943:  }
    #####: 5944:  return 0;
        -: 5945:}
        -: 5946:
        -: 5947:typedef struct ZipfileBuffer ZipfileBuffer;
        -: 5948:struct ZipfileBuffer {
        -: 5949:  u8 *a;                          /* Pointer to buffer */
        -: 5950:  int n;                          /* Size of buffer in bytes */
        -: 5951:  int nAlloc;                     /* Byte allocated at a[] */
        -: 5952:};
        -: 5953:
        -: 5954:typedef struct ZipfileCtx ZipfileCtx;
        -: 5955:struct ZipfileCtx {
        -: 5956:  int nEntry;
        -: 5957:  ZipfileBuffer body;
        -: 5958:  ZipfileBuffer cds;
        -: 5959:};
        -: 5960:
    #####: 5961:static int zipfileBufferGrow(ZipfileBuffer *pBuf, int nByte){
    #####: 5962:  if( pBuf->n+nByte>pBuf->nAlloc ){
        -: 5963:    u8 *aNew;
    #####: 5964:    int nNew = pBuf->n ? pBuf->n*2 : 512;
    #####: 5965:    int nReq = pBuf->n + nByte;
        -: 5966:
    #####: 5967:    while( nNew<nReq ) nNew = nNew*2;
    #####: 5968:    aNew = sqlite3_realloc(pBuf->a, nNew);
    #####: 5969:    if( aNew==0 ) return SQLITE_NOMEM;
    #####: 5970:    pBuf->a = aNew;
    #####: 5971:    pBuf->nAlloc = nNew;
        -: 5972:  }
    #####: 5973:  return SQLITE_OK;
        -: 5974:}
        -: 5975:
        -: 5976:/*
        -: 5977:** xStep() callback for the zipfile() aggregate. This can be called in
        -: 5978:** any of the following ways:
        -: 5979:**
        -: 5980:**   SELECT zipfile(name,data) ...
        -: 5981:**   SELECT zipfile(name,mode,mtime,data) ...
        -: 5982:**   SELECT zipfile(name,mode,mtime,data,method) ...
        -: 5983:*/
    #####: 5984:void zipfileStep(sqlite3_context *pCtx, int nVal, sqlite3_value **apVal){
        -: 5985:  ZipfileCtx *p;                  /* Aggregate function context */
        -: 5986:  ZipfileEntry e;                 /* New entry to add to zip archive */
        -: 5987:
    #####: 5988:  sqlite3_value *pName = 0;
    #####: 5989:  sqlite3_value *pMode = 0;
    #####: 5990:  sqlite3_value *pMtime = 0;
    #####: 5991:  sqlite3_value *pData = 0;
    #####: 5992:  sqlite3_value *pMethod = 0;
        -: 5993:
    #####: 5994:  int bIsDir = 0;
        -: 5995:  u32 mode;
    #####: 5996:  int rc = SQLITE_OK;
    #####: 5997:  char *zErr = 0;
        -: 5998:
    #####: 5999:  int iMethod = -1;               /* Compression method to use (0 or 8) */
        -: 6000:
    #####: 6001:  const u8 *aData = 0;            /* Possibly compressed data for new entry */
    #####: 6002:  int nData = 0;                  /* Size of aData[] in bytes */
    #####: 6003:  int szUncompressed = 0;         /* Size of data before compression */
    #####: 6004:  u8 *aFree = 0;                  /* Free this before returning */
    #####: 6005:  u32 iCrc32 = 0;                 /* crc32 of uncompressed data */
        -: 6006:
    #####: 6007:  char *zName = 0;                /* Path (name) of new entry */
    #####: 6008:  int nName = 0;                  /* Size of zName in bytes */
    #####: 6009:  char *zFree = 0;                /* Free this before returning */
        -: 6010:  int nByte;
        -: 6011:
    #####: 6012:  memset(&e, 0, sizeof(e));
    #####: 6013:  p = (ZipfileCtx*)sqlite3_aggregate_context(pCtx, sizeof(ZipfileCtx));
    #####: 6014:  if( p==0 ) return;
        -: 6015:
        -: 6016:  /* Martial the arguments into stack variables */
    #####: 6017:  if( nVal!=2 && nVal!=4 && nVal!=5 ){
    #####: 6018:    zErr = sqlite3_mprintf("wrong number of arguments to function zipfile()");
    #####: 6019:    rc = SQLITE_ERROR;
    #####: 6020:    goto zipfile_step_out;
        -: 6021:  }
    #####: 6022:  pName = apVal[0];
    #####: 6023:  if( nVal==2 ){
    #####: 6024:    pData = apVal[1];
        -: 6025:  }else{
    #####: 6026:    pMode = apVal[1];
    #####: 6027:    pMtime = apVal[2];
    #####: 6028:    pData = apVal[3];
    #####: 6029:    if( nVal==5 ){
    #####: 6030:      pMethod = apVal[4];
        -: 6031:    }
        -: 6032:  }
        -: 6033:
        -: 6034:  /* Check that the 'name' parameter looks ok. */
    #####: 6035:  zName = (char*)sqlite3_value_text(pName);
    #####: 6036:  nName = sqlite3_value_bytes(pName);
    #####: 6037:  if( zName==0 ){
    #####: 6038:    zErr = sqlite3_mprintf("first argument to zipfile() must be non-NULL");
    #####: 6039:    rc = SQLITE_ERROR;
    #####: 6040:    goto zipfile_step_out;
        -: 6041:  }
        -: 6042:
        -: 6043:  /* Inspect the 'method' parameter. This must be either 0 (store), 8 (use
        -: 6044:  ** deflate compression) or NULL (choose automatically).  */
    #####: 6045:  if( pMethod && SQLITE_NULL!=sqlite3_value_type(pMethod) ){
    #####: 6046:    iMethod = (int)sqlite3_value_int64(pMethod);
    #####: 6047:    if( iMethod!=0 && iMethod!=8 ){
    #####: 6048:      zErr = sqlite3_mprintf("illegal method value: %d", iMethod);
    #####: 6049:      rc = SQLITE_ERROR;
    #####: 6050:      goto zipfile_step_out;
        -: 6051:    }
        -: 6052:  }
        -: 6053:
        -: 6054:  /* Now inspect the data. If this is NULL, then the new entry must be a
        -: 6055:  ** directory.  Otherwise, figure out whether or not the data should
        -: 6056:  ** be deflated or simply stored in the zip archive. */
    #####: 6057:  if( sqlite3_value_type(pData)==SQLITE_NULL ){
    #####: 6058:    bIsDir = 1;
    #####: 6059:    iMethod = 0;
        -: 6060:  }else{
    #####: 6061:    aData = sqlite3_value_blob(pData);
    #####: 6062:    szUncompressed = nData = sqlite3_value_bytes(pData);
    #####: 6063:    iCrc32 = crc32(0, aData, nData);
    #####: 6064:    if( iMethod<0 || iMethod==8 ){
    #####: 6065:      int nOut = 0;
    #####: 6066:      rc = zipfileDeflate(aData, nData, &aFree, &nOut, &zErr);
    #####: 6067:      if( rc!=SQLITE_OK ){
    #####: 6068:        goto zipfile_step_out;
        -: 6069:      }
    #####: 6070:      if( iMethod==8 || nOut<nData ){
    #####: 6071:        aData = aFree;
    #####: 6072:        nData = nOut;
    #####: 6073:        iMethod = 8;
        -: 6074:      }else{
    #####: 6075:        iMethod = 0;
        -: 6076:      }
        -: 6077:    }
        -: 6078:  }
        -: 6079:
        -: 6080:  /* Decode the "mode" argument. */
    #####: 6081:  rc = zipfileGetMode(pMode, bIsDir, &mode, &zErr);
    #####: 6082:  if( rc ) goto zipfile_step_out;
        -: 6083:
        -: 6084:  /* Decode the "mtime" argument. */
    #####: 6085:  e.mUnixTime = zipfileGetTime(pMtime);
        -: 6086:
        -: 6087:  /* If this is a directory entry, ensure that there is exactly one '/'
        -: 6088:  ** at the end of the path. Or, if this is not a directory and the path
        -: 6089:  ** ends in '/' it is an error. */
    #####: 6090:  if( bIsDir==0 ){
    #####: 6091:    if( zName[nName-1]=='/' ){
    #####: 6092:      zErr = sqlite3_mprintf("non-directory name must not end with /");
    #####: 6093:      rc = SQLITE_ERROR;
    #####: 6094:      goto zipfile_step_out;
        -: 6095:    }
        -: 6096:  }else{
    #####: 6097:    if( zName[nName-1]!='/' ){
    #####: 6098:      zName = zFree = sqlite3_mprintf("%s/", zName);
    #####: 6099:      nName++;
    #####: 6100:      if( zName==0 ){
    #####: 6101:        rc = SQLITE_NOMEM;
    #####: 6102:        goto zipfile_step_out;
        -: 6103:      }
        -: 6104:    }else{
    #####: 6105:      while( nName>1 && zName[nName-2]=='/' ) nName--;
        -: 6106:    }
        -: 6107:  }
        -: 6108:
        -: 6109:  /* Assemble the ZipfileEntry object for the new zip archive entry */
    #####: 6110:  e.cds.iVersionMadeBy = ZIPFILE_NEWENTRY_MADEBY;
    #####: 6111:  e.cds.iVersionExtract = ZIPFILE_NEWENTRY_REQUIRED;
    #####: 6112:  e.cds.flags = ZIPFILE_NEWENTRY_FLAGS;
    #####: 6113:  e.cds.iCompression = (u16)iMethod;
    #####: 6114:  zipfileMtimeToDos(&e.cds, (u32)e.mUnixTime);
    #####: 6115:  e.cds.crc32 = iCrc32;
    #####: 6116:  e.cds.szCompressed = nData;
    #####: 6117:  e.cds.szUncompressed = szUncompressed;
    #####: 6118:  e.cds.iExternalAttr = (mode<<16);
    #####: 6119:  e.cds.iOffset = p->body.n;
    #####: 6120:  e.cds.nFile = (u16)nName;
    #####: 6121:  e.cds.zFile = zName;
        -: 6122:
        -: 6123:  /* Append the LFH to the body of the new archive */
    #####: 6124:  nByte = ZIPFILE_LFH_FIXED_SZ + e.cds.nFile + 9;
    #####: 6125:  if( (rc = zipfileBufferGrow(&p->body, nByte)) ) goto zipfile_step_out;
    #####: 6126:  p->body.n += zipfileSerializeLFH(&e, &p->body.a[p->body.n]);
        -: 6127:
        -: 6128:  /* Append the data to the body of the new archive */
    #####: 6129:  if( nData>0 ){
    #####: 6130:    if( (rc = zipfileBufferGrow(&p->body, nData)) ) goto zipfile_step_out;
    #####: 6131:    memcpy(&p->body.a[p->body.n], aData, nData);
    #####: 6132:    p->body.n += nData;
        -: 6133:  }
        -: 6134:
        -: 6135:  /* Append the CDS record to the directory of the new archive */
    #####: 6136:  nByte = ZIPFILE_CDS_FIXED_SZ + e.cds.nFile + 9;
    #####: 6137:  if( (rc = zipfileBufferGrow(&p->cds, nByte)) ) goto zipfile_step_out;
    #####: 6138:  p->cds.n += zipfileSerializeCDS(&e, &p->cds.a[p->cds.n]);
        -: 6139:
        -: 6140:  /* Increment the count of entries in the archive */
    #####: 6141:  p->nEntry++;
        -: 6142:
    #####: 6143: zipfile_step_out:
    #####: 6144:  sqlite3_free(aFree);
    #####: 6145:  sqlite3_free(zFree);
    #####: 6146:  if( rc ){
    #####: 6147:    if( zErr ){
    #####: 6148:      sqlite3_result_error(pCtx, zErr, -1);
        -: 6149:    }else{
    #####: 6150:      sqlite3_result_error_code(pCtx, rc);
        -: 6151:    }
        -: 6152:  }
    #####: 6153:  sqlite3_free(zErr);
        -: 6154:}
        -: 6155:
        -: 6156:/*
        -: 6157:** xFinalize() callback for zipfile aggregate function.
        -: 6158:*/
    #####: 6159:void zipfileFinal(sqlite3_context *pCtx){
        -: 6160:  ZipfileCtx *p;
        -: 6161:  ZipfileEOCD eocd;
        -: 6162:  int nZip;
        -: 6163:  u8 *aZip;
        -: 6164:
    #####: 6165:  p = (ZipfileCtx*)sqlite3_aggregate_context(pCtx, sizeof(ZipfileCtx));
    #####: 6166:  if( p==0 ) return;
    #####: 6167:  if( p->nEntry>0 ){
    #####: 6168:    memset(&eocd, 0, sizeof(eocd));
    #####: 6169:    eocd.nEntry = (u16)p->nEntry;
    #####: 6170:    eocd.nEntryTotal = (u16)p->nEntry;
    #####: 6171:    eocd.nSize = p->cds.n;
    #####: 6172:    eocd.iOffset = p->body.n;
        -: 6173:
    #####: 6174:    nZip = p->body.n + p->cds.n + ZIPFILE_EOCD_FIXED_SZ;
    #####: 6175:    aZip = (u8*)sqlite3_malloc(nZip);
    #####: 6176:    if( aZip==0 ){
    #####: 6177:      sqlite3_result_error_nomem(pCtx);
        -: 6178:    }else{
    #####: 6179:      memcpy(aZip, p->body.a, p->body.n);
    #####: 6180:      memcpy(&aZip[p->body.n], p->cds.a, p->cds.n);
    #####: 6181:      zipfileSerializeEOCD(&eocd, &aZip[p->body.n + p->cds.n]);
    #####: 6182:      sqlite3_result_blob(pCtx, aZip, nZip, zipfileFree);
        -: 6183:    }
        -: 6184:  }
        -: 6185:
    #####: 6186:  sqlite3_free(p->body.a);
    #####: 6187:  sqlite3_free(p->cds.a);
        -: 6188:}
        -: 6189:
        -: 6190:
        -: 6191:/*
        -: 6192:** Register the "zipfile" virtual table.
        -: 6193:*/
        2: 6194:static int zipfileRegister(sqlite3 *db){
        -: 6195:  static sqlite3_module zipfileModule = {
        -: 6196:    1,                         /* iVersion */
        -: 6197:    zipfileConnect,            /* xCreate */
        -: 6198:    zipfileConnect,            /* xConnect */
        -: 6199:    zipfileBestIndex,          /* xBestIndex */
        -: 6200:    zipfileDisconnect,         /* xDisconnect */
        -: 6201:    zipfileDisconnect,         /* xDestroy */
        -: 6202:    zipfileOpen,               /* xOpen - open a cursor */
        -: 6203:    zipfileClose,              /* xClose - close a cursor */
        -: 6204:    zipfileFilter,             /* xFilter - configure scan constraints */
        -: 6205:    zipfileNext,               /* xNext - advance a cursor */
        -: 6206:    zipfileEof,                /* xEof - check for end of scan */
        -: 6207:    zipfileColumn,             /* xColumn - read data */
        -: 6208:    0,                         /* xRowid - read data */
        -: 6209:    zipfileUpdate,             /* xUpdate */
        -: 6210:    zipfileBegin,              /* xBegin */
        -: 6211:    0,                         /* xSync */
        -: 6212:    zipfileCommit,             /* xCommit */
        -: 6213:    zipfileRollback,           /* xRollback */
        -: 6214:    zipfileFindFunction,       /* xFindMethod */
        -: 6215:    0,                         /* xRename */
        -: 6216:  };
        -: 6217:
        2: 6218:  int rc = sqlite3_create_module(db, "zipfile"  , &zipfileModule, 0);
        2: 6219:  if( rc==SQLITE_OK ) rc = sqlite3_overload_function(db, "zipfile_cds", -1);
        2: 6220:  if( rc==SQLITE_OK ){
        2: 6221:    rc = sqlite3_create_function(db, "zipfile", -1, SQLITE_UTF8, 0, 0, 
        -: 6222:        zipfileStep, zipfileFinal
        -: 6223:    );
        -: 6224:  }
        2: 6225:  return rc;
        -: 6226:}
        -: 6227:#else         /* SQLITE_OMIT_VIRTUALTABLE */
        -: 6228:# define zipfileRegister(x) SQLITE_OK
        -: 6229:#endif
        -: 6230:
        -: 6231:#ifdef _WIN32
        -: 6232:
        -: 6233:#endif
        2: 6234:int sqlite3_zipfile_init(
        -: 6235:  sqlite3 *db, 
        -: 6236:  char **pzErrMsg, 
        -: 6237:  const sqlite3_api_routines *pApi
        -: 6238:){
        -: 6239:  SQLITE_EXTENSION_INIT2(pApi);
        -: 6240:  (void)pzErrMsg;  /* Unused parameter */
        2: 6241:  return zipfileRegister(db);
        -: 6242:}
        -: 6243:
        -: 6244:/************************* End ../ext/misc/zipfile.c ********************/
        -: 6245:/************************* Begin ../ext/misc/sqlar.c ******************/
        -: 6246:/*
        -: 6247:** 2017-12-17
        -: 6248:**
        -: 6249:** The author disclaims copyright to this source code.  In place of
        -: 6250:** a legal notice, here is a blessing:
        -: 6251:**
        -: 6252:**    May you do good and not evil.
        -: 6253:**    May you find forgiveness for yourself and forgive others.
        -: 6254:**    May you share freely, never taking more than you give.
        -: 6255:**
        -: 6256:******************************************************************************
        -: 6257:**
        -: 6258:** Utility functions sqlar_compress() and sqlar_uncompress(). Useful
        -: 6259:** for working with sqlar archives and used by the shell tool's built-in
        -: 6260:** sqlar support.
        -: 6261:*/
        -: 6262:SQLITE_EXTENSION_INIT1
        -: 6263:#include <zlib.h>
        -: 6264:
        -: 6265:/*
        -: 6266:** Implementation of the "sqlar_compress(X)" SQL function.
        -: 6267:**
        -: 6268:** If the type of X is SQLITE_BLOB, and compressing that blob using
        -: 6269:** zlib utility function compress() yields a smaller blob, return the
        -: 6270:** compressed blob. Otherwise, return a copy of X.
        -: 6271:**
        -: 6272:** SQLar uses the "zlib format" for compressed content.  The zlib format
        -: 6273:** contains a two-byte identification header and a four-byte checksum at
        -: 6274:** the end.  This is different from ZIP which uses the raw deflate format.
        -: 6275:**
        -: 6276:** Future enhancements to SQLar might add support for new compression formats.
        -: 6277:** If so, those new formats will be identified by alternative headers in the
        -: 6278:** compressed data.
        -: 6279:*/
    #####: 6280:static void sqlarCompressFunc(
        -: 6281:  sqlite3_context *context,
        -: 6282:  int argc,
        -: 6283:  sqlite3_value **argv
        -: 6284:){
        -: 6285:  assert( argc==1 );
    #####: 6286:  if( sqlite3_value_type(argv[0])==SQLITE_BLOB ){
    #####: 6287:    const Bytef *pData = sqlite3_value_blob(argv[0]);
    #####: 6288:    uLong nData = sqlite3_value_bytes(argv[0]);
    #####: 6289:    uLongf nOut = compressBound(nData);
        -: 6290:    Bytef *pOut;
        -: 6291:
    #####: 6292:    pOut = (Bytef*)sqlite3_malloc(nOut);
    #####: 6293:    if( pOut==0 ){
    #####: 6294:      sqlite3_result_error_nomem(context);
    #####: 6295:      return;
        -: 6296:    }else{
    #####: 6297:      if( Z_OK!=compress(pOut, &nOut, pData, nData) ){
    #####: 6298:        sqlite3_result_error(context, "error in compress()", -1);
    #####: 6299:      }else if( nOut<nData ){
    #####: 6300:        sqlite3_result_blob(context, pOut, nOut, SQLITE_TRANSIENT);
        -: 6301:      }else{
    #####: 6302:        sqlite3_result_value(context, argv[0]);
        -: 6303:      }
    #####: 6304:      sqlite3_free(pOut);
        -: 6305:    }
        -: 6306:  }else{
    #####: 6307:    sqlite3_result_value(context, argv[0]);
        -: 6308:  }
        -: 6309:}
        -: 6310:
        -: 6311:/*
        -: 6312:** Implementation of the "sqlar_uncompress(X,SZ)" SQL function
        -: 6313:**
        -: 6314:** Parameter SZ is interpreted as an integer. If it is less than or
        -: 6315:** equal to zero, then this function returns a copy of X. Or, if
        -: 6316:** SZ is equal to the size of X when interpreted as a blob, also
        -: 6317:** return a copy of X. Otherwise, decompress blob X using zlib
        -: 6318:** utility function uncompress() and return the results (another
        -: 6319:** blob).
        -: 6320:*/
    #####: 6321:static void sqlarUncompressFunc(
        -: 6322:  sqlite3_context *context,
        -: 6323:  int argc,
        -: 6324:  sqlite3_value **argv
        -: 6325:){
        -: 6326:  uLong nData;
        -: 6327:  uLongf sz;
        -: 6328:
        -: 6329:  assert( argc==2 );
    #####: 6330:  sz = sqlite3_value_int(argv[1]);
        -: 6331:
    #####: 6332:  if( sz<=0 || sz==(nData = sqlite3_value_bytes(argv[0])) ){
    #####: 6333:    sqlite3_result_value(context, argv[0]);
        -: 6334:  }else{
    #####: 6335:    const Bytef *pData= sqlite3_value_blob(argv[0]);
    #####: 6336:    Bytef *pOut = sqlite3_malloc(sz);
    #####: 6337:    if( Z_OK!=uncompress(pOut, &sz, pData, nData) ){
    #####: 6338:      sqlite3_result_error(context, "error in uncompress()", -1);
        -: 6339:    }else{
    #####: 6340:      sqlite3_result_blob(context, pOut, sz, SQLITE_TRANSIENT);
        -: 6341:    }
    #####: 6342:    sqlite3_free(pOut);
        -: 6343:  }
    #####: 6344:}
        -: 6345:
        -: 6346:
        -: 6347:#ifdef _WIN32
        -: 6348:
        -: 6349:#endif
        2: 6350:int sqlite3_sqlar_init(
        -: 6351:  sqlite3 *db, 
        -: 6352:  char **pzErrMsg, 
        -: 6353:  const sqlite3_api_routines *pApi
        -: 6354:){
        2: 6355:  int rc = SQLITE_OK;
        -: 6356:  SQLITE_EXTENSION_INIT2(pApi);
        -: 6357:  (void)pzErrMsg;  /* Unused parameter */
        2: 6358:  rc = sqlite3_create_function(db, "sqlar_compress", 1, SQLITE_UTF8, 0,
        -: 6359:                               sqlarCompressFunc, 0, 0);
        2: 6360:  if( rc==SQLITE_OK ){
        2: 6361:    rc = sqlite3_create_function(db, "sqlar_uncompress", 2, SQLITE_UTF8, 0,
        -: 6362:                                 sqlarUncompressFunc, 0, 0);
        -: 6363:  }
        2: 6364:  return rc;
        -: 6365:}
        -: 6366:
        -: 6367:/************************* End ../ext/misc/sqlar.c ********************/
        -: 6368:#endif
        -: 6369:/************************* Begin ../ext/expert/sqlite3expert.h ******************/
        -: 6370:/*
        -: 6371:** 2017 April 07
        -: 6372:**
        -: 6373:** The author disclaims copyright to this source code.  In place of
        -: 6374:** a legal notice, here is a blessing:
        -: 6375:**
        -: 6376:**    May you do good and not evil.
        -: 6377:**    May you find forgiveness for yourself and forgive others.
        -: 6378:**    May you share freely, never taking more than you give.
        -: 6379:**
        -: 6380:*************************************************************************
        -: 6381:*/
        -: 6382:
        -: 6383:
        -: 6384:
        -: 6385:typedef struct sqlite3expert sqlite3expert;
        -: 6386:
        -: 6387:/*
        -: 6388:** Create a new sqlite3expert object.
        -: 6389:**
        -: 6390:** If successful, a pointer to the new object is returned and (*pzErr) set
        -: 6391:** to NULL. Or, if an error occurs, NULL is returned and (*pzErr) set to
        -: 6392:** an English-language error message. In this case it is the responsibility
        -: 6393:** of the caller to eventually free the error message buffer using
        -: 6394:** sqlite3_free().
        -: 6395:*/
        -: 6396:sqlite3expert *sqlite3_expert_new(sqlite3 *db, char **pzErr);
        -: 6397:
        -: 6398:/*
        -: 6399:** Configure an sqlite3expert object.
        -: 6400:**
        -: 6401:** EXPERT_CONFIG_SAMPLE:
        -: 6402:**   By default, sqlite3_expert_analyze() generates sqlite_stat1 data for
        -: 6403:**   each candidate index. This involves scanning and sorting the entire
        -: 6404:**   contents of each user database table once for each candidate index
        -: 6405:**   associated with the table. For large databases, this can be 
        -: 6406:**   prohibitively slow. This option allows the sqlite3expert object to
        -: 6407:**   be configured so that sqlite_stat1 data is instead generated based on a
        -: 6408:**   subset of each table, or so that no sqlite_stat1 data is used at all.
        -: 6409:**
        -: 6410:**   A single integer argument is passed to this option. If the value is less
        -: 6411:**   than or equal to zero, then no sqlite_stat1 data is generated or used by
        -: 6412:**   the analysis - indexes are recommended based on the database schema only.
        -: 6413:**   Or, if the value is 100 or greater, complete sqlite_stat1 data is
        -: 6414:**   generated for each candidate index (this is the default). Finally, if the
        -: 6415:**   value falls between 0 and 100, then it represents the percentage of user
        -: 6416:**   table rows that should be considered when generating sqlite_stat1 data.
        -: 6417:**
        -: 6418:**   Examples:
        -: 6419:**
        -: 6420:**     // Do not generate any sqlite_stat1 data
        -: 6421:**     sqlite3_expert_config(pExpert, EXPERT_CONFIG_SAMPLE, 0);
        -: 6422:**
        -: 6423:**     // Generate sqlite_stat1 data based on 10% of the rows in each table.
        -: 6424:**     sqlite3_expert_config(pExpert, EXPERT_CONFIG_SAMPLE, 10);
        -: 6425:*/
        -: 6426:int sqlite3_expert_config(sqlite3expert *p, int op, ...);
        -: 6427:
        -: 6428:#define EXPERT_CONFIG_SAMPLE 1    /* int */
        -: 6429:
        -: 6430:/*
        -: 6431:** Specify zero or more SQL statements to be included in the analysis.
        -: 6432:**
        -: 6433:** Buffer zSql must contain zero or more complete SQL statements. This
        -: 6434:** function parses all statements contained in the buffer and adds them
        -: 6435:** to the internal list of statements to analyze. If successful, SQLITE_OK
        -: 6436:** is returned and (*pzErr) set to NULL. Or, if an error occurs - for example
        -: 6437:** due to a error in the SQL - an SQLite error code is returned and (*pzErr)
        -: 6438:** may be set to point to an English language error message. In this case
        -: 6439:** the caller is responsible for eventually freeing the error message buffer
        -: 6440:** using sqlite3_free().
        -: 6441:**
        -: 6442:** If an error does occur while processing one of the statements in the
        -: 6443:** buffer passed as the second argument, none of the statements in the
        -: 6444:** buffer are added to the analysis.
        -: 6445:**
        -: 6446:** This function must be called before sqlite3_expert_analyze(). If a call
        -: 6447:** to this function is made on an sqlite3expert object that has already
        -: 6448:** been passed to sqlite3_expert_analyze() SQLITE_MISUSE is returned
        -: 6449:** immediately and no statements are added to the analysis.
        -: 6450:*/
        -: 6451:int sqlite3_expert_sql(
        -: 6452:  sqlite3expert *p,               /* From a successful sqlite3_expert_new() */
        -: 6453:  const char *zSql,               /* SQL statement(s) to add */
        -: 6454:  char **pzErr                    /* OUT: Error message (if any) */
        -: 6455:);
        -: 6456:
        -: 6457:
        -: 6458:/*
        -: 6459:** This function is called after the sqlite3expert object has been configured
        -: 6460:** with all SQL statements using sqlite3_expert_sql() to actually perform
        -: 6461:** the analysis. Once this function has been called, it is not possible to
        -: 6462:** add further SQL statements to the analysis.
        -: 6463:**
        -: 6464:** If successful, SQLITE_OK is returned and (*pzErr) is set to NULL. Or, if
        -: 6465:** an error occurs, an SQLite error code is returned and (*pzErr) set to 
        -: 6466:** point to a buffer containing an English language error message. In this
        -: 6467:** case it is the responsibility of the caller to eventually free the buffer
        -: 6468:** using sqlite3_free().
        -: 6469:**
        -: 6470:** If an error does occur within this function, the sqlite3expert object
        -: 6471:** is no longer useful for any purpose. At that point it is no longer
        -: 6472:** possible to add further SQL statements to the object or to re-attempt
        -: 6473:** the analysis. The sqlite3expert object must still be freed using a call
        -: 6474:** sqlite3_expert_destroy().
        -: 6475:*/
        -: 6476:int sqlite3_expert_analyze(sqlite3expert *p, char **pzErr);
        -: 6477:
        -: 6478:/*
        -: 6479:** Return the total number of statements loaded using sqlite3_expert_sql().
        -: 6480:** The total number of SQL statements may be different from the total number
        -: 6481:** to calls to sqlite3_expert_sql().
        -: 6482:*/
        -: 6483:int sqlite3_expert_count(sqlite3expert*);
        -: 6484:
        -: 6485:/*
        -: 6486:** Return a component of the report.
        -: 6487:**
        -: 6488:** This function is called after sqlite3_expert_analyze() to extract the
        -: 6489:** results of the analysis. Each call to this function returns either a
        -: 6490:** NULL pointer or a pointer to a buffer containing a nul-terminated string.
        -: 6491:** The value passed as the third argument must be one of the EXPERT_REPORT_*
        -: 6492:** #define constants defined below.
        -: 6493:**
        -: 6494:** For some EXPERT_REPORT_* parameters, the buffer returned contains 
        -: 6495:** information relating to a specific SQL statement. In these cases that
        -: 6496:** SQL statement is identified by the value passed as the second argument.
        -: 6497:** SQL statements are numbered from 0 in the order in which they are parsed.
        -: 6498:** If an out-of-range value (less than zero or equal to or greater than the
        -: 6499:** value returned by sqlite3_expert_count()) is passed as the second argument
        -: 6500:** along with such an EXPERT_REPORT_* parameter, NULL is always returned.
        -: 6501:**
        -: 6502:** EXPERT_REPORT_SQL:
        -: 6503:**   Return the text of SQL statement iStmt.
        -: 6504:**
        -: 6505:** EXPERT_REPORT_INDEXES:
        -: 6506:**   Return a buffer containing the CREATE INDEX statements for all recommended
        -: 6507:**   indexes for statement iStmt. If there are no new recommeded indexes, NULL 
        -: 6508:**   is returned.
        -: 6509:**
        -: 6510:** EXPERT_REPORT_PLAN:
        -: 6511:**   Return a buffer containing the EXPLAIN QUERY PLAN output for SQL query
        -: 6512:**   iStmt after the proposed indexes have been added to the database schema.
        -: 6513:**
        -: 6514:** EXPERT_REPORT_CANDIDATES:
        -: 6515:**   Return a pointer to a buffer containing the CREATE INDEX statements 
        -: 6516:**   for all indexes that were tested (for all SQL statements). The iStmt
        -: 6517:**   parameter is ignored for EXPERT_REPORT_CANDIDATES calls.
        -: 6518:*/
        -: 6519:const char *sqlite3_expert_report(sqlite3expert*, int iStmt, int eReport);
        -: 6520:
        -: 6521:/*
        -: 6522:** Values for the third argument passed to sqlite3_expert_report().
        -: 6523:*/
        -: 6524:#define EXPERT_REPORT_SQL        1
        -: 6525:#define EXPERT_REPORT_INDEXES    2
        -: 6526:#define EXPERT_REPORT_PLAN       3
        -: 6527:#define EXPERT_REPORT_CANDIDATES 4
        -: 6528:
        -: 6529:/*
        -: 6530:** Free an (sqlite3expert*) handle and all associated resources. There 
        -: 6531:** should be one call to this function for each successful call to 
        -: 6532:** sqlite3-expert_new().
        -: 6533:*/
        -: 6534:void sqlite3_expert_destroy(sqlite3expert*);
        -: 6535:
        -: 6536:
        -: 6537:
        -: 6538:/************************* End ../ext/expert/sqlite3expert.h ********************/
        -: 6539:/************************* Begin ../ext/expert/sqlite3expert.c ******************/
        -: 6540:/*
        -: 6541:** 2017 April 09
        -: 6542:**
        -: 6543:** The author disclaims copyright to this source code.  In place of
        -: 6544:** a legal notice, here is a blessing:
        -: 6545:**
        -: 6546:**    May you do good and not evil.
        -: 6547:**    May you find forgiveness for yourself and forgive others.
        -: 6548:**    May you share freely, never taking more than you give.
        -: 6549:**
        -: 6550:*************************************************************************
        -: 6551:*/
        -: 6552:#include <assert.h>
        -: 6553:#include <string.h>
        -: 6554:#include <stdio.h>
        -: 6555:
        -: 6556:#ifndef SQLITE_OMIT_VIRTUALTABLE 
        -: 6557:
        -: 6558:/* typedef sqlite3_int64 i64; */
        -: 6559:/* typedef sqlite3_uint64 u64; */
        -: 6560:
        -: 6561:typedef struct IdxColumn IdxColumn;
        -: 6562:typedef struct IdxConstraint IdxConstraint;
        -: 6563:typedef struct IdxScan IdxScan;
        -: 6564:typedef struct IdxStatement IdxStatement;
        -: 6565:typedef struct IdxTable IdxTable;
        -: 6566:typedef struct IdxWrite IdxWrite;
        -: 6567:
        -: 6568:#define STRLEN  (int)strlen
        -: 6569:
        -: 6570:/*
        -: 6571:** A temp table name that we assume no user database will actually use.
        -: 6572:** If this assumption proves incorrect triggers on the table with the
        -: 6573:** conflicting name will be ignored.
        -: 6574:*/
        -: 6575:#define UNIQUE_TABLE_NAME "t592690916721053953805701627921227776"
        -: 6576:
        -: 6577:/*
        -: 6578:** A single constraint. Equivalent to either "col = ?" or "col < ?" (or
        -: 6579:** any other type of single-ended range constraint on a column).
        -: 6580:**
        -: 6581:** pLink:
        -: 6582:**   Used to temporarily link IdxConstraint objects into lists while
        -: 6583:**   creating candidate indexes.
        -: 6584:*/
        -: 6585:struct IdxConstraint {
        -: 6586:  char *zColl;                    /* Collation sequence */
        -: 6587:  int bRange;                     /* True for range, false for eq */
        -: 6588:  int iCol;                       /* Constrained table column */
        -: 6589:  int bFlag;                      /* Used by idxFindCompatible() */
        -: 6590:  int bDesc;                      /* True if ORDER BY <expr> DESC */
        -: 6591:  IdxConstraint *pNext;           /* Next constraint in pEq or pRange list */
        -: 6592:  IdxConstraint *pLink;           /* See above */
        -: 6593:};
        -: 6594:
        -: 6595:/*
        -: 6596:** A single scan of a single table.
        -: 6597:*/
        -: 6598:struct IdxScan {
        -: 6599:  IdxTable *pTab;                 /* Associated table object */
        -: 6600:  int iDb;                        /* Database containing table zTable */
        -: 6601:  i64 covering;                   /* Mask of columns required for cov. index */
        -: 6602:  IdxConstraint *pOrder;          /* ORDER BY columns */
        -: 6603:  IdxConstraint *pEq;             /* List of == constraints */
        -: 6604:  IdxConstraint *pRange;          /* List of < constraints */
        -: 6605:  IdxScan *pNextScan;             /* Next IdxScan object for same analysis */
        -: 6606:};
        -: 6607:
        -: 6608:/*
        -: 6609:** Information regarding a single database table. Extracted from 
        -: 6610:** "PRAGMA table_info" by function idxGetTableInfo().
        -: 6611:*/
        -: 6612:struct IdxColumn {
        -: 6613:  char *zName;
        -: 6614:  char *zColl;
        -: 6615:  int iPk;
        -: 6616:};
        -: 6617:struct IdxTable {
        -: 6618:  int nCol;
        -: 6619:  char *zName;                    /* Table name */
        -: 6620:  IdxColumn *aCol;
        -: 6621:  IdxTable *pNext;                /* Next table in linked list of all tables */
        -: 6622:};
        -: 6623:
        -: 6624:/*
        -: 6625:** An object of the following type is created for each unique table/write-op
        -: 6626:** seen. The objects are stored in a singly-linked list beginning at
        -: 6627:** sqlite3expert.pWrite.
        -: 6628:*/
        -: 6629:struct IdxWrite {
        -: 6630:  IdxTable *pTab;
        -: 6631:  int eOp;                        /* SQLITE_UPDATE, DELETE or INSERT */
        -: 6632:  IdxWrite *pNext;
        -: 6633:};
        -: 6634:
        -: 6635:/*
        -: 6636:** Each statement being analyzed is represented by an instance of this
        -: 6637:** structure.
        -: 6638:*/
        -: 6639:struct IdxStatement {
        -: 6640:  int iId;                        /* Statement number */
        -: 6641:  char *zSql;                     /* SQL statement */
        -: 6642:  char *zIdx;                     /* Indexes */
        -: 6643:  char *zEQP;                     /* Plan */
        -: 6644:  IdxStatement *pNext;
        -: 6645:};
        -: 6646:
        -: 6647:
        -: 6648:/*
        -: 6649:** A hash table for storing strings. With space for a payload string
        -: 6650:** with each entry. Methods are:
        -: 6651:**
        -: 6652:**   idxHashInit()
        -: 6653:**   idxHashClear()
        -: 6654:**   idxHashAdd()
        -: 6655:**   idxHashSearch()
        -: 6656:*/
        -: 6657:#define IDX_HASH_SIZE 1023
        -: 6658:typedef struct IdxHashEntry IdxHashEntry;
        -: 6659:typedef struct IdxHash IdxHash;
        -: 6660:struct IdxHashEntry {
        -: 6661:  char *zKey;                     /* nul-terminated key */
        -: 6662:  char *zVal;                     /* nul-terminated value string */
        -: 6663:  char *zVal2;                    /* nul-terminated value string 2 */
        -: 6664:  IdxHashEntry *pHashNext;        /* Next entry in same hash bucket */
        -: 6665:  IdxHashEntry *pNext;            /* Next entry in hash */
        -: 6666:};
        -: 6667:struct IdxHash {
        -: 6668:  IdxHashEntry *pFirst;
        -: 6669:  IdxHashEntry *aHash[IDX_HASH_SIZE];
        -: 6670:};
        -: 6671:
        -: 6672:/*
        -: 6673:** sqlite3expert object.
        -: 6674:*/
        -: 6675:struct sqlite3expert {
        -: 6676:  int iSample;                    /* Percentage of tables to sample for stat1 */
        -: 6677:  sqlite3 *db;                    /* User database */
        -: 6678:  sqlite3 *dbm;                   /* In-memory db for this analysis */
        -: 6679:  sqlite3 *dbv;                   /* Vtab schema for this analysis */
        -: 6680:  IdxTable *pTable;               /* List of all IdxTable objects */
        -: 6681:  IdxScan *pScan;                 /* List of scan objects */
        -: 6682:  IdxWrite *pWrite;               /* List of write objects */
        -: 6683:  IdxStatement *pStatement;       /* List of IdxStatement objects */
        -: 6684:  int bRun;                       /* True once analysis has run */
        -: 6685:  char **pzErrmsg;
        -: 6686:  int rc;                         /* Error code from whereinfo hook */
        -: 6687:  IdxHash hIdx;                   /* Hash containing all candidate indexes */
        -: 6688:  char *zCandidates;              /* For EXPERT_REPORT_CANDIDATES */
        -: 6689:};
        -: 6690:
        -: 6691:
        -: 6692:/*
        -: 6693:** Allocate and return nByte bytes of zeroed memory using sqlite3_malloc(). 
        -: 6694:** If the allocation fails, set *pRc to SQLITE_NOMEM and return NULL.
        -: 6695:*/
    #####: 6696:static void *idxMalloc(int *pRc, int nByte){
        -: 6697:  void *pRet;
        -: 6698:  assert( *pRc==SQLITE_OK );
        -: 6699:  assert( nByte>0 );
    #####: 6700:  pRet = sqlite3_malloc(nByte);
    #####: 6701:  if( pRet ){
    #####: 6702:    memset(pRet, 0, nByte);
        -: 6703:  }else{
    #####: 6704:    *pRc = SQLITE_NOMEM;
        -: 6705:  }
    #####: 6706:  return pRet;
        -: 6707:}
        -: 6708:
        -: 6709:/*
        -: 6710:** Initialize an IdxHash hash table.
        -: 6711:*/
    #####: 6712:static void idxHashInit(IdxHash *pHash){
    #####: 6713:  memset(pHash, 0, sizeof(IdxHash));
    #####: 6714:}
        -: 6715:
        -: 6716:/*
        -: 6717:** Reset an IdxHash hash table.
        -: 6718:*/
    #####: 6719:static void idxHashClear(IdxHash *pHash){
        -: 6720:  int i;
    #####: 6721:  for(i=0; i<IDX_HASH_SIZE; i++){
        -: 6722:    IdxHashEntry *pEntry;
        -: 6723:    IdxHashEntry *pNext;
    #####: 6724:    for(pEntry=pHash->aHash[i]; pEntry; pEntry=pNext){
    #####: 6725:      pNext = pEntry->pHashNext;
    #####: 6726:      sqlite3_free(pEntry->zVal2);
    #####: 6727:      sqlite3_free(pEntry);
        -: 6728:    }
        -: 6729:  }
    #####: 6730:  memset(pHash, 0, sizeof(IdxHash));
    #####: 6731:}
        -: 6732:
        -: 6733:/*
        -: 6734:** Return the index of the hash bucket that the string specified by the
        -: 6735:** arguments to this function belongs.
        -: 6736:*/
    #####: 6737:static int idxHashString(const char *z, int n){
    #####: 6738:  unsigned int ret = 0;
        -: 6739:  int i;
    #####: 6740:  for(i=0; i<n; i++){
    #####: 6741:    ret += (ret<<3) + (unsigned char)(z[i]);
        -: 6742:  }
    #####: 6743:  return (int)(ret % IDX_HASH_SIZE);
        -: 6744:}
        -: 6745:
        -: 6746:/*
        -: 6747:** If zKey is already present in the hash table, return non-zero and do
        -: 6748:** nothing. Otherwise, add an entry with key zKey and payload string zVal to
        -: 6749:** the hash table passed as the second argument. 
        -: 6750:*/
    #####: 6751:static int idxHashAdd(
        -: 6752:  int *pRc, 
        -: 6753:  IdxHash *pHash, 
        -: 6754:  const char *zKey,
        -: 6755:  const char *zVal
        -: 6756:){
    #####: 6757:  int nKey = STRLEN(zKey);
    #####: 6758:  int iHash = idxHashString(zKey, nKey);
    #####: 6759:  int nVal = (zVal ? STRLEN(zVal) : 0);
        -: 6760:  IdxHashEntry *pEntry;
        -: 6761:  assert( iHash>=0 );
    #####: 6762:  for(pEntry=pHash->aHash[iHash]; pEntry; pEntry=pEntry->pHashNext){
    #####: 6763:    if( STRLEN(pEntry->zKey)==nKey && 0==memcmp(pEntry->zKey, zKey, nKey) ){
    #####: 6764:      return 1;
        -: 6765:    }
        -: 6766:  }
    #####: 6767:  pEntry = idxMalloc(pRc, sizeof(IdxHashEntry) + nKey+1 + nVal+1);
    #####: 6768:  if( pEntry ){
    #####: 6769:    pEntry->zKey = (char*)&pEntry[1];
    #####: 6770:    memcpy(pEntry->zKey, zKey, nKey);
    #####: 6771:    if( zVal ){
    #####: 6772:      pEntry->zVal = &pEntry->zKey[nKey+1];
    #####: 6773:      memcpy(pEntry->zVal, zVal, nVal);
        -: 6774:    }
    #####: 6775:    pEntry->pHashNext = pHash->aHash[iHash];
    #####: 6776:    pHash->aHash[iHash] = pEntry;
        -: 6777:
    #####: 6778:    pEntry->pNext = pHash->pFirst;
    #####: 6779:    pHash->pFirst = pEntry;
        -: 6780:  }
    #####: 6781:  return 0;
        -: 6782:}
        -: 6783:
        -: 6784:/*
        -: 6785:** If zKey/nKey is present in the hash table, return a pointer to the 
        -: 6786:** hash-entry object.
        -: 6787:*/
    #####: 6788:static IdxHashEntry *idxHashFind(IdxHash *pHash, const char *zKey, int nKey){
        -: 6789:  int iHash;
        -: 6790:  IdxHashEntry *pEntry;
    #####: 6791:  if( nKey<0 ) nKey = STRLEN(zKey);
    #####: 6792:  iHash = idxHashString(zKey, nKey);
        -: 6793:  assert( iHash>=0 );
    #####: 6794:  for(pEntry=pHash->aHash[iHash]; pEntry; pEntry=pEntry->pHashNext){
    #####: 6795:    if( STRLEN(pEntry->zKey)==nKey && 0==memcmp(pEntry->zKey, zKey, nKey) ){
    #####: 6796:      return pEntry;
        -: 6797:    }
        -: 6798:  }
    #####: 6799:  return 0;
        -: 6800:}
        -: 6801:
        -: 6802:/*
        -: 6803:** If the hash table contains an entry with a key equal to the string
        -: 6804:** passed as the final two arguments to this function, return a pointer
        -: 6805:** to the payload string. Otherwise, if zKey/nKey is not present in the
        -: 6806:** hash table, return NULL.
        -: 6807:*/
    #####: 6808:static const char *idxHashSearch(IdxHash *pHash, const char *zKey, int nKey){
    #####: 6809:  IdxHashEntry *pEntry = idxHashFind(pHash, zKey, nKey);
    #####: 6810:  if( pEntry ) return pEntry->zVal;
    #####: 6811:  return 0;
        -: 6812:}
        -: 6813:
        -: 6814:/*
        -: 6815:** Allocate and return a new IdxConstraint object. Set the IdxConstraint.zColl
        -: 6816:** variable to point to a copy of nul-terminated string zColl.
        -: 6817:*/
    #####: 6818:static IdxConstraint *idxNewConstraint(int *pRc, const char *zColl){
        -: 6819:  IdxConstraint *pNew;
    #####: 6820:  int nColl = STRLEN(zColl);
        -: 6821:
        -: 6822:  assert( *pRc==SQLITE_OK );
    #####: 6823:  pNew = (IdxConstraint*)idxMalloc(pRc, sizeof(IdxConstraint) * nColl + 1);
    #####: 6824:  if( pNew ){
    #####: 6825:    pNew->zColl = (char*)&pNew[1];
    #####: 6826:    memcpy(pNew->zColl, zColl, nColl+1);
        -: 6827:  }
    #####: 6828:  return pNew;
        -: 6829:}
        -: 6830:
        -: 6831:/*
        -: 6832:** An error associated with database handle db has just occurred. Pass
        -: 6833:** the error message to callback function xOut.
        -: 6834:*/
    #####: 6835:static void idxDatabaseError(
        -: 6836:  sqlite3 *db,                    /* Database handle */
        -: 6837:  char **pzErrmsg                 /* Write error here */
        -: 6838:){
    #####: 6839:  *pzErrmsg = sqlite3_mprintf("%s", sqlite3_errmsg(db));
    #####: 6840:}
        -: 6841:
        -: 6842:/*
        -: 6843:** Prepare an SQL statement.
        -: 6844:*/
    #####: 6845:static int idxPrepareStmt(
        -: 6846:  sqlite3 *db,                    /* Database handle to compile against */
        -: 6847:  sqlite3_stmt **ppStmt,          /* OUT: Compiled SQL statement */
        -: 6848:  char **pzErrmsg,                /* OUT: sqlite3_malloc()ed error message */
        -: 6849:  const char *zSql                /* SQL statement to compile */
        -: 6850:){
    #####: 6851:  int rc = sqlite3_prepare_v2(db, zSql, -1, ppStmt, 0);
    #####: 6852:  if( rc!=SQLITE_OK ){
    #####: 6853:    *ppStmt = 0;
    #####: 6854:    idxDatabaseError(db, pzErrmsg);
        -: 6855:  }
    #####: 6856:  return rc;
        -: 6857:}
        -: 6858:
        -: 6859:/*
        -: 6860:** Prepare an SQL statement using the results of a printf() formatting.
        -: 6861:*/
    #####: 6862:static int idxPrintfPrepareStmt(
        -: 6863:  sqlite3 *db,                    /* Database handle to compile against */
        -: 6864:  sqlite3_stmt **ppStmt,          /* OUT: Compiled SQL statement */
        -: 6865:  char **pzErrmsg,                /* OUT: sqlite3_malloc()ed error message */
        -: 6866:  const char *zFmt,               /* printf() format of SQL statement */
        -: 6867:  ...                             /* Trailing printf() arguments */
        -: 6868:){
        -: 6869:  va_list ap;
        -: 6870:  int rc;
        -: 6871:  char *zSql;
    #####: 6872:  va_start(ap, zFmt);
    #####: 6873:  zSql = sqlite3_vmprintf(zFmt, ap);
    #####: 6874:  if( zSql==0 ){
    #####: 6875:    rc = SQLITE_NOMEM;
        -: 6876:  }else{
    #####: 6877:    rc = idxPrepareStmt(db, ppStmt, pzErrmsg, zSql);
    #####: 6878:    sqlite3_free(zSql);
        -: 6879:  }
    #####: 6880:  va_end(ap);
    #####: 6881:  return rc;
        -: 6882:}
        -: 6883:
        -: 6884:
        -: 6885:/*************************************************************************
        -: 6886:** Beginning of virtual table implementation.
        -: 6887:*/
        -: 6888:typedef struct ExpertVtab ExpertVtab;
        -: 6889:struct ExpertVtab {
        -: 6890:  sqlite3_vtab base;
        -: 6891:  IdxTable *pTab;
        -: 6892:  sqlite3expert *pExpert;
        -: 6893:};
        -: 6894:
        -: 6895:typedef struct ExpertCsr ExpertCsr;
        -: 6896:struct ExpertCsr {
        -: 6897:  sqlite3_vtab_cursor base;
        -: 6898:  sqlite3_stmt *pData;
        -: 6899:};
        -: 6900:
    #####: 6901:static char *expertDequote(const char *zIn){
    #####: 6902:  int n = STRLEN(zIn);
    #####: 6903:  char *zRet = sqlite3_malloc(n);
        -: 6904:
        -: 6905:  assert( zIn[0]=='\'' );
        -: 6906:  assert( zIn[n-1]=='\'' );
        -: 6907:
    #####: 6908:  if( zRet ){
    #####: 6909:    int iOut = 0;
    #####: 6910:    int iIn = 0;
    #####: 6911:    for(iIn=1; iIn<(n-1); iIn++){
    #####: 6912:      if( zIn[iIn]=='\'' ){
        -: 6913:        assert( zIn[iIn+1]=='\'' );
    #####: 6914:        iIn++;
        -: 6915:      }
    #####: 6916:      zRet[iOut++] = zIn[iIn];
        -: 6917:    }
    #####: 6918:    zRet[iOut] = '\0';
        -: 6919:  }
        -: 6920:
    #####: 6921:  return zRet;
        -: 6922:}
        -: 6923:
        -: 6924:/* 
        -: 6925:** This function is the implementation of both the xConnect and xCreate
        -: 6926:** methods of the r-tree virtual table.
        -: 6927:**
        -: 6928:**   argv[0]   -> module name
        -: 6929:**   argv[1]   -> database name
        -: 6930:**   argv[2]   -> table name
        -: 6931:**   argv[...] -> column names...
        -: 6932:*/
    #####: 6933:static int expertConnect(
        -: 6934:  sqlite3 *db,
        -: 6935:  void *pAux,
        -: 6936:  int argc, const char *const*argv,
        -: 6937:  sqlite3_vtab **ppVtab,
        -: 6938:  char **pzErr
        -: 6939:){
    #####: 6940:  sqlite3expert *pExpert = (sqlite3expert*)pAux;
    #####: 6941:  ExpertVtab *p = 0;
        -: 6942:  int rc;
        -: 6943:
    #####: 6944:  if( argc!=4 ){
    #####: 6945:    *pzErr = sqlite3_mprintf("internal error!");
    #####: 6946:    rc = SQLITE_ERROR;
        -: 6947:  }else{
    #####: 6948:    char *zCreateTable = expertDequote(argv[3]);
    #####: 6949:    if( zCreateTable ){
    #####: 6950:      rc = sqlite3_declare_vtab(db, zCreateTable);
    #####: 6951:      if( rc==SQLITE_OK ){
    #####: 6952:        p = idxMalloc(&rc, sizeof(ExpertVtab));
        -: 6953:      }
    #####: 6954:      if( rc==SQLITE_OK ){
    #####: 6955:        p->pExpert = pExpert;
    #####: 6956:        p->pTab = pExpert->pTable;
        -: 6957:        assert( sqlite3_stricmp(p->pTab->zName, argv[2])==0 );
        -: 6958:      }
    #####: 6959:      sqlite3_free(zCreateTable);
        -: 6960:    }else{
    #####: 6961:      rc = SQLITE_NOMEM;
        -: 6962:    }
        -: 6963:  }
        -: 6964:
    #####: 6965:  *ppVtab = (sqlite3_vtab*)p;
    #####: 6966:  return rc;
        -: 6967:}
        -: 6968:
    #####: 6969:static int expertDisconnect(sqlite3_vtab *pVtab){
    #####: 6970:  ExpertVtab *p = (ExpertVtab*)pVtab;
    #####: 6971:  sqlite3_free(p);
    #####: 6972:  return SQLITE_OK;
        -: 6973:}
        -: 6974:
    #####: 6975:static int expertBestIndex(sqlite3_vtab *pVtab, sqlite3_index_info *pIdxInfo){
    #####: 6976:  ExpertVtab *p = (ExpertVtab*)pVtab;
    #####: 6977:  int rc = SQLITE_OK;
    #####: 6978:  int n = 0;
        -: 6979:  IdxScan *pScan;
    #####: 6980:  const int opmask = 
        -: 6981:    SQLITE_INDEX_CONSTRAINT_EQ | SQLITE_INDEX_CONSTRAINT_GT |
        -: 6982:    SQLITE_INDEX_CONSTRAINT_LT | SQLITE_INDEX_CONSTRAINT_GE |
        -: 6983:    SQLITE_INDEX_CONSTRAINT_LE;
        -: 6984:
    #####: 6985:  pScan = idxMalloc(&rc, sizeof(IdxScan));
    #####: 6986:  if( pScan ){
        -: 6987:    int i;
        -: 6988:
        -: 6989:    /* Link the new scan object into the list */
    #####: 6990:    pScan->pTab = p->pTab;
    #####: 6991:    pScan->pNextScan = p->pExpert->pScan;
    #####: 6992:    p->pExpert->pScan = pScan;
        -: 6993:
        -: 6994:    /* Add the constraints to the IdxScan object */
    #####: 6995:    for(i=0; i<pIdxInfo->nConstraint; i++){
    #####: 6996:      struct sqlite3_index_constraint *pCons = &pIdxInfo->aConstraint[i];
    #####: 6997:      if( pCons->usable 
    #####: 6998:       && pCons->iColumn>=0 
    #####: 6999:       && p->pTab->aCol[pCons->iColumn].iPk==0
    #####: 7000:       && (pCons->op & opmask) 
        -: 7001:      ){
        -: 7002:        IdxConstraint *pNew;
    #####: 7003:        const char *zColl = sqlite3_vtab_collation(pIdxInfo, i);
    #####: 7004:        pNew = idxNewConstraint(&rc, zColl);
    #####: 7005:        if( pNew ){
    #####: 7006:          pNew->iCol = pCons->iColumn;
    #####: 7007:          if( pCons->op==SQLITE_INDEX_CONSTRAINT_EQ ){
    #####: 7008:            pNew->pNext = pScan->pEq;
    #####: 7009:            pScan->pEq = pNew;
        -: 7010:          }else{
    #####: 7011:            pNew->bRange = 1;
    #####: 7012:            pNew->pNext = pScan->pRange;
    #####: 7013:            pScan->pRange = pNew;
        -: 7014:          }
        -: 7015:        }
    #####: 7016:        n++;
    #####: 7017:        pIdxInfo->aConstraintUsage[i].argvIndex = n;
        -: 7018:      }
        -: 7019:    }
        -: 7020:
        -: 7021:    /* Add the ORDER BY to the IdxScan object */
    #####: 7022:    for(i=pIdxInfo->nOrderBy-1; i>=0; i--){
    #####: 7023:      int iCol = pIdxInfo->aOrderBy[i].iColumn;
    #####: 7024:      if( iCol>=0 ){
    #####: 7025:        IdxConstraint *pNew = idxNewConstraint(&rc, p->pTab->aCol[iCol].zColl);
    #####: 7026:        if( pNew ){
    #####: 7027:          pNew->iCol = iCol;
    #####: 7028:          pNew->bDesc = pIdxInfo->aOrderBy[i].desc;
    #####: 7029:          pNew->pNext = pScan->pOrder;
    #####: 7030:          pNew->pLink = pScan->pOrder;
    #####: 7031:          pScan->pOrder = pNew;
    #####: 7032:          n++;
        -: 7033:        }
        -: 7034:      }
        -: 7035:    }
        -: 7036:  }
        -: 7037:
    #####: 7038:  pIdxInfo->estimatedCost = 1000000.0 / (n+1);
    #####: 7039:  return rc;
        -: 7040:}
        -: 7041:
    #####: 7042:static int expertUpdate(
        -: 7043:  sqlite3_vtab *pVtab, 
        -: 7044:  int nData, 
        -: 7045:  sqlite3_value **azData, 
        -: 7046:  sqlite_int64 *pRowid
        -: 7047:){
        -: 7048:  (void)pVtab;
        -: 7049:  (void)nData;
        -: 7050:  (void)azData;
        -: 7051:  (void)pRowid;
    #####: 7052:  return SQLITE_OK;
        -: 7053:}
        -: 7054:
        -: 7055:/* 
        -: 7056:** Virtual table module xOpen method.
        -: 7057:*/
    #####: 7058:static int expertOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){
    #####: 7059:  int rc = SQLITE_OK;
        -: 7060:  ExpertCsr *pCsr;
        -: 7061:  (void)pVTab;
    #####: 7062:  pCsr = idxMalloc(&rc, sizeof(ExpertCsr));
    #####: 7063:  *ppCursor = (sqlite3_vtab_cursor*)pCsr;
    #####: 7064:  return rc;
        -: 7065:}
        -: 7066:
        -: 7067:/* 
        -: 7068:** Virtual table module xClose method.
        -: 7069:*/
    #####: 7070:static int expertClose(sqlite3_vtab_cursor *cur){
    #####: 7071:  ExpertCsr *pCsr = (ExpertCsr*)cur;
    #####: 7072:  sqlite3_finalize(pCsr->pData);
    #####: 7073:  sqlite3_free(pCsr);
    #####: 7074:  return SQLITE_OK;
        -: 7075:}
        -: 7076:
        -: 7077:/*
        -: 7078:** Virtual table module xEof method.
        -: 7079:**
        -: 7080:** Return non-zero if the cursor does not currently point to a valid 
        -: 7081:** record (i.e if the scan has finished), or zero otherwise.
        -: 7082:*/
    #####: 7083:static int expertEof(sqlite3_vtab_cursor *cur){
    #####: 7084:  ExpertCsr *pCsr = (ExpertCsr*)cur;
    #####: 7085:  return pCsr->pData==0;
        -: 7086:}
        -: 7087:
        -: 7088:/* 
        -: 7089:** Virtual table module xNext method.
        -: 7090:*/
    #####: 7091:static int expertNext(sqlite3_vtab_cursor *cur){
    #####: 7092:  ExpertCsr *pCsr = (ExpertCsr*)cur;
    #####: 7093:  int rc = SQLITE_OK;
        -: 7094:
        -: 7095:  assert( pCsr->pData );
    #####: 7096:  rc = sqlite3_step(pCsr->pData);
    #####: 7097:  if( rc!=SQLITE_ROW ){
    #####: 7098:    rc = sqlite3_finalize(pCsr->pData);
    #####: 7099:    pCsr->pData = 0;
        -: 7100:  }else{
    #####: 7101:    rc = SQLITE_OK;
        -: 7102:  }
        -: 7103:
    #####: 7104:  return rc;
        -: 7105:}
        -: 7106:
        -: 7107:/* 
        -: 7108:** Virtual table module xRowid method.
        -: 7109:*/
    #####: 7110:static int expertRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){
        -: 7111:  (void)cur;
    #####: 7112:  *pRowid = 0;
    #####: 7113:  return SQLITE_OK;
        -: 7114:}
        -: 7115:
        -: 7116:/* 
        -: 7117:** Virtual table module xColumn method.
        -: 7118:*/
    #####: 7119:static int expertColumn(sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int i){
    #####: 7120:  ExpertCsr *pCsr = (ExpertCsr*)cur;
        -: 7121:  sqlite3_value *pVal;
    #####: 7122:  pVal = sqlite3_column_value(pCsr->pData, i);
    #####: 7123:  if( pVal ){
    #####: 7124:    sqlite3_result_value(ctx, pVal);
        -: 7125:  }
    #####: 7126:  return SQLITE_OK;
        -: 7127:}
        -: 7128:
        -: 7129:/* 
        -: 7130:** Virtual table module xFilter method.
        -: 7131:*/
    #####: 7132:static int expertFilter(
        -: 7133:  sqlite3_vtab_cursor *cur, 
        -: 7134:  int idxNum, const char *idxStr,
        -: 7135:  int argc, sqlite3_value **argv
        -: 7136:){
    #####: 7137:  ExpertCsr *pCsr = (ExpertCsr*)cur;
    #####: 7138:  ExpertVtab *pVtab = (ExpertVtab*)(cur->pVtab);
    #####: 7139:  sqlite3expert *pExpert = pVtab->pExpert;
        -: 7140:  int rc;
        -: 7141:
        -: 7142:  (void)idxNum;
        -: 7143:  (void)idxStr;
        -: 7144:  (void)argc;
        -: 7145:  (void)argv;
    #####: 7146:  rc = sqlite3_finalize(pCsr->pData);
    #####: 7147:  pCsr->pData = 0;
    #####: 7148:  if( rc==SQLITE_OK ){
    #####: 7149:    rc = idxPrintfPrepareStmt(pExpert->db, &pCsr->pData, &pVtab->base.zErrMsg,
    #####: 7150:        "SELECT * FROM main.%Q WHERE sample()", pVtab->pTab->zName
        -: 7151:    );
        -: 7152:  }
        -: 7153:
    #####: 7154:  if( rc==SQLITE_OK ){
    #####: 7155:    rc = expertNext(cur);
        -: 7156:  }
    #####: 7157:  return rc;
        -: 7158:}
        -: 7159:
    #####: 7160:static int idxRegisterVtab(sqlite3expert *p){
        -: 7161:  static sqlite3_module expertModule = {
        -: 7162:    2,                            /* iVersion */
        -: 7163:    expertConnect,                /* xCreate - create a table */
        -: 7164:    expertConnect,                /* xConnect - connect to an existing table */
        -: 7165:    expertBestIndex,              /* xBestIndex - Determine search strategy */
        -: 7166:    expertDisconnect,             /* xDisconnect - Disconnect from a table */
        -: 7167:    expertDisconnect,             /* xDestroy - Drop a table */
        -: 7168:    expertOpen,                   /* xOpen - open a cursor */
        -: 7169:    expertClose,                  /* xClose - close a cursor */
        -: 7170:    expertFilter,                 /* xFilter - configure scan constraints */
        -: 7171:    expertNext,                   /* xNext - advance a cursor */
        -: 7172:    expertEof,                    /* xEof */
        -: 7173:    expertColumn,                 /* xColumn - read data */
        -: 7174:    expertRowid,                  /* xRowid - read data */
        -: 7175:    expertUpdate,                 /* xUpdate - write data */
        -: 7176:    0,                            /* xBegin - begin transaction */
        -: 7177:    0,                            /* xSync - sync transaction */
        -: 7178:    0,                            /* xCommit - commit transaction */
        -: 7179:    0,                            /* xRollback - rollback transaction */
        -: 7180:    0,                            /* xFindFunction - function overloading */
        -: 7181:    0,                            /* xRename - rename the table */
        -: 7182:    0,                            /* xSavepoint */
        -: 7183:    0,                            /* xRelease */
        -: 7184:    0,                            /* xRollbackTo */
        -: 7185:    0,                            /* xShadowName */
        -: 7186:  };
        -: 7187:
    #####: 7188:  return sqlite3_create_module(p->dbv, "expert", &expertModule, (void*)p);
        -: 7189:}
        -: 7190:/*
        -: 7191:** End of virtual table implementation.
        -: 7192:*************************************************************************/
        -: 7193:/*
        -: 7194:** Finalize SQL statement pStmt. If (*pRc) is SQLITE_OK when this function
        -: 7195:** is called, set it to the return value of sqlite3_finalize() before
        -: 7196:** returning. Otherwise, discard the sqlite3_finalize() return value.
        -: 7197:*/
    #####: 7198:static void idxFinalize(int *pRc, sqlite3_stmt *pStmt){
    #####: 7199:  int rc = sqlite3_finalize(pStmt);
    #####: 7200:  if( *pRc==SQLITE_OK ) *pRc = rc;
    #####: 7201:}
        -: 7202:
        -: 7203:/*
        -: 7204:** Attempt to allocate an IdxTable structure corresponding to table zTab
        -: 7205:** in the main database of connection db. If successful, set (*ppOut) to
        -: 7206:** point to the new object and return SQLITE_OK. Otherwise, return an
        -: 7207:** SQLite error code and set (*ppOut) to NULL. In this case *pzErrmsg may be
        -: 7208:** set to point to an error string.
        -: 7209:**
        -: 7210:** It is the responsibility of the caller to eventually free either the
        -: 7211:** IdxTable object or error message using sqlite3_free().
        -: 7212:*/
    #####: 7213:static int idxGetTableInfo(
        -: 7214:  sqlite3 *db,                    /* Database connection to read details from */
        -: 7215:  const char *zTab,               /* Table name */
        -: 7216:  IdxTable **ppOut,               /* OUT: New object (if successful) */
        -: 7217:  char **pzErrmsg                 /* OUT: Error message (if not) */
        -: 7218:){
    #####: 7219:  sqlite3_stmt *p1 = 0;
    #####: 7220:  int nCol = 0;
    #####: 7221:  int nTab = STRLEN(zTab);
    #####: 7222:  int nByte = sizeof(IdxTable) + nTab + 1;
    #####: 7223:  IdxTable *pNew = 0;
        -: 7224:  int rc, rc2;
    #####: 7225:  char *pCsr = 0;
        -: 7226:
    #####: 7227:  rc = idxPrintfPrepareStmt(db, &p1, pzErrmsg, "PRAGMA table_info=%Q", zTab);
    #####: 7228:  while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(p1) ){
    #####: 7229:    const char *zCol = (const char*)sqlite3_column_text(p1, 1);
    #####: 7230:    nByte += 1 + STRLEN(zCol);
    #####: 7231:    rc = sqlite3_table_column_metadata(
        -: 7232:        db, "main", zTab, zCol, 0, &zCol, 0, 0, 0
        -: 7233:    );
    #####: 7234:    nByte += 1 + STRLEN(zCol);
    #####: 7235:    nCol++;
        -: 7236:  }
    #####: 7237:  rc2 = sqlite3_reset(p1);
    #####: 7238:  if( rc==SQLITE_OK ) rc = rc2;
        -: 7239:
    #####: 7240:  nByte += sizeof(IdxColumn) * nCol;
    #####: 7241:  if( rc==SQLITE_OK ){
    #####: 7242:    pNew = idxMalloc(&rc, nByte);
        -: 7243:  }
    #####: 7244:  if( rc==SQLITE_OK ){
    #####: 7245:    pNew->aCol = (IdxColumn*)&pNew[1];
    #####: 7246:    pNew->nCol = nCol;
    #####: 7247:    pCsr = (char*)&pNew->aCol[nCol];
        -: 7248:  }
        -: 7249:
    #####: 7250:  nCol = 0;
    #####: 7251:  while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(p1) ){
    #####: 7252:    const char *zCol = (const char*)sqlite3_column_text(p1, 1);
    #####: 7253:    int nCopy = STRLEN(zCol) + 1;
    #####: 7254:    pNew->aCol[nCol].zName = pCsr;
    #####: 7255:    pNew->aCol[nCol].iPk = sqlite3_column_int(p1, 5);
    #####: 7256:    memcpy(pCsr, zCol, nCopy);
    #####: 7257:    pCsr += nCopy;
        -: 7258:
    #####: 7259:    rc = sqlite3_table_column_metadata(
        -: 7260:        db, "main", zTab, zCol, 0, &zCol, 0, 0, 0
        -: 7261:    );
    #####: 7262:    if( rc==SQLITE_OK ){
    #####: 7263:      nCopy = STRLEN(zCol) + 1;
    #####: 7264:      pNew->aCol[nCol].zColl = pCsr;
    #####: 7265:      memcpy(pCsr, zCol, nCopy);
    #####: 7266:      pCsr += nCopy;
        -: 7267:    }
        -: 7268:
    #####: 7269:    nCol++;
        -: 7270:  }
    #####: 7271:  idxFinalize(&rc, p1);
        -: 7272:
    #####: 7273:  if( rc!=SQLITE_OK ){
    #####: 7274:    sqlite3_free(pNew);
    #####: 7275:    pNew = 0;
        -: 7276:  }else{
    #####: 7277:    pNew->zName = pCsr;
    #####: 7278:    memcpy(pNew->zName, zTab, nTab+1);
        -: 7279:  }
        -: 7280:
    #####: 7281:  *ppOut = pNew;
    #####: 7282:  return rc;
        -: 7283:}
        -: 7284:
        -: 7285:/*
        -: 7286:** This function is a no-op if *pRc is set to anything other than 
        -: 7287:** SQLITE_OK when it is called.
        -: 7288:**
        -: 7289:** If *pRc is initially set to SQLITE_OK, then the text specified by
        -: 7290:** the printf() style arguments is appended to zIn and the result returned
        -: 7291:** in a buffer allocated by sqlite3_malloc(). sqlite3_free() is called on
        -: 7292:** zIn before returning.
        -: 7293:*/
    #####: 7294:static char *idxAppendText(int *pRc, char *zIn, const char *zFmt, ...){
        -: 7295:  va_list ap;
    #####: 7296:  char *zAppend = 0;
    #####: 7297:  char *zRet = 0;
    #####: 7298:  int nIn = zIn ? STRLEN(zIn) : 0;
    #####: 7299:  int nAppend = 0;
    #####: 7300:  va_start(ap, zFmt);
    #####: 7301:  if( *pRc==SQLITE_OK ){
    #####: 7302:    zAppend = sqlite3_vmprintf(zFmt, ap);
    #####: 7303:    if( zAppend ){
    #####: 7304:      nAppend = STRLEN(zAppend);
    #####: 7305:      zRet = (char*)sqlite3_malloc(nIn + nAppend + 1);
        -: 7306:    }
    #####: 7307:    if( zAppend && zRet ){
    #####: 7308:      if( nIn ) memcpy(zRet, zIn, nIn);
    #####: 7309:      memcpy(&zRet[nIn], zAppend, nAppend+1);
        -: 7310:    }else{
    #####: 7311:      sqlite3_free(zRet);
    #####: 7312:      zRet = 0;
    #####: 7313:      *pRc = SQLITE_NOMEM;
        -: 7314:    }
    #####: 7315:    sqlite3_free(zAppend);
    #####: 7316:    sqlite3_free(zIn);
        -: 7317:  }
    #####: 7318:  va_end(ap);
    #####: 7319:  return zRet;
        -: 7320:}
        -: 7321:
        -: 7322:/*
        -: 7323:** Return true if zId must be quoted in order to use it as an SQL
        -: 7324:** identifier, or false otherwise.
        -: 7325:*/
    #####: 7326:static int idxIdentifierRequiresQuotes(const char *zId){
        -: 7327:  int i;
    #####: 7328:  for(i=0; zId[i]; i++){
    #####: 7329:    if( !(zId[i]=='_')
    #####: 7330:     && !(zId[i]>='0' && zId[i]<='9')
    #####: 7331:     && !(zId[i]>='a' && zId[i]<='z')
    #####: 7332:     && !(zId[i]>='A' && zId[i]<='Z')
        -: 7333:    ){
    #####: 7334:      return 1;
        -: 7335:    }
        -: 7336:  }
    #####: 7337:  return 0;
        -: 7338:}
        -: 7339:
        -: 7340:/*
        -: 7341:** This function appends an index column definition suitable for constraint
        -: 7342:** pCons to the string passed as zIn and returns the result.
        -: 7343:*/
    #####: 7344:static char *idxAppendColDefn(
        -: 7345:  int *pRc,                       /* IN/OUT: Error code */
        -: 7346:  char *zIn,                      /* Column defn accumulated so far */
        -: 7347:  IdxTable *pTab,                 /* Table index will be created on */
        -: 7348:  IdxConstraint *pCons
        -: 7349:){
    #####: 7350:  char *zRet = zIn;
    #####: 7351:  IdxColumn *p = &pTab->aCol[pCons->iCol];
    #####: 7352:  if( zRet ) zRet = idxAppendText(pRc, zRet, ", ");
        -: 7353:
    #####: 7354:  if( idxIdentifierRequiresQuotes(p->zName) ){
    #####: 7355:    zRet = idxAppendText(pRc, zRet, "%Q", p->zName);
        -: 7356:  }else{
    #####: 7357:    zRet = idxAppendText(pRc, zRet, "%s", p->zName);
        -: 7358:  }
        -: 7359:
    #####: 7360:  if( sqlite3_stricmp(p->zColl, pCons->zColl) ){
    #####: 7361:    if( idxIdentifierRequiresQuotes(pCons->zColl) ){
    #####: 7362:      zRet = idxAppendText(pRc, zRet, " COLLATE %Q", pCons->zColl);
        -: 7363:    }else{
    #####: 7364:      zRet = idxAppendText(pRc, zRet, " COLLATE %s", pCons->zColl);
        -: 7365:    }
        -: 7366:  }
        -: 7367:
    #####: 7368:  if( pCons->bDesc ){
    #####: 7369:    zRet = idxAppendText(pRc, zRet, " DESC");
        -: 7370:  }
    #####: 7371:  return zRet;
        -: 7372:}
        -: 7373:
        -: 7374:/*
        -: 7375:** Search database dbm for an index compatible with the one idxCreateFromCons()
        -: 7376:** would create from arguments pScan, pEq and pTail. If no error occurs and 
        -: 7377:** such an index is found, return non-zero. Or, if no such index is found,
        -: 7378:** return zero.
        -: 7379:**
        -: 7380:** If an error occurs, set *pRc to an SQLite error code and return zero.
        -: 7381:*/
    #####: 7382:static int idxFindCompatible(
        -: 7383:  int *pRc,                       /* OUT: Error code */
        -: 7384:  sqlite3* dbm,                   /* Database to search */
        -: 7385:  IdxScan *pScan,                 /* Scan for table to search for index on */
        -: 7386:  IdxConstraint *pEq,             /* List of == constraints */
        -: 7387:  IdxConstraint *pTail            /* List of range constraints */
        -: 7388:){
    #####: 7389:  const char *zTbl = pScan->pTab->zName;
    #####: 7390:  sqlite3_stmt *pIdxList = 0;
        -: 7391:  IdxConstraint *pIter;
    #####: 7392:  int nEq = 0;                    /* Number of elements in pEq */
        -: 7393:  int rc;
        -: 7394:
        -: 7395:  /* Count the elements in list pEq */
    #####: 7396:  for(pIter=pEq; pIter; pIter=pIter->pLink) nEq++;
        -: 7397:
    #####: 7398:  rc = idxPrintfPrepareStmt(dbm, &pIdxList, 0, "PRAGMA index_list=%Q", zTbl);
    #####: 7399:  while( rc==SQLITE_OK && sqlite3_step(pIdxList)==SQLITE_ROW ){
    #####: 7400:    int bMatch = 1;
    #####: 7401:    IdxConstraint *pT = pTail;
    #####: 7402:    sqlite3_stmt *pInfo = 0;
    #####: 7403:    const char *zIdx = (const char*)sqlite3_column_text(pIdxList, 1);
        -: 7404:
        -: 7405:    /* Zero the IdxConstraint.bFlag values in the pEq list */
    #####: 7406:    for(pIter=pEq; pIter; pIter=pIter->pLink) pIter->bFlag = 0;
        -: 7407:
    #####: 7408:    rc = idxPrintfPrepareStmt(dbm, &pInfo, 0, "PRAGMA index_xInfo=%Q", zIdx);
    #####: 7409:    while( rc==SQLITE_OK && sqlite3_step(pInfo)==SQLITE_ROW ){
    #####: 7410:      int iIdx = sqlite3_column_int(pInfo, 0);
    #####: 7411:      int iCol = sqlite3_column_int(pInfo, 1);
    #####: 7412:      const char *zColl = (const char*)sqlite3_column_text(pInfo, 4);
        -: 7413:
    #####: 7414:      if( iIdx<nEq ){
    #####: 7415:        for(pIter=pEq; pIter; pIter=pIter->pLink){
    #####: 7416:          if( pIter->bFlag ) continue;
    #####: 7417:          if( pIter->iCol!=iCol ) continue;
    #####: 7418:          if( sqlite3_stricmp(pIter->zColl, zColl) ) continue;
    #####: 7419:          pIter->bFlag = 1;
    #####: 7420:          break;
        -: 7421:        }
    #####: 7422:        if( pIter==0 ){
    #####: 7423:          bMatch = 0;
    #####: 7424:          break;
        -: 7425:        }
        -: 7426:      }else{
    #####: 7427:        if( pT ){
    #####: 7428:          if( pT->iCol!=iCol || sqlite3_stricmp(pT->zColl, zColl) ){
    #####: 7429:            bMatch = 0;
    #####: 7430:            break;
        -: 7431:          }
    #####: 7432:          pT = pT->pLink;
        -: 7433:        }
        -: 7434:      }
        -: 7435:    }
    #####: 7436:    idxFinalize(&rc, pInfo);
        -: 7437:
    #####: 7438:    if( rc==SQLITE_OK && bMatch ){
    #####: 7439:      sqlite3_finalize(pIdxList);
    #####: 7440:      return 1;
        -: 7441:    }
        -: 7442:  }
    #####: 7443:  idxFinalize(&rc, pIdxList);
        -: 7444:
    #####: 7445:  *pRc = rc;
    #####: 7446:  return 0;
        -: 7447:}
        -: 7448:
    #####: 7449:static int idxCreateFromCons(
        -: 7450:  sqlite3expert *p,
        -: 7451:  IdxScan *pScan,
        -: 7452:  IdxConstraint *pEq, 
        -: 7453:  IdxConstraint *pTail
        -: 7454:){
    #####: 7455:  sqlite3 *dbm = p->dbm;
    #####: 7456:  int rc = SQLITE_OK;
    #####: 7457:  if( (pEq || pTail) && 0==idxFindCompatible(&rc, dbm, pScan, pEq, pTail) ){
    #####: 7458:    IdxTable *pTab = pScan->pTab;
    #####: 7459:    char *zCols = 0;
    #####: 7460:    char *zIdx = 0;
        -: 7461:    IdxConstraint *pCons;
    #####: 7462:    unsigned int h = 0;
        -: 7463:    const char *zFmt;
        -: 7464:
    #####: 7465:    for(pCons=pEq; pCons; pCons=pCons->pLink){
    #####: 7466:      zCols = idxAppendColDefn(&rc, zCols, pTab, pCons);
        -: 7467:    }
    #####: 7468:    for(pCons=pTail; pCons; pCons=pCons->pLink){
    #####: 7469:      zCols = idxAppendColDefn(&rc, zCols, pTab, pCons);
        -: 7470:    }
        -: 7471:
    #####: 7472:    if( rc==SQLITE_OK ){
        -: 7473:      /* Hash the list of columns to come up with a name for the index */
    #####: 7474:      const char *zTable = pScan->pTab->zName;
        -: 7475:      char *zName;                /* Index name */
        -: 7476:      int i;
    #####: 7477:      for(i=0; zCols[i]; i++){
    #####: 7478:        h += ((h<<3) + zCols[i]);
        -: 7479:      }
    #####: 7480:      zName = sqlite3_mprintf("%s_idx_%08x", zTable, h);
    #####: 7481:      if( zName==0 ){ 
    #####: 7482:        rc = SQLITE_NOMEM;
        -: 7483:      }else{
    #####: 7484:        if( idxIdentifierRequiresQuotes(zTable) ){
    #####: 7485:          zFmt = "CREATE INDEX '%q' ON %Q(%s)";
        -: 7486:        }else{
    #####: 7487:          zFmt = "CREATE INDEX %s ON %s(%s)";
        -: 7488:        }
    #####: 7489:        zIdx = sqlite3_mprintf(zFmt, zName, zTable, zCols);
    #####: 7490:        if( !zIdx ){
    #####: 7491:          rc = SQLITE_NOMEM;
        -: 7492:        }else{
    #####: 7493:          rc = sqlite3_exec(dbm, zIdx, 0, 0, p->pzErrmsg);
    #####: 7494:          idxHashAdd(&rc, &p->hIdx, zName, zIdx);
        -: 7495:        }
    #####: 7496:        sqlite3_free(zName);
    #####: 7497:        sqlite3_free(zIdx);
        -: 7498:      }
        -: 7499:    }
        -: 7500:
    #####: 7501:    sqlite3_free(zCols);
        -: 7502:  }
    #####: 7503:  return rc;
        -: 7504:}
        -: 7505:
        -: 7506:/*
        -: 7507:** Return true if list pList (linked by IdxConstraint.pLink) contains
        -: 7508:** a constraint compatible with *p. Otherwise return false.
        -: 7509:*/
    #####: 7510:static int idxFindConstraint(IdxConstraint *pList, IdxConstraint *p){
        -: 7511:  IdxConstraint *pCmp;
    #####: 7512:  for(pCmp=pList; pCmp; pCmp=pCmp->pLink){
    #####: 7513:    if( p->iCol==pCmp->iCol ) return 1;
        -: 7514:  }
    #####: 7515:  return 0;
        -: 7516:}
        -: 7517:
    #####: 7518:static int idxCreateFromWhere(
        -: 7519:  sqlite3expert *p, 
        -: 7520:  IdxScan *pScan,                 /* Create indexes for this scan */
        -: 7521:  IdxConstraint *pTail            /* range/ORDER BY constraints for inclusion */
        -: 7522:){
    #####: 7523:  IdxConstraint *p1 = 0;
        -: 7524:  IdxConstraint *pCon;
        -: 7525:  int rc;
        -: 7526:
        -: 7527:  /* Gather up all the == constraints. */
    #####: 7528:  for(pCon=pScan->pEq; pCon; pCon=pCon->pNext){
    #####: 7529:    if( !idxFindConstraint(p1, pCon) && !idxFindConstraint(pTail, pCon) ){
    #####: 7530:      pCon->pLink = p1;
    #####: 7531:      p1 = pCon;
        -: 7532:    }
        -: 7533:  }
        -: 7534:
        -: 7535:  /* Create an index using the == constraints collected above. And the
        -: 7536:  ** range constraint/ORDER BY terms passed in by the caller, if any. */
    #####: 7537:  rc = idxCreateFromCons(p, pScan, p1, pTail);
        -: 7538:
        -: 7539:  /* If no range/ORDER BY passed by the caller, create a version of the
        -: 7540:  ** index for each range constraint.  */
    #####: 7541:  if( pTail==0 ){
    #####: 7542:    for(pCon=pScan->pRange; rc==SQLITE_OK && pCon; pCon=pCon->pNext){
        -: 7543:      assert( pCon->pLink==0 );
    #####: 7544:      if( !idxFindConstraint(p1, pCon) && !idxFindConstraint(pTail, pCon) ){
    #####: 7545:        rc = idxCreateFromCons(p, pScan, p1, pCon);
        -: 7546:      }
        -: 7547:    }
        -: 7548:  }
        -: 7549:
    #####: 7550:  return rc;
        -: 7551:}
        -: 7552:
        -: 7553:/*
        -: 7554:** Create candidate indexes in database [dbm] based on the data in 
        -: 7555:** linked-list pScan.
        -: 7556:*/
    #####: 7557:static int idxCreateCandidates(sqlite3expert *p){
    #####: 7558:  int rc = SQLITE_OK;
        -: 7559:  IdxScan *pIter;
        -: 7560:
    #####: 7561:  for(pIter=p->pScan; pIter && rc==SQLITE_OK; pIter=pIter->pNextScan){
    #####: 7562:    rc = idxCreateFromWhere(p, pIter, 0);
    #####: 7563:    if( rc==SQLITE_OK && pIter->pOrder ){
    #####: 7564:      rc = idxCreateFromWhere(p, pIter, pIter->pOrder);
        -: 7565:    }
        -: 7566:  }
        -: 7567:
    #####: 7568:  return rc;
        -: 7569:}
        -: 7570:
        -: 7571:/*
        -: 7572:** Free all elements of the linked list starting at pConstraint.
        -: 7573:*/
    #####: 7574:static void idxConstraintFree(IdxConstraint *pConstraint){
        -: 7575:  IdxConstraint *pNext;
        -: 7576:  IdxConstraint *p;
        -: 7577:
    #####: 7578:  for(p=pConstraint; p; p=pNext){
    #####: 7579:    pNext = p->pNext;
    #####: 7580:    sqlite3_free(p);
        -: 7581:  }
    #####: 7582:}
        -: 7583:
        -: 7584:/*
        -: 7585:** Free all elements of the linked list starting from pScan up until pLast
        -: 7586:** (pLast is not freed).
        -: 7587:*/
    #####: 7588:static void idxScanFree(IdxScan *pScan, IdxScan *pLast){
        -: 7589:  IdxScan *p;
        -: 7590:  IdxScan *pNext;
    #####: 7591:  for(p=pScan; p!=pLast; p=pNext){
    #####: 7592:    pNext = p->pNextScan;
    #####: 7593:    idxConstraintFree(p->pOrder);
    #####: 7594:    idxConstraintFree(p->pEq);
    #####: 7595:    idxConstraintFree(p->pRange);
    #####: 7596:    sqlite3_free(p);
        -: 7597:  }
    #####: 7598:}
        -: 7599:
        -: 7600:/*
        -: 7601:** Free all elements of the linked list starting from pStatement up 
        -: 7602:** until pLast (pLast is not freed).
        -: 7603:*/
    #####: 7604:static void idxStatementFree(IdxStatement *pStatement, IdxStatement *pLast){
        -: 7605:  IdxStatement *p;
        -: 7606:  IdxStatement *pNext;
    #####: 7607:  for(p=pStatement; p!=pLast; p=pNext){
    #####: 7608:    pNext = p->pNext;
    #####: 7609:    sqlite3_free(p->zEQP);
    #####: 7610:    sqlite3_free(p->zIdx);
    #####: 7611:    sqlite3_free(p);
        -: 7612:  }
    #####: 7613:}
        -: 7614:
        -: 7615:/*
        -: 7616:** Free the linked list of IdxTable objects starting at pTab.
        -: 7617:*/
    #####: 7618:static void idxTableFree(IdxTable *pTab){
        -: 7619:  IdxTable *pIter;
        -: 7620:  IdxTable *pNext;
    #####: 7621:  for(pIter=pTab; pIter; pIter=pNext){
    #####: 7622:    pNext = pIter->pNext;
    #####: 7623:    sqlite3_free(pIter);
        -: 7624:  }
    #####: 7625:}
        -: 7626:
        -: 7627:/*
        -: 7628:** Free the linked list of IdxWrite objects starting at pTab.
        -: 7629:*/
    #####: 7630:static void idxWriteFree(IdxWrite *pTab){
        -: 7631:  IdxWrite *pIter;
        -: 7632:  IdxWrite *pNext;
    #####: 7633:  for(pIter=pTab; pIter; pIter=pNext){
    #####: 7634:    pNext = pIter->pNext;
    #####: 7635:    sqlite3_free(pIter);
        -: 7636:  }
    #####: 7637:}
        -: 7638:
        -: 7639:
        -: 7640:
        -: 7641:/*
        -: 7642:** This function is called after candidate indexes have been created. It
        -: 7643:** runs all the queries to see which indexes they prefer, and populates
        -: 7644:** IdxStatement.zIdx and IdxStatement.zEQP with the results.
        -: 7645:*/
    #####: 7646:int idxFindIndexes(
        -: 7647:  sqlite3expert *p,
        -: 7648:  char **pzErr                         /* OUT: Error message (sqlite3_malloc) */
        -: 7649:){
        -: 7650:  IdxStatement *pStmt;
    #####: 7651:  sqlite3 *dbm = p->dbm;
    #####: 7652:  int rc = SQLITE_OK;
        -: 7653:
        -: 7654:  IdxHash hIdx;
    #####: 7655:  idxHashInit(&hIdx);
        -: 7656:
    #####: 7657:  for(pStmt=p->pStatement; rc==SQLITE_OK && pStmt; pStmt=pStmt->pNext){
        -: 7658:    IdxHashEntry *pEntry;
    #####: 7659:    sqlite3_stmt *pExplain = 0;
    #####: 7660:    idxHashClear(&hIdx);
    #####: 7661:    rc = idxPrintfPrepareStmt(dbm, &pExplain, pzErr,
        -: 7662:        "EXPLAIN QUERY PLAN %s", pStmt->zSql
        -: 7663:    );
    #####: 7664:    while( rc==SQLITE_OK && sqlite3_step(pExplain)==SQLITE_ROW ){
        -: 7665:      /* int iId = sqlite3_column_int(pExplain, 0); */
        -: 7666:      /* int iParent = sqlite3_column_int(pExplain, 1); */
        -: 7667:      /* int iNotUsed = sqlite3_column_int(pExplain, 2); */
    #####: 7668:      const char *zDetail = (const char*)sqlite3_column_text(pExplain, 3);
    #####: 7669:      int nDetail = STRLEN(zDetail);
        -: 7670:      int i;
        -: 7671:
    #####: 7672:      for(i=0; i<nDetail; i++){
    #####: 7673:        const char *zIdx = 0;
    #####: 7674:        if( memcmp(&zDetail[i], " USING INDEX ", 13)==0 ){
    #####: 7675:          zIdx = &zDetail[i+13];
    #####: 7676:        }else if( memcmp(&zDetail[i], " USING COVERING INDEX ", 22)==0 ){
    #####: 7677:          zIdx = &zDetail[i+22];
        -: 7678:        }
    #####: 7679:        if( zIdx ){
        -: 7680:          const char *zSql;
    #####: 7681:          int nIdx = 0;
    #####: 7682:          while( zIdx[nIdx]!='\0' && (zIdx[nIdx]!=' ' || zIdx[nIdx+1]!='(') ){
    #####: 7683:            nIdx++;
        -: 7684:          }
    #####: 7685:          zSql = idxHashSearch(&p->hIdx, zIdx, nIdx);
    #####: 7686:          if( zSql ){
    #####: 7687:            idxHashAdd(&rc, &hIdx, zSql, 0);
    #####: 7688:            if( rc ) goto find_indexes_out;
        -: 7689:          }
    #####: 7690:          break;
        -: 7691:        }
        -: 7692:      }
        -: 7693:
    #####: 7694:      if( zDetail[0]!='-' ){
    #####: 7695:        pStmt->zEQP = idxAppendText(&rc, pStmt->zEQP, "%s\n", zDetail);
        -: 7696:      }
        -: 7697:    }
        -: 7698:
    #####: 7699:    for(pEntry=hIdx.pFirst; pEntry; pEntry=pEntry->pNext){
    #####: 7700:      pStmt->zIdx = idxAppendText(&rc, pStmt->zIdx, "%s;\n", pEntry->zKey);
        -: 7701:    }
        -: 7702:
    #####: 7703:    idxFinalize(&rc, pExplain);
        -: 7704:  }
        -: 7705:
    #####: 7706: find_indexes_out:
    #####: 7707:  idxHashClear(&hIdx);
    #####: 7708:  return rc;
        -: 7709:}
        -: 7710:
    #####: 7711:static int idxAuthCallback(
        -: 7712:  void *pCtx,
        -: 7713:  int eOp,
        -: 7714:  const char *z3,
        -: 7715:  const char *z4,
        -: 7716:  const char *zDb,
        -: 7717:  const char *zTrigger
        -: 7718:){
    #####: 7719:  int rc = SQLITE_OK;
        -: 7720:  (void)z4;
        -: 7721:  (void)zTrigger;
    #####: 7722:  if( eOp==SQLITE_INSERT || eOp==SQLITE_UPDATE || eOp==SQLITE_DELETE ){
    #####: 7723:    if( sqlite3_stricmp(zDb, "main")==0 ){
    #####: 7724:      sqlite3expert *p = (sqlite3expert*)pCtx;
        -: 7725:      IdxTable *pTab;
    #####: 7726:      for(pTab=p->pTable; pTab; pTab=pTab->pNext){
    #####: 7727:        if( 0==sqlite3_stricmp(z3, pTab->zName) ) break;
        -: 7728:      }
    #####: 7729:      if( pTab ){
        -: 7730:        IdxWrite *pWrite;
    #####: 7731:        for(pWrite=p->pWrite; pWrite; pWrite=pWrite->pNext){
    #####: 7732:          if( pWrite->pTab==pTab && pWrite->eOp==eOp ) break;
        -: 7733:        }
    #####: 7734:        if( pWrite==0 ){
    #####: 7735:          pWrite = idxMalloc(&rc, sizeof(IdxWrite));
    #####: 7736:          if( rc==SQLITE_OK ){
    #####: 7737:            pWrite->pTab = pTab;
    #####: 7738:            pWrite->eOp = eOp;
    #####: 7739:            pWrite->pNext = p->pWrite;
    #####: 7740:            p->pWrite = pWrite;
        -: 7741:          }
        -: 7742:        }
        -: 7743:      }
        -: 7744:    }
        -: 7745:  }
    #####: 7746:  return rc;
        -: 7747:}
        -: 7748:
    #####: 7749:static int idxProcessOneTrigger(
        -: 7750:  sqlite3expert *p, 
        -: 7751:  IdxWrite *pWrite, 
        -: 7752:  char **pzErr
        -: 7753:){
        -: 7754:  static const char *zInt = UNIQUE_TABLE_NAME;
        -: 7755:  static const char *zDrop = "DROP TABLE " UNIQUE_TABLE_NAME;
    #####: 7756:  IdxTable *pTab = pWrite->pTab;
    #####: 7757:  const char *zTab = pTab->zName;
    #####: 7758:  const char *zSql = 
        -: 7759:    "SELECT 'CREATE TEMP' || substr(sql, 7) FROM sqlite_master "
        -: 7760:    "WHERE tbl_name = %Q AND type IN ('table', 'trigger') "
        -: 7761:    "ORDER BY type;";
    #####: 7762:  sqlite3_stmt *pSelect = 0;
    #####: 7763:  int rc = SQLITE_OK;
    #####: 7764:  char *zWrite = 0;
        -: 7765:
        -: 7766:  /* Create the table and its triggers in the temp schema */
    #####: 7767:  rc = idxPrintfPrepareStmt(p->db, &pSelect, pzErr, zSql, zTab, zTab);
    #####: 7768:  while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pSelect) ){
    #####: 7769:    const char *zCreate = (const char*)sqlite3_column_text(pSelect, 0);
    #####: 7770:    rc = sqlite3_exec(p->dbv, zCreate, 0, 0, pzErr);
        -: 7771:  }
    #####: 7772:  idxFinalize(&rc, pSelect);
        -: 7773:
        -: 7774:  /* Rename the table in the temp schema to zInt */
    #####: 7775:  if( rc==SQLITE_OK ){
    #####: 7776:    char *z = sqlite3_mprintf("ALTER TABLE temp.%Q RENAME TO %Q", zTab, zInt);
    #####: 7777:    if( z==0 ){
    #####: 7778:      rc = SQLITE_NOMEM;
        -: 7779:    }else{
    #####: 7780:      rc = sqlite3_exec(p->dbv, z, 0, 0, pzErr);
    #####: 7781:      sqlite3_free(z);
        -: 7782:    }
        -: 7783:  }
        -: 7784:
    #####: 7785:  switch( pWrite->eOp ){
    #####: 7786:    case SQLITE_INSERT: {
        -: 7787:      int i;
    #####: 7788:      zWrite = idxAppendText(&rc, zWrite, "INSERT INTO %Q VALUES(", zInt);
    #####: 7789:      for(i=0; i<pTab->nCol; i++){
    #####: 7790:        zWrite = idxAppendText(&rc, zWrite, "%s?", i==0 ? "" : ", ");
        -: 7791:      }
    #####: 7792:      zWrite = idxAppendText(&rc, zWrite, ")");
    #####: 7793:      break;
        -: 7794:    }
    #####: 7795:    case SQLITE_UPDATE: {
        -: 7796:      int i;
    #####: 7797:      zWrite = idxAppendText(&rc, zWrite, "UPDATE %Q SET ", zInt);
    #####: 7798:      for(i=0; i<pTab->nCol; i++){
    #####: 7799:        zWrite = idxAppendText(&rc, zWrite, "%s%Q=?", i==0 ? "" : ", ", 
    #####: 7800:            pTab->aCol[i].zName
        -: 7801:        );
        -: 7802:      }
    #####: 7803:      break;
        -: 7804:    }
    #####: 7805:    default: {
        -: 7806:      assert( pWrite->eOp==SQLITE_DELETE );
    #####: 7807:      if( rc==SQLITE_OK ){
    #####: 7808:        zWrite = sqlite3_mprintf("DELETE FROM %Q", zInt);
    #####: 7809:        if( zWrite==0 ) rc = SQLITE_NOMEM;
        -: 7810:      }
        -: 7811:    }
        -: 7812:  }
        -: 7813:
    #####: 7814:  if( rc==SQLITE_OK ){
    #####: 7815:    sqlite3_stmt *pX = 0;
    #####: 7816:    rc = sqlite3_prepare_v2(p->dbv, zWrite, -1, &pX, 0);
    #####: 7817:    idxFinalize(&rc, pX);
    #####: 7818:    if( rc!=SQLITE_OK ){
    #####: 7819:      idxDatabaseError(p->dbv, pzErr);
        -: 7820:    }
        -: 7821:  }
    #####: 7822:  sqlite3_free(zWrite);
        -: 7823:
    #####: 7824:  if( rc==SQLITE_OK ){
    #####: 7825:    rc = sqlite3_exec(p->dbv, zDrop, 0, 0, pzErr);
        -: 7826:  }
        -: 7827:
    #####: 7828:  return rc;
        -: 7829:}
        -: 7830:
    #####: 7831:static int idxProcessTriggers(sqlite3expert *p, char **pzErr){
    #####: 7832:  int rc = SQLITE_OK;
    #####: 7833:  IdxWrite *pEnd = 0;
    #####: 7834:  IdxWrite *pFirst = p->pWrite;
        -: 7835:
    #####: 7836:  while( rc==SQLITE_OK && pFirst!=pEnd ){
        -: 7837:    IdxWrite *pIter;
    #####: 7838:    for(pIter=pFirst; rc==SQLITE_OK && pIter!=pEnd; pIter=pIter->pNext){
    #####: 7839:      rc = idxProcessOneTrigger(p, pIter, pzErr);
        -: 7840:    }
    #####: 7841:    pEnd = pFirst;
    #####: 7842:    pFirst = p->pWrite;
        -: 7843:  }
        -: 7844:
    #####: 7845:  return rc;
        -: 7846:}
        -: 7847:
        -: 7848:
    #####: 7849:static int idxCreateVtabSchema(sqlite3expert *p, char **pzErrmsg){
    #####: 7850:  int rc = idxRegisterVtab(p);
    #####: 7851:  sqlite3_stmt *pSchema = 0;
        -: 7852:
        -: 7853:  /* For each table in the main db schema:
        -: 7854:  **
        -: 7855:  **   1) Add an entry to the p->pTable list, and
        -: 7856:  **   2) Create the equivalent virtual table in dbv.
        -: 7857:  */
    #####: 7858:  rc = idxPrepareStmt(p->db, &pSchema, pzErrmsg,
        -: 7859:      "SELECT type, name, sql, 1 FROM sqlite_master "
        -: 7860:      "WHERE type IN ('table','view') AND name NOT LIKE 'sqlite_%%' "
        -: 7861:      " UNION ALL "
        -: 7862:      "SELECT type, name, sql, 2 FROM sqlite_master "
        -: 7863:      "WHERE type = 'trigger'"
        -: 7864:      "  AND tbl_name IN(SELECT name FROM sqlite_master WHERE type = 'view') "
        -: 7865:      "ORDER BY 4, 1"
        -: 7866:  );
    #####: 7867:  while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pSchema) ){
    #####: 7868:    const char *zType = (const char*)sqlite3_column_text(pSchema, 0);
    #####: 7869:    const char *zName = (const char*)sqlite3_column_text(pSchema, 1);
    #####: 7870:    const char *zSql = (const char*)sqlite3_column_text(pSchema, 2);
        -: 7871:
    #####: 7872:    if( zType[0]=='v' || zType[1]=='r' ){
    #####: 7873:      rc = sqlite3_exec(p->dbv, zSql, 0, 0, pzErrmsg);
        -: 7874:    }else{
        -: 7875:      IdxTable *pTab;
    #####: 7876:      rc = idxGetTableInfo(p->db, zName, &pTab, pzErrmsg);
    #####: 7877:      if( rc==SQLITE_OK ){
        -: 7878:        int i;
    #####: 7879:        char *zInner = 0;
    #####: 7880:        char *zOuter = 0;
    #####: 7881:        pTab->pNext = p->pTable;
    #####: 7882:        p->pTable = pTab;
        -: 7883:
        -: 7884:        /* The statement the vtab will pass to sqlite3_declare_vtab() */
    #####: 7885:        zInner = idxAppendText(&rc, 0, "CREATE TABLE x(");
    #####: 7886:        for(i=0; i<pTab->nCol; i++){
    #####: 7887:          zInner = idxAppendText(&rc, zInner, "%s%Q COLLATE %s", 
    #####: 7888:              (i==0 ? "" : ", "), pTab->aCol[i].zName, pTab->aCol[i].zColl
        -: 7889:          );
        -: 7890:        }
    #####: 7891:        zInner = idxAppendText(&rc, zInner, ")");
        -: 7892:
        -: 7893:        /* The CVT statement to create the vtab */
    #####: 7894:        zOuter = idxAppendText(&rc, 0, 
        -: 7895:            "CREATE VIRTUAL TABLE %Q USING expert(%Q)", zName, zInner
        -: 7896:        );
    #####: 7897:        if( rc==SQLITE_OK ){
    #####: 7898:          rc = sqlite3_exec(p->dbv, zOuter, 0, 0, pzErrmsg);
        -: 7899:        }
    #####: 7900:        sqlite3_free(zInner);
    #####: 7901:        sqlite3_free(zOuter);
        -: 7902:      }
        -: 7903:    }
        -: 7904:  }
    #####: 7905:  idxFinalize(&rc, pSchema);
    #####: 7906:  return rc;
        -: 7907:}
        -: 7908:
        -: 7909:struct IdxSampleCtx {
        -: 7910:  int iTarget;
        -: 7911:  double target;                  /* Target nRet/nRow value */
        -: 7912:  double nRow;                    /* Number of rows seen */
        -: 7913:  double nRet;                    /* Number of rows returned */
        -: 7914:};
        -: 7915:
    #####: 7916:static void idxSampleFunc(
        -: 7917:  sqlite3_context *pCtx,
        -: 7918:  int argc,
        -: 7919:  sqlite3_value **argv
        -: 7920:){
    #####: 7921:  struct IdxSampleCtx *p = (struct IdxSampleCtx*)sqlite3_user_data(pCtx);
        -: 7922:  int bRet;
        -: 7923:
        -: 7924:  (void)argv;
        -: 7925:  assert( argc==0 );
    #####: 7926:  if( p->nRow==0.0 ){
    #####: 7927:    bRet = 1;
        -: 7928:  }else{
    #####: 7929:    bRet = (p->nRet / p->nRow) <= p->target;
    #####: 7930:    if( bRet==0 ){
        -: 7931:      unsigned short rnd;
    #####: 7932:      sqlite3_randomness(2, (void*)&rnd);
    #####: 7933:      bRet = ((int)rnd % 100) <= p->iTarget;
        -: 7934:    }
        -: 7935:  }
        -: 7936:
    #####: 7937:  sqlite3_result_int(pCtx, bRet);
    #####: 7938:  p->nRow += 1.0;
    #####: 7939:  p->nRet += (double)bRet;
    #####: 7940:}
        -: 7941:
        -: 7942:struct IdxRemCtx {
        -: 7943:  int nSlot;
        -: 7944:  struct IdxRemSlot {
        -: 7945:    int eType;                    /* SQLITE_NULL, INTEGER, REAL, TEXT, BLOB */
        -: 7946:    i64 iVal;                     /* SQLITE_INTEGER value */
        -: 7947:    double rVal;                  /* SQLITE_FLOAT value */
        -: 7948:    int nByte;                    /* Bytes of space allocated at z */
        -: 7949:    int n;                        /* Size of buffer z */
        -: 7950:    char *z;                      /* SQLITE_TEXT/BLOB value */
        -: 7951:  } aSlot[1];
        -: 7952:};
        -: 7953:
        -: 7954:/*
        -: 7955:** Implementation of scalar function rem().
        -: 7956:*/
    #####: 7957:static void idxRemFunc(
        -: 7958:  sqlite3_context *pCtx,
        -: 7959:  int argc,
        -: 7960:  sqlite3_value **argv
        -: 7961:){
    #####: 7962:  struct IdxRemCtx *p = (struct IdxRemCtx*)sqlite3_user_data(pCtx);
        -: 7963:  struct IdxRemSlot *pSlot;
        -: 7964:  int iSlot;
        -: 7965:  assert( argc==2 );
        -: 7966:
    #####: 7967:  iSlot = sqlite3_value_int(argv[0]);
        -: 7968:  assert( iSlot<=p->nSlot );
    #####: 7969:  pSlot = &p->aSlot[iSlot];
        -: 7970:
    #####: 7971:  switch( pSlot->eType ){
    #####: 7972:    case SQLITE_NULL:
        -: 7973:      /* no-op */
    #####: 7974:      break;
        -: 7975:
    #####: 7976:    case SQLITE_INTEGER:
    #####: 7977:      sqlite3_result_int64(pCtx, pSlot->iVal);
    #####: 7978:      break;
        -: 7979:
    #####: 7980:    case SQLITE_FLOAT:
    #####: 7981:      sqlite3_result_double(pCtx, pSlot->rVal);
    #####: 7982:      break;
        -: 7983:
    #####: 7984:    case SQLITE_BLOB:
    #####: 7985:      sqlite3_result_blob(pCtx, pSlot->z, pSlot->n, SQLITE_TRANSIENT);
    #####: 7986:      break;
        -: 7987:
    #####: 7988:    case SQLITE_TEXT:
    #####: 7989:      sqlite3_result_text(pCtx, pSlot->z, pSlot->n, SQLITE_TRANSIENT);
    #####: 7990:      break;
        -: 7991:  }
        -: 7992:
    #####: 7993:  pSlot->eType = sqlite3_value_type(argv[1]);
    #####: 7994:  switch( pSlot->eType ){
    #####: 7995:    case SQLITE_NULL:
        -: 7996:      /* no-op */
    #####: 7997:      break;
        -: 7998:
    #####: 7999:    case SQLITE_INTEGER:
    #####: 8000:      pSlot->iVal = sqlite3_value_int64(argv[1]);
    #####: 8001:      break;
        -: 8002:
    #####: 8003:    case SQLITE_FLOAT:
    #####: 8004:      pSlot->rVal = sqlite3_value_double(argv[1]);
    #####: 8005:      break;
        -: 8006:
    #####: 8007:    case SQLITE_BLOB:
        -: 8008:    case SQLITE_TEXT: {
    #####: 8009:      int nByte = sqlite3_value_bytes(argv[1]);
    #####: 8010:      if( nByte>pSlot->nByte ){
    #####: 8011:        char *zNew = (char*)sqlite3_realloc(pSlot->z, nByte*2);
    #####: 8012:        if( zNew==0 ){
    #####: 8013:          sqlite3_result_error_nomem(pCtx);
    #####: 8014:          return;
        -: 8015:        }
    #####: 8016:        pSlot->nByte = nByte*2;
    #####: 8017:        pSlot->z = zNew;
        -: 8018:      }
    #####: 8019:      pSlot->n = nByte;
    #####: 8020:      if( pSlot->eType==SQLITE_BLOB ){
    #####: 8021:        memcpy(pSlot->z, sqlite3_value_blob(argv[1]), nByte);
        -: 8022:      }else{
    #####: 8023:        memcpy(pSlot->z, sqlite3_value_text(argv[1]), nByte);
        -: 8024:      }
    #####: 8025:      break;
        -: 8026:    }
        -: 8027:  }
        -: 8028:}
        -: 8029:
    #####: 8030:static int idxLargestIndex(sqlite3 *db, int *pnMax, char **pzErr){
    #####: 8031:  int rc = SQLITE_OK;
    #####: 8032:  const char *zMax = 
        -: 8033:    "SELECT max(i.seqno) FROM "
        -: 8034:    "  sqlite_master AS s, "
        -: 8035:    "  pragma_index_list(s.name) AS l, "
        -: 8036:    "  pragma_index_info(l.name) AS i "
        -: 8037:    "WHERE s.type = 'table'";
    #####: 8038:  sqlite3_stmt *pMax = 0;
        -: 8039:
    #####: 8040:  *pnMax = 0;
    #####: 8041:  rc = idxPrepareStmt(db, &pMax, pzErr, zMax);
    #####: 8042:  if( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pMax) ){
    #####: 8043:    *pnMax = sqlite3_column_int(pMax, 0) + 1;
        -: 8044:  }
    #####: 8045:  idxFinalize(&rc, pMax);
        -: 8046:
    #####: 8047:  return rc;
        -: 8048:}
        -: 8049:
    #####: 8050:static int idxPopulateOneStat1(
        -: 8051:  sqlite3expert *p,
        -: 8052:  sqlite3_stmt *pIndexXInfo,
        -: 8053:  sqlite3_stmt *pWriteStat,
        -: 8054:  const char *zTab,
        -: 8055:  const char *zIdx,
        -: 8056:  char **pzErr
        -: 8057:){
    #####: 8058:  char *zCols = 0;
    #####: 8059:  char *zOrder = 0;
    #####: 8060:  char *zQuery = 0;
    #####: 8061:  int nCol = 0;
        -: 8062:  int i;
    #####: 8063:  sqlite3_stmt *pQuery = 0;
    #####: 8064:  int *aStat = 0;
    #####: 8065:  int rc = SQLITE_OK;
        -: 8066:
        -: 8067:  assert( p->iSample>0 );
        -: 8068:
        -: 8069:  /* Formulate the query text */
    #####: 8070:  sqlite3_bind_text(pIndexXInfo, 1, zIdx, -1, SQLITE_STATIC);
    #####: 8071:  while( SQLITE_OK==rc && SQLITE_ROW==sqlite3_step(pIndexXInfo) ){
    #####: 8072:    const char *zComma = zCols==0 ? "" : ", ";
    #####: 8073:    const char *zName = (const char*)sqlite3_column_text(pIndexXInfo, 0);
    #####: 8074:    const char *zColl = (const char*)sqlite3_column_text(pIndexXInfo, 1);
    #####: 8075:    zCols = idxAppendText(&rc, zCols, 
        -: 8076:        "%sx.%Q IS rem(%d, x.%Q) COLLATE %s", zComma, zName, nCol, zName, zColl
        -: 8077:    );
    #####: 8078:    zOrder = idxAppendText(&rc, zOrder, "%s%d", zComma, ++nCol);
        -: 8079:  }
    #####: 8080:  sqlite3_reset(pIndexXInfo);
    #####: 8081:  if( rc==SQLITE_OK ){
    #####: 8082:    if( p->iSample==100 ){
    #####: 8083:      zQuery = sqlite3_mprintf(
        -: 8084:          "SELECT %s FROM %Q x ORDER BY %s", zCols, zTab, zOrder
        -: 8085:      );
        -: 8086:    }else{
    #####: 8087:      zQuery = sqlite3_mprintf(
        -: 8088:          "SELECT %s FROM temp."UNIQUE_TABLE_NAME" x ORDER BY %s", zCols, zOrder
        -: 8089:      );
        -: 8090:    }
        -: 8091:  }
    #####: 8092:  sqlite3_free(zCols);
    #####: 8093:  sqlite3_free(zOrder);
        -: 8094:
        -: 8095:  /* Formulate the query text */
    #####: 8096:  if( rc==SQLITE_OK ){
    #####: 8097:    sqlite3 *dbrem = (p->iSample==100 ? p->db : p->dbv);
    #####: 8098:    rc = idxPrepareStmt(dbrem, &pQuery, pzErr, zQuery);
        -: 8099:  }
    #####: 8100:  sqlite3_free(zQuery);
        -: 8101:
    #####: 8102:  if( rc==SQLITE_OK ){
    #####: 8103:    aStat = (int*)idxMalloc(&rc, sizeof(int)*(nCol+1));
        -: 8104:  }
    #####: 8105:  if( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pQuery) ){
        -: 8106:    IdxHashEntry *pEntry;
    #####: 8107:    char *zStat = 0;
    #####: 8108:    for(i=0; i<=nCol; i++) aStat[i] = 1;
    #####: 8109:    while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pQuery) ){
    #####: 8110:      aStat[0]++;
    #####: 8111:      for(i=0; i<nCol; i++){
    #####: 8112:        if( sqlite3_column_int(pQuery, i)==0 ) break;
        -: 8113:      }
    #####: 8114:      for(/*no-op*/; i<nCol; i++){
    #####: 8115:        aStat[i+1]++;
        -: 8116:      }
        -: 8117:    }
        -: 8118:
    #####: 8119:    if( rc==SQLITE_OK ){
    #####: 8120:      int s0 = aStat[0];
    #####: 8121:      zStat = sqlite3_mprintf("%d", s0);
    #####: 8122:      if( zStat==0 ) rc = SQLITE_NOMEM;
    #####: 8123:      for(i=1; rc==SQLITE_OK && i<=nCol; i++){
    #####: 8124:        zStat = idxAppendText(&rc, zStat, " %d", (s0+aStat[i]/2) / aStat[i]);
        -: 8125:      }
        -: 8126:    }
        -: 8127:
    #####: 8128:    if( rc==SQLITE_OK ){
    #####: 8129:      sqlite3_bind_text(pWriteStat, 1, zTab, -1, SQLITE_STATIC);
    #####: 8130:      sqlite3_bind_text(pWriteStat, 2, zIdx, -1, SQLITE_STATIC);
    #####: 8131:      sqlite3_bind_text(pWriteStat, 3, zStat, -1, SQLITE_STATIC);
    #####: 8132:      sqlite3_step(pWriteStat);
    #####: 8133:      rc = sqlite3_reset(pWriteStat);
        -: 8134:    }
        -: 8135:
    #####: 8136:    pEntry = idxHashFind(&p->hIdx, zIdx, STRLEN(zIdx));
    #####: 8137:    if( pEntry ){
        -: 8138:      assert( pEntry->zVal2==0 );
    #####: 8139:      pEntry->zVal2 = zStat;
        -: 8140:    }else{
    #####: 8141:      sqlite3_free(zStat);
        -: 8142:    }
        -: 8143:  }
    #####: 8144:  sqlite3_free(aStat);
    #####: 8145:  idxFinalize(&rc, pQuery);
        -: 8146:
    #####: 8147:  return rc;
        -: 8148:}
        -: 8149:
    #####: 8150:static int idxBuildSampleTable(sqlite3expert *p, const char *zTab){
        -: 8151:  int rc;
        -: 8152:  char *zSql;
        -: 8153:
    #####: 8154:  rc = sqlite3_exec(p->dbv,"DROP TABLE IF EXISTS temp."UNIQUE_TABLE_NAME,0,0,0);
    #####: 8155:  if( rc!=SQLITE_OK ) return rc;
        -: 8156:
    #####: 8157:  zSql = sqlite3_mprintf(
        -: 8158:      "CREATE TABLE temp." UNIQUE_TABLE_NAME " AS SELECT * FROM %Q", zTab
        -: 8159:  );
    #####: 8160:  if( zSql==0 ) return SQLITE_NOMEM;
    #####: 8161:  rc = sqlite3_exec(p->dbv, zSql, 0, 0, 0);
    #####: 8162:  sqlite3_free(zSql);
        -: 8163:
    #####: 8164:  return rc;
        -: 8165:}
        -: 8166:
        -: 8167:/*
        -: 8168:** This function is called as part of sqlite3_expert_analyze(). Candidate
        -: 8169:** indexes have already been created in database sqlite3expert.dbm, this
        -: 8170:** function populates sqlite_stat1 table in the same database.
        -: 8171:**
        -: 8172:** The stat1 data is generated by querying the 
        -: 8173:*/
    #####: 8174:static int idxPopulateStat1(sqlite3expert *p, char **pzErr){
    #####: 8175:  int rc = SQLITE_OK;
    #####: 8176:  int nMax =0;
    #####: 8177:  struct IdxRemCtx *pCtx = 0;
        -: 8178:  struct IdxSampleCtx samplectx; 
        -: 8179:  int i;
    #####: 8180:  i64 iPrev = -100000;
    #####: 8181:  sqlite3_stmt *pAllIndex = 0;
    #####: 8182:  sqlite3_stmt *pIndexXInfo = 0;
    #####: 8183:  sqlite3_stmt *pWrite = 0;
        -: 8184:
    #####: 8185:  const char *zAllIndex =
        -: 8186:    "SELECT s.rowid, s.name, l.name FROM "
        -: 8187:    "  sqlite_master AS s, "
        -: 8188:    "  pragma_index_list(s.name) AS l "
        -: 8189:    "WHERE s.type = 'table'";
    #####: 8190:  const char *zIndexXInfo = 
        -: 8191:    "SELECT name, coll FROM pragma_index_xinfo(?) WHERE key";
    #####: 8192:  const char *zWrite = "INSERT INTO sqlite_stat1 VALUES(?, ?, ?)";
        -: 8193:
        -: 8194:  /* If iSample==0, no sqlite_stat1 data is required. */
    #####: 8195:  if( p->iSample==0 ) return SQLITE_OK;
        -: 8196:
    #####: 8197:  rc = idxLargestIndex(p->dbm, &nMax, pzErr);
    #####: 8198:  if( nMax<=0 || rc!=SQLITE_OK ) return rc;
        -: 8199:
    #####: 8200:  rc = sqlite3_exec(p->dbm, "ANALYZE; PRAGMA writable_schema=1", 0, 0, 0);
        -: 8201:
    #####: 8202:  if( rc==SQLITE_OK ){
    #####: 8203:    int nByte = sizeof(struct IdxRemCtx) + (sizeof(struct IdxRemSlot) * nMax);
    #####: 8204:    pCtx = (struct IdxRemCtx*)idxMalloc(&rc, nByte);
        -: 8205:  }
        -: 8206:
    #####: 8207:  if( rc==SQLITE_OK ){
    #####: 8208:    sqlite3 *dbrem = (p->iSample==100 ? p->db : p->dbv);
    #####: 8209:    rc = sqlite3_create_function(
        -: 8210:        dbrem, "rem", 2, SQLITE_UTF8, (void*)pCtx, idxRemFunc, 0, 0
        -: 8211:    );
        -: 8212:  }
    #####: 8213:  if( rc==SQLITE_OK ){
    #####: 8214:    rc = sqlite3_create_function(
        -: 8215:        p->db, "sample", 0, SQLITE_UTF8, (void*)&samplectx, idxSampleFunc, 0, 0
        -: 8216:    );
        -: 8217:  }
        -: 8218:
    #####: 8219:  if( rc==SQLITE_OK ){
    #####: 8220:    pCtx->nSlot = nMax+1;
    #####: 8221:    rc = idxPrepareStmt(p->dbm, &pAllIndex, pzErr, zAllIndex);
        -: 8222:  }
    #####: 8223:  if( rc==SQLITE_OK ){
    #####: 8224:    rc = idxPrepareStmt(p->dbm, &pIndexXInfo, pzErr, zIndexXInfo);
        -: 8225:  }
    #####: 8226:  if( rc==SQLITE_OK ){
    #####: 8227:    rc = idxPrepareStmt(p->dbm, &pWrite, pzErr, zWrite);
        -: 8228:  }
        -: 8229:
    #####: 8230:  while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pAllIndex) ){
    #####: 8231:    i64 iRowid = sqlite3_column_int64(pAllIndex, 0);
    #####: 8232:    const char *zTab = (const char*)sqlite3_column_text(pAllIndex, 1);
    #####: 8233:    const char *zIdx = (const char*)sqlite3_column_text(pAllIndex, 2);
    #####: 8234:    if( p->iSample<100 && iPrev!=iRowid ){
    #####: 8235:      samplectx.target = (double)p->iSample / 100.0;
    #####: 8236:      samplectx.iTarget = p->iSample;
    #####: 8237:      samplectx.nRow = 0.0;
    #####: 8238:      samplectx.nRet = 0.0;
    #####: 8239:      rc = idxBuildSampleTable(p, zTab);
    #####: 8240:      if( rc!=SQLITE_OK ) break;
        -: 8241:    }
    #####: 8242:    rc = idxPopulateOneStat1(p, pIndexXInfo, pWrite, zTab, zIdx, pzErr);
    #####: 8243:    iPrev = iRowid;
        -: 8244:  }
    #####: 8245:  if( rc==SQLITE_OK && p->iSample<100 ){
    #####: 8246:    rc = sqlite3_exec(p->dbv, 
        -: 8247:        "DROP TABLE IF EXISTS temp." UNIQUE_TABLE_NAME, 0,0,0
        -: 8248:    );
        -: 8249:  }
        -: 8250:
    #####: 8251:  idxFinalize(&rc, pAllIndex);
    #####: 8252:  idxFinalize(&rc, pIndexXInfo);
    #####: 8253:  idxFinalize(&rc, pWrite);
        -: 8254:
    #####: 8255:  for(i=0; i<pCtx->nSlot; i++){
    #####: 8256:    sqlite3_free(pCtx->aSlot[i].z);
        -: 8257:  }
    #####: 8258:  sqlite3_free(pCtx);
        -: 8259:
    #####: 8260:  if( rc==SQLITE_OK ){
    #####: 8261:    rc = sqlite3_exec(p->dbm, "ANALYZE sqlite_master", 0, 0, 0);
        -: 8262:  }
        -: 8263:
    #####: 8264:  sqlite3_exec(p->db, "DROP TABLE IF EXISTS temp."UNIQUE_TABLE_NAME,0,0,0);
    #####: 8265:  return rc;
        -: 8266:}
        -: 8267:
        -: 8268:/*
        -: 8269:** Allocate a new sqlite3expert object.
        -: 8270:*/
    #####: 8271:sqlite3expert *sqlite3_expert_new(sqlite3 *db, char **pzErrmsg){
    #####: 8272:  int rc = SQLITE_OK;
        -: 8273:  sqlite3expert *pNew;
        -: 8274:
    #####: 8275:  pNew = (sqlite3expert*)idxMalloc(&rc, sizeof(sqlite3expert));
        -: 8276:
        -: 8277:  /* Open two in-memory databases to work with. The "vtab database" (dbv)
        -: 8278:  ** will contain a virtual table corresponding to each real table in
        -: 8279:  ** the user database schema, and a copy of each view. It is used to
        -: 8280:  ** collect information regarding the WHERE, ORDER BY and other clauses
        -: 8281:  ** of the user's query.
        -: 8282:  */
    #####: 8283:  if( rc==SQLITE_OK ){
    #####: 8284:    pNew->db = db;
    #####: 8285:    pNew->iSample = 100;
    #####: 8286:    rc = sqlite3_open(":memory:", &pNew->dbv);
        -: 8287:  }
    #####: 8288:  if( rc==SQLITE_OK ){
    #####: 8289:    rc = sqlite3_open(":memory:", &pNew->dbm);
    #####: 8290:    if( rc==SQLITE_OK ){
    #####: 8291:      sqlite3_db_config(pNew->dbm, SQLITE_DBCONFIG_TRIGGER_EQP, 1, (int*)0);
        -: 8292:    }
        -: 8293:  }
        -: 8294:  
        -: 8295:
        -: 8296:  /* Copy the entire schema of database [db] into [dbm]. */
    #####: 8297:  if( rc==SQLITE_OK ){
        -: 8298:    sqlite3_stmt *pSql;
    #####: 8299:    rc = idxPrintfPrepareStmt(pNew->db, &pSql, pzErrmsg, 
        -: 8300:        "SELECT sql FROM sqlite_master WHERE name NOT LIKE 'sqlite_%%'"
        -: 8301:        " AND sql NOT LIKE 'CREATE VIRTUAL %%'"
        -: 8302:    );
    #####: 8303:    while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pSql) ){
    #####: 8304:      const char *zSql = (const char*)sqlite3_column_text(pSql, 0);
    #####: 8305:      rc = sqlite3_exec(pNew->dbm, zSql, 0, 0, pzErrmsg);
        -: 8306:    }
    #####: 8307:    idxFinalize(&rc, pSql);
        -: 8308:  }
        -: 8309:
        -: 8310:  /* Create the vtab schema */
    #####: 8311:  if( rc==SQLITE_OK ){
    #####: 8312:    rc = idxCreateVtabSchema(pNew, pzErrmsg);
        -: 8313:  }
        -: 8314:
        -: 8315:  /* Register the auth callback with dbv */
    #####: 8316:  if( rc==SQLITE_OK ){
    #####: 8317:    sqlite3_set_authorizer(pNew->dbv, idxAuthCallback, (void*)pNew);
        -: 8318:  }
        -: 8319:
        -: 8320:  /* If an error has occurred, free the new object and reutrn NULL. Otherwise,
        -: 8321:  ** return the new sqlite3expert handle.  */
    #####: 8322:  if( rc!=SQLITE_OK ){
    #####: 8323:    sqlite3_expert_destroy(pNew);
    #####: 8324:    pNew = 0;
        -: 8325:  }
    #####: 8326:  return pNew;
        -: 8327:}
        -: 8328:
        -: 8329:/*
        -: 8330:** Configure an sqlite3expert object.
        -: 8331:*/
    #####: 8332:int sqlite3_expert_config(sqlite3expert *p, int op, ...){
    #####: 8333:  int rc = SQLITE_OK;
        -: 8334:  va_list ap;
    #####: 8335:  va_start(ap, op);
    #####: 8336:  switch( op ){
    #####: 8337:    case EXPERT_CONFIG_SAMPLE: {
    #####: 8338:      int iVal = va_arg(ap, int);
    #####: 8339:      if( iVal<0 ) iVal = 0;
    #####: 8340:      if( iVal>100 ) iVal = 100;
    #####: 8341:      p->iSample = iVal;
    #####: 8342:      break;
        -: 8343:    }
    #####: 8344:    default:
    #####: 8345:      rc = SQLITE_NOTFOUND;
    #####: 8346:      break;
        -: 8347:  }
        -: 8348:
    #####: 8349:  va_end(ap);
    #####: 8350:  return rc;
        -: 8351:}
        -: 8352:
        -: 8353:/*
        -: 8354:** Add an SQL statement to the analysis.
        -: 8355:*/
    #####: 8356:int sqlite3_expert_sql(
        -: 8357:  sqlite3expert *p,               /* From sqlite3_expert_new() */
        -: 8358:  const char *zSql,               /* SQL statement to add */
        -: 8359:  char **pzErr                    /* OUT: Error message (if any) */
        -: 8360:){
    #####: 8361:  IdxScan *pScanOrig = p->pScan;
    #####: 8362:  IdxStatement *pStmtOrig = p->pStatement;
    #####: 8363:  int rc = SQLITE_OK;
    #####: 8364:  const char *zStmt = zSql;
        -: 8365:
    #####: 8366:  if( p->bRun ) return SQLITE_MISUSE;
        -: 8367:
    #####: 8368:  while( rc==SQLITE_OK && zStmt && zStmt[0] ){
    #####: 8369:    sqlite3_stmt *pStmt = 0;
    #####: 8370:    rc = sqlite3_prepare_v2(p->dbv, zStmt, -1, &pStmt, &zStmt);
    #####: 8371:    if( rc==SQLITE_OK ){
    #####: 8372:      if( pStmt ){
        -: 8373:        IdxStatement *pNew;
    #####: 8374:        const char *z = sqlite3_sql(pStmt);
    #####: 8375:        int n = STRLEN(z);
    #####: 8376:        pNew = (IdxStatement*)idxMalloc(&rc, sizeof(IdxStatement) + n+1);
    #####: 8377:        if( rc==SQLITE_OK ){
    #####: 8378:          pNew->zSql = (char*)&pNew[1];
    #####: 8379:          memcpy(pNew->zSql, z, n+1);
    #####: 8380:          pNew->pNext = p->pStatement;
    #####: 8381:          if( p->pStatement ) pNew->iId = p->pStatement->iId+1;
    #####: 8382:          p->pStatement = pNew;
        -: 8383:        }
    #####: 8384:        sqlite3_finalize(pStmt);
        -: 8385:      }
        -: 8386:    }else{
    #####: 8387:      idxDatabaseError(p->dbv, pzErr);
        -: 8388:    }
        -: 8389:  }
        -: 8390:
    #####: 8391:  if( rc!=SQLITE_OK ){
    #####: 8392:    idxScanFree(p->pScan, pScanOrig);
    #####: 8393:    idxStatementFree(p->pStatement, pStmtOrig);
    #####: 8394:    p->pScan = pScanOrig;
    #####: 8395:    p->pStatement = pStmtOrig;
        -: 8396:  }
        -: 8397:
    #####: 8398:  return rc;
        -: 8399:}
        -: 8400:
    #####: 8401:int sqlite3_expert_analyze(sqlite3expert *p, char **pzErr){
        -: 8402:  int rc;
        -: 8403:  IdxHashEntry *pEntry;
        -: 8404:
        -: 8405:  /* Do trigger processing to collect any extra IdxScan structures */
    #####: 8406:  rc = idxProcessTriggers(p, pzErr);
        -: 8407:
        -: 8408:  /* Create candidate indexes within the in-memory database file */
    #####: 8409:  if( rc==SQLITE_OK ){
    #####: 8410:    rc = idxCreateCandidates(p);
        -: 8411:  }
        -: 8412:
        -: 8413:  /* Generate the stat1 data */
    #####: 8414:  if( rc==SQLITE_OK ){
    #####: 8415:    rc = idxPopulateStat1(p, pzErr);
        -: 8416:  }
        -: 8417:
        -: 8418:  /* Formulate the EXPERT_REPORT_CANDIDATES text */
    #####: 8419:  for(pEntry=p->hIdx.pFirst; pEntry; pEntry=pEntry->pNext){
    #####: 8420:    p->zCandidates = idxAppendText(&rc, p->zCandidates, 
        -: 8421:        "%s;%s%s\n", pEntry->zVal, 
    #####: 8422:        pEntry->zVal2 ? " -- stat1: " : "", pEntry->zVal2
        -: 8423:    );
        -: 8424:  }
        -: 8425:
        -: 8426:  /* Figure out which of the candidate indexes are preferred by the query
        -: 8427:  ** planner and report the results to the user.  */
    #####: 8428:  if( rc==SQLITE_OK ){
    #####: 8429:    rc = idxFindIndexes(p, pzErr);
        -: 8430:  }
        -: 8431:
    #####: 8432:  if( rc==SQLITE_OK ){
    #####: 8433:    p->bRun = 1;
        -: 8434:  }
    #####: 8435:  return rc;
        -: 8436:}
        -: 8437:
        -: 8438:/*
        -: 8439:** Return the total number of statements that have been added to this
        -: 8440:** sqlite3expert using sqlite3_expert_sql().
        -: 8441:*/
    #####: 8442:int sqlite3_expert_count(sqlite3expert *p){
    #####: 8443:  int nRet = 0;
    #####: 8444:  if( p->pStatement ) nRet = p->pStatement->iId+1;
    #####: 8445:  return nRet;
        -: 8446:}
        -: 8447:
        -: 8448:/*
        -: 8449:** Return a component of the report.
        -: 8450:*/
    #####: 8451:const char *sqlite3_expert_report(sqlite3expert *p, int iStmt, int eReport){
    #####: 8452:  const char *zRet = 0;
        -: 8453:  IdxStatement *pStmt;
        -: 8454:
    #####: 8455:  if( p->bRun==0 ) return 0;
    #####: 8456:  for(pStmt=p->pStatement; pStmt && pStmt->iId!=iStmt; pStmt=pStmt->pNext);
    #####: 8457:  switch( eReport ){
    #####: 8458:    case EXPERT_REPORT_SQL:
    #####: 8459:      if( pStmt ) zRet = pStmt->zSql;
    #####: 8460:      break;
    #####: 8461:    case EXPERT_REPORT_INDEXES:
    #####: 8462:      if( pStmt ) zRet = pStmt->zIdx;
    #####: 8463:      break;
    #####: 8464:    case EXPERT_REPORT_PLAN:
    #####: 8465:      if( pStmt ) zRet = pStmt->zEQP;
    #####: 8466:      break;
    #####: 8467:    case EXPERT_REPORT_CANDIDATES:
    #####: 8468:      zRet = p->zCandidates;
    #####: 8469:      break;
        -: 8470:  }
    #####: 8471:  return zRet;
        -: 8472:}
        -: 8473:
        -: 8474:/*
        -: 8475:** Free an sqlite3expert object.
        -: 8476:*/
    #####: 8477:void sqlite3_expert_destroy(sqlite3expert *p){
    #####: 8478:  if( p ){
    #####: 8479:    sqlite3_close(p->dbm);
    #####: 8480:    sqlite3_close(p->dbv);
    #####: 8481:    idxScanFree(p->pScan, 0);
    #####: 8482:    idxStatementFree(p->pStatement, 0);
    #####: 8483:    idxTableFree(p->pTable);
    #####: 8484:    idxWriteFree(p->pWrite);
    #####: 8485:    idxHashClear(&p->hIdx);
    #####: 8486:    sqlite3_free(p->zCandidates);
    #####: 8487:    sqlite3_free(p);
        -: 8488:  }
    #####: 8489:}
        -: 8490:
        -: 8491:#endif /* ifndef SQLITE_OMIT_VIRTUAL_TABLE */
        -: 8492:
        -: 8493:/************************* End ../ext/expert/sqlite3expert.c ********************/
        -: 8494:
        -: 8495:#if defined(SQLITE_ENABLE_SESSION)
        -: 8496:/*
        -: 8497:** State information for a single open session
        -: 8498:*/
        -: 8499:typedef struct OpenSession OpenSession;
        -: 8500:struct OpenSession {
        -: 8501:  char *zName;             /* Symbolic name for this session */
        -: 8502:  int nFilter;             /* Number of xFilter rejection GLOB patterns */
        -: 8503:  char **azFilter;         /* Array of xFilter rejection GLOB patterns */
        -: 8504:  sqlite3_session *p;      /* The open session */
        -: 8505:};
        -: 8506:#endif
        -: 8507:
        -: 8508:/*
        -: 8509:** Shell output mode information from before ".explain on",
        -: 8510:** saved so that it can be restored by ".explain off"
        -: 8511:*/
        -: 8512:typedef struct SavedModeInfo SavedModeInfo;
        -: 8513:struct SavedModeInfo {
        -: 8514:  int valid;          /* Is there legit data in here? */
        -: 8515:  int mode;           /* Mode prior to ".explain on" */
        -: 8516:  int showHeader;     /* The ".header" setting prior to ".explain on" */
        -: 8517:  int colWidth[100];  /* Column widths prior to ".explain on" */
        -: 8518:};
        -: 8519:
        -: 8520:typedef struct ExpertInfo ExpertInfo;
        -: 8521:struct ExpertInfo {
        -: 8522:  sqlite3expert *pExpert;
        -: 8523:  int bVerbose;
        -: 8524:};
        -: 8525:
        -: 8526:/* A single line in the EQP output */
        -: 8527:typedef struct EQPGraphRow EQPGraphRow;
        -: 8528:struct EQPGraphRow {
        -: 8529:  int iEqpId;           /* ID for this row */
        -: 8530:  int iParentId;        /* ID of the parent row */
        -: 8531:  EQPGraphRow *pNext;   /* Next row in sequence */
        -: 8532:  char zText[1];        /* Text to display for this row */
        -: 8533:};
        -: 8534:
        -: 8535:/* All EQP output is collected into an instance of the following */
        -: 8536:typedef struct EQPGraph EQPGraph;
        -: 8537:struct EQPGraph {
        -: 8538:  EQPGraphRow *pRow;    /* Linked list of all rows of the EQP output */
        -: 8539:  EQPGraphRow *pLast;   /* Last element of the pRow list */
        -: 8540:  char zPrefix[100];    /* Graph prefix */
        -: 8541:};
        -: 8542:
        -: 8543:/*
        -: 8544:** State information about the database connection is contained in an
        -: 8545:** instance of the following structure.
        -: 8546:*/
        -: 8547:typedef struct ShellState ShellState;
        -: 8548:struct ShellState {
        -: 8549:  sqlite3 *db;           /* The database */
        -: 8550:  u8 autoExplain;        /* Automatically turn on .explain mode */
        -: 8551:  u8 autoEQP;            /* Run EXPLAIN QUERY PLAN prior to seach SQL stmt */
        -: 8552:  u8 autoEQPtest;        /* autoEQP is in test mode */
        -: 8553:  u8 statsOn;            /* True to display memory stats before each finalize */
        -: 8554:  u8 scanstatsOn;        /* True to display scan stats before each finalize */
        -: 8555:  u8 openMode;           /* SHELL_OPEN_NORMAL, _APPENDVFS, or _ZIPFILE */
        -: 8556:  u8 doXdgOpen;          /* Invoke start/open/xdg-open in output_reset() */
        -: 8557:  u8 nEqpLevel;          /* Depth of the EQP output graph */
        -: 8558:  unsigned mEqpLines;    /* Mask of veritical lines in the EQP output graph */
        -: 8559:  int outCount;          /* Revert to stdout when reaching zero */
        -: 8560:  int cnt;               /* Number of records displayed so far */
        -: 8561:  FILE *out;             /* Write results here */
        -: 8562:  FILE *traceOut;        /* Output for sqlite3_trace() */
        -: 8563:  int nErr;              /* Number of errors seen */
        -: 8564:  int mode;              /* An output mode setting */
        -: 8565:  int modePrior;         /* Saved mode */
        -: 8566:  int cMode;             /* temporary output mode for the current query */
        -: 8567:  int normalMode;        /* Output mode before ".explain on" */
        -: 8568:  int writableSchema;    /* True if PRAGMA writable_schema=ON */
        -: 8569:  int showHeader;        /* True to show column names in List or Column mode */
        -: 8570:  int nCheck;            /* Number of ".check" commands run */
        -: 8571:  unsigned shellFlgs;    /* Various flags */
        -: 8572:  char *zDestTable;      /* Name of destination table when MODE_Insert */
        -: 8573:  char *zTempFile;       /* Temporary file that might need deleting */
        -: 8574:  char zTestcase[30];    /* Name of current test case */
        -: 8575:  char colSeparator[20]; /* Column separator character for several modes */
        -: 8576:  char rowSeparator[20]; /* Row separator character for MODE_Ascii */
        -: 8577:  char colSepPrior[20];  /* Saved column separator */
        -: 8578:  char rowSepPrior[20];  /* Saved row separator */
        -: 8579:  int colWidth[100];     /* Requested width of each column when in column mode*/
        -: 8580:  int actualWidth[100];  /* Actual width of each column */
        -: 8581:  char nullValue[20];    /* The text to print when a NULL comes back from
        -: 8582:                         ** the database */
        -: 8583:  char outfile[FILENAME_MAX]; /* Filename for *out */
        -: 8584:  const char *zDbFilename;    /* name of the database file */
        -: 8585:  char *zFreeOnClose;         /* Filename to free when closing */
        -: 8586:  const char *zVfs;           /* Name of VFS to use */
        -: 8587:  sqlite3_stmt *pStmt;   /* Current statement if any. */
        -: 8588:  FILE *pLog;            /* Write log output here */
        -: 8589:  int *aiIndent;         /* Array of indents used in MODE_Explain */
        -: 8590:  int nIndent;           /* Size of array aiIndent[] */
        -: 8591:  int iIndent;           /* Index of current op in aiIndent[] */
        -: 8592:  EQPGraph sGraph;       /* Information for the graphical EXPLAIN QUERY PLAN */
        -: 8593:#if defined(SQLITE_ENABLE_SESSION)
        -: 8594:  int nSession;             /* Number of active sessions */
        -: 8595:  OpenSession aSession[4];  /* Array of sessions.  [0] is in focus. */
        -: 8596:#endif
        -: 8597:  ExpertInfo expert;        /* Valid if previous command was ".expert OPT..." */
        -: 8598:};
        -: 8599:
        -: 8600:
        -: 8601:/* Allowed values for ShellState.autoEQP
        -: 8602:*/
        -: 8603:#define AUTOEQP_off      0           /* Automatic EXPLAIN QUERY PLAN is off */
        -: 8604:#define AUTOEQP_on       1           /* Automatic EQP is on */
        -: 8605:#define AUTOEQP_trigger  2           /* On and also show plans for triggers */
        -: 8606:#define AUTOEQP_full     3           /* Show full EXPLAIN */
        -: 8607:
        -: 8608:/* Allowed values for ShellState.openMode
        -: 8609:*/
        -: 8610:#define SHELL_OPEN_UNSPEC      0      /* No open-mode specified */
        -: 8611:#define SHELL_OPEN_NORMAL      1      /* Normal database file */
        -: 8612:#define SHELL_OPEN_APPENDVFS   2      /* Use appendvfs */
        -: 8613:#define SHELL_OPEN_ZIPFILE     3      /* Use the zipfile virtual table */
        -: 8614:#define SHELL_OPEN_READONLY    4      /* Open a normal database read-only */
        -: 8615:#define SHELL_OPEN_DESERIALIZE 5      /* Open using sqlite3_deserialize() */
        -: 8616:
        -: 8617:/*
        -: 8618:** These are the allowed shellFlgs values
        -: 8619:*/
        -: 8620:#define SHFLG_Pagecache      0x00000001 /* The --pagecache option is used */
        -: 8621:#define SHFLG_Lookaside      0x00000002 /* Lookaside memory is used */
        -: 8622:#define SHFLG_Backslash      0x00000004 /* The --backslash option is used */
        -: 8623:#define SHFLG_PreserveRowid  0x00000008 /* .dump preserves rowid values */
        -: 8624:#define SHFLG_Newlines       0x00000010 /* .dump --newline flag */
        -: 8625:#define SHFLG_CountChanges   0x00000020 /* .changes setting */
        -: 8626:#define SHFLG_Echo           0x00000040 /* .echo or --echo setting */
        -: 8627:
        -: 8628:/*
        -: 8629:** Macros for testing and setting shellFlgs
        -: 8630:*/
        -: 8631:#define ShellHasFlag(P,X)    (((P)->shellFlgs & (X))!=0)
        -: 8632:#define ShellSetFlag(P,X)    ((P)->shellFlgs|=(X))
        -: 8633:#define ShellClearFlag(P,X)  ((P)->shellFlgs&=(~(X)))
        -: 8634:
        -: 8635:/*
        -: 8636:** These are the allowed modes.
        -: 8637:*/
        -: 8638:#define MODE_Line     0  /* One column per line.  Blank line between records */
        -: 8639:#define MODE_Column   1  /* One record per line in neat columns */
        -: 8640:#define MODE_List     2  /* One record per line with a separator */
        -: 8641:#define MODE_Semi     3  /* Same as MODE_List but append ";" to each line */
        -: 8642:#define MODE_Html     4  /* Generate an XHTML table */
        -: 8643:#define MODE_Insert   5  /* Generate SQL "insert" statements */
        -: 8644:#define MODE_Quote    6  /* Quote values as for SQL */
        -: 8645:#define MODE_Tcl      7  /* Generate ANSI-C or TCL quoted elements */
        -: 8646:#define MODE_Csv      8  /* Quote strings, numbers are plain */
        -: 8647:#define MODE_Explain  9  /* Like MODE_Column, but do not truncate data */
        -: 8648:#define MODE_Ascii   10  /* Use ASCII unit and record separators (0x1F/0x1E) */
        -: 8649:#define MODE_Pretty  11  /* Pretty-print schemas */
        -: 8650:#define MODE_EQP     12  /* Converts EXPLAIN QUERY PLAN output into a graph */
        -: 8651:
        -: 8652:static const char *modeDescr[] = {
        -: 8653:  "line",
        -: 8654:  "column",
        -: 8655:  "list",
        -: 8656:  "semi",
        -: 8657:  "html",
        -: 8658:  "insert",
        -: 8659:  "quote",
        -: 8660:  "tcl",
        -: 8661:  "csv",
        -: 8662:  "explain",
        -: 8663:  "ascii",
        -: 8664:  "prettyprint",
        -: 8665:  "eqp"
        -: 8666:};
        -: 8667:
        -: 8668:/*
        -: 8669:** These are the column/row/line separators used by the various
        -: 8670:** import/export modes.
        -: 8671:*/
        -: 8672:#define SEP_Column    "|"
        -: 8673:#define SEP_Row       "\n"
        -: 8674:#define SEP_Tab       "\t"
        -: 8675:#define SEP_Space     " "
        -: 8676:#define SEP_Comma     ","
        -: 8677:#define SEP_CrLf      "\r\n"
        -: 8678:#define SEP_Unit      "\x1F"
        -: 8679:#define SEP_Record    "\x1E"
        -: 8680:
        -: 8681:/*
        -: 8682:** A callback for the sqlite3_log() interface.
        -: 8683:*/
        2: 8684:static void shellLog(void *pArg, int iErrCode, const char *zMsg){
        2: 8685:  ShellState *p = (ShellState*)pArg;
        2: 8686:  if( p->pLog==0 ) return;
    #####: 8687:  utf8_printf(p->pLog, "(%d) %s\n", iErrCode, zMsg);
    #####: 8688:  fflush(p->pLog);
        -: 8689:}
        -: 8690:
        -: 8691:/*
        -: 8692:** SQL function:  shell_putsnl(X)
        -: 8693:**
        -: 8694:** Write the text X to the screen (or whatever output is being directed)
        -: 8695:** adding a newline at the end, and then return X.
        -: 8696:*/
    #####: 8697:static void shellPutsFunc(
        -: 8698:  sqlite3_context *pCtx,
        -: 8699:  int nVal,
        -: 8700:  sqlite3_value **apVal
        -: 8701:){
    #####: 8702:  ShellState *p = (ShellState*)sqlite3_user_data(pCtx);
        -: 8703:  (void)nVal;
    #####: 8704:  utf8_printf(p->out, "%s\n", sqlite3_value_text(apVal[0]));
    #####: 8705:  sqlite3_result_value(pCtx, apVal[0]);
    #####: 8706:}
        -: 8707:
        -: 8708:/*
        -: 8709:** SQL function:   edit(VALUE)
        -: 8710:**                 edit(VALUE,EDITOR)
        -: 8711:**
        -: 8712:** These steps:
        -: 8713:**
        -: 8714:**     (1) Write VALUE into a temporary file.
        -: 8715:**     (2) Run program EDITOR on that temporary file.
        -: 8716:**     (3) Read the temporary file back and return its content as the result.
        -: 8717:**     (4) Delete the temporary file
        -: 8718:**
        -: 8719:** If the EDITOR argument is omitted, use the value in the VISUAL
        -: 8720:** environment variable.  If still there is no EDITOR, through an error.
        -: 8721:**
        -: 8722:** Also throw an error if the EDITOR program returns a non-zero exit code.
        -: 8723:*/
        -: 8724:#ifndef SQLITE_NOHAVE_SYSTEM
    #####: 8725:static void editFunc(
        -: 8726:  sqlite3_context *context,
        -: 8727:  int argc,
        -: 8728:  sqlite3_value **argv
        -: 8729:){
        -: 8730:  const char *zEditor;
    #####: 8731:  char *zTempFile = 0;
        -: 8732:  sqlite3 *db;
    #####: 8733:  char *zCmd = 0;
        -: 8734:  int bBin;
        -: 8735:  int rc;
    #####: 8736:  int hasCRNL = 0;
    #####: 8737:  FILE *f = 0;
        -: 8738:  sqlite3_int64 sz;
        -: 8739:  sqlite3_int64 x;
    #####: 8740:  unsigned char *p = 0;
        -: 8741:
    #####: 8742:  if( argc==2 ){
    #####: 8743:    zEditor = (const char*)sqlite3_value_text(argv[1]);
        -: 8744:  }else{
    #####: 8745:    zEditor = getenv("VISUAL");
        -: 8746:  }
    #####: 8747:  if( zEditor==0 ){
    #####: 8748:    sqlite3_result_error(context, "no editor for edit()", -1);
    #####: 8749:    return;
        -: 8750:  }
    #####: 8751:  if( sqlite3_value_type(argv[0])==SQLITE_NULL ){
    #####: 8752:    sqlite3_result_error(context, "NULL input to edit()", -1);
    #####: 8753:    return;
        -: 8754:  }
    #####: 8755:  db = sqlite3_context_db_handle(context);
    #####: 8756:  zTempFile = 0;
    #####: 8757:  sqlite3_file_control(db, 0, SQLITE_FCNTL_TEMPFILENAME, &zTempFile);
    #####: 8758:  if( zTempFile==0 ){
    #####: 8759:    sqlite3_uint64 r = 0;
    #####: 8760:    sqlite3_randomness(sizeof(r), &r);
    #####: 8761:    zTempFile = sqlite3_mprintf("temp%llx", r);
    #####: 8762:    if( zTempFile==0 ){
    #####: 8763:      sqlite3_result_error_nomem(context);
    #####: 8764:      return;
        -: 8765:    }
        -: 8766:  }
    #####: 8767:  bBin = sqlite3_value_type(argv[0])==SQLITE_BLOB;
        -: 8768:  /* When writing the file to be edited, do \n to \r\n conversions on systems
        -: 8769:  ** that want \r\n line endings */
    #####: 8770:  f = fopen(zTempFile, bBin ? "wb" : "w");
    #####: 8771:  if( f==0 ){
    #####: 8772:    sqlite3_result_error(context, "edit() cannot open temp file", -1);
    #####: 8773:    goto edit_func_end;
        -: 8774:  }
    #####: 8775:  sz = sqlite3_value_bytes(argv[0]);
    #####: 8776:  if( bBin ){
    #####: 8777:    x = fwrite(sqlite3_value_blob(argv[0]), 1, sz, f);
        -: 8778:  }else{
    #####: 8779:    const char *z = (const char*)sqlite3_value_text(argv[0]);
        -: 8780:    /* Remember whether or not the value originally contained \r\n */
    #####: 8781:    if( z && strstr(z,"\r\n")!=0 ) hasCRNL = 1;
    #####: 8782:    x = fwrite(sqlite3_value_text(argv[0]), 1, sz, f);
        -: 8783:  }
    #####: 8784:  fclose(f);
    #####: 8785:  f = 0;
    #####: 8786:  if( x!=sz ){
    #####: 8787:    sqlite3_result_error(context, "edit() could not write the whole file", -1);
    #####: 8788:    goto edit_func_end;
        -: 8789:  }
    #####: 8790:  zCmd = sqlite3_mprintf("%s \"%s\"", zEditor, zTempFile);
    #####: 8791:  if( zCmd==0 ){
    #####: 8792:    sqlite3_result_error_nomem(context);
    #####: 8793:    goto edit_func_end;
        -: 8794:  }
    #####: 8795:  rc = system(zCmd);
    #####: 8796:  sqlite3_free(zCmd);
    #####: 8797:  if( rc ){
    #####: 8798:    sqlite3_result_error(context, "EDITOR returned non-zero", -1);
    #####: 8799:    goto edit_func_end;
        -: 8800:  }
    #####: 8801:  f = fopen(zTempFile, "rb");
    #####: 8802:  if( f==0 ){
    #####: 8803:    sqlite3_result_error(context,
        -: 8804:      "edit() cannot reopen temp file after edit", -1);
    #####: 8805:    goto edit_func_end;
        -: 8806:  }
    #####: 8807:  fseek(f, 0, SEEK_END);
    #####: 8808:  sz = ftell(f);
    #####: 8809:  rewind(f);
    #####: 8810:  p = sqlite3_malloc64( sz+(bBin==0) );
    #####: 8811:  if( p==0 ){
    #####: 8812:    sqlite3_result_error_nomem(context);
    #####: 8813:    goto edit_func_end;
        -: 8814:  }
    #####: 8815:  x = fread(p, 1, sz, f);
    #####: 8816:  fclose(f);
    #####: 8817:  f = 0;
    #####: 8818:  if( x!=sz ){
    #####: 8819:    sqlite3_result_error(context, "could not read back the whole file", -1);
    #####: 8820:    goto edit_func_end;
        -: 8821:  }
    #####: 8822:  if( bBin ){
    #####: 8823:    sqlite3_result_blob64(context, p, sz, sqlite3_free);
        -: 8824:  }else{
        -: 8825:    sqlite3_int64 i, j;
    #####: 8826:    if( hasCRNL ){
        -: 8827:      /* If the original contains \r\n then do no conversions back to \n */
    #####: 8828:      j = sz;
        -: 8829:    }else{
        -: 8830:      /* If the file did not originally contain \r\n then convert any new
        -: 8831:      ** \r\n back into \n */
    #####: 8832:      for(i=j=0; i<sz; i++){
    #####: 8833:        if( p[i]=='\r' && p[i+1]=='\n' ) i++;
    #####: 8834:        p[j++] = p[i];
        -: 8835:      }
    #####: 8836:      sz = j;
    #####: 8837:      p[sz] = 0;
        -: 8838:    } 
    #####: 8839:    sqlite3_result_text64(context, (const char*)p, sz,
        -: 8840:                          sqlite3_free, SQLITE_UTF8);
        -: 8841:  }
    #####: 8842:  p = 0;
        -: 8843:
    #####: 8844:edit_func_end:
    #####: 8845:  if( f ) fclose(f);
    #####: 8846:  unlink(zTempFile);
    #####: 8847:  sqlite3_free(zTempFile);
    #####: 8848:  sqlite3_free(p);
        -: 8849:}
        -: 8850:#endif /* SQLITE_NOHAVE_SYSTEM */
        -: 8851:
        -: 8852:/*
        -: 8853:** Save or restore the current output mode
        -: 8854:*/
    #####: 8855:static void outputModePush(ShellState *p){
    #####: 8856:  p->modePrior = p->mode;
    #####: 8857:  memcpy(p->colSepPrior, p->colSeparator, sizeof(p->colSeparator));
    #####: 8858:  memcpy(p->rowSepPrior, p->rowSeparator, sizeof(p->rowSeparator));
    #####: 8859:}
    #####: 8860:static void outputModePop(ShellState *p){
    #####: 8861:  p->mode = p->modePrior;
    #####: 8862:  memcpy(p->colSeparator, p->colSepPrior, sizeof(p->colSeparator));
    #####: 8863:  memcpy(p->rowSeparator, p->rowSepPrior, sizeof(p->rowSeparator));
    #####: 8864:}
        -: 8865:
        -: 8866:/*
        -: 8867:** Output the given string as a hex-encoded blob (eg. X'1234' )
        -: 8868:*/
    #####: 8869:static void output_hex_blob(FILE *out, const void *pBlob, int nBlob){
        -: 8870:  int i;
    #####: 8871:  char *zBlob = (char *)pBlob;
    #####: 8872:  raw_printf(out,"X'");
    #####: 8873:  for(i=0; i<nBlob; i++){ raw_printf(out,"%02x",zBlob[i]&0xff); }
    #####: 8874:  raw_printf(out,"'");
    #####: 8875:}
        -: 8876:
        -: 8877:/*
        -: 8878:** Find a string that is not found anywhere in z[].  Return a pointer
        -: 8879:** to that string.
        -: 8880:**
        -: 8881:** Try to use zA and zB first.  If both of those are already found in z[]
        -: 8882:** then make up some string and store it in the buffer zBuf.
        -: 8883:*/
    #####: 8884:static const char *unused_string(
        -: 8885:  const char *z,                    /* Result must not appear anywhere in z */
        -: 8886:  const char *zA, const char *zB,   /* Try these first */
        -: 8887:  char *zBuf                        /* Space to store a generated string */
        -: 8888:){
    #####: 8889:  unsigned i = 0;
    #####: 8890:  if( strstr(z, zA)==0 ) return zA;
    #####: 8891:  if( strstr(z, zB)==0 ) return zB;
        -: 8892:  do{
    #####: 8893:    sqlite3_snprintf(20,zBuf,"(%s%u)", zA, i++);
    #####: 8894:  }while( strstr(z,zBuf)!=0 );
    #####: 8895:  return zBuf;
        -: 8896:}
        -: 8897:
        -: 8898:/*
        -: 8899:** Output the given string as a quoted string using SQL quoting conventions.
        -: 8900:**
        -: 8901:** See also: output_quoted_escaped_string()
        -: 8902:*/
    #####: 8903:static void output_quoted_string(FILE *out, const char *z){
        -: 8904:  int i;
        -: 8905:  char c;
        -: 8906:  setBinaryMode(out, 1);
    #####: 8907:  for(i=0; (c = z[i])!=0 && c!='\''; i++){}
    #####: 8908:  if( c==0 ){
    #####: 8909:    utf8_printf(out,"'%s'",z);
        -: 8910:  }else{
    #####: 8911:    raw_printf(out, "'");
    #####: 8912:    while( *z ){
    #####: 8913:      for(i=0; (c = z[i])!=0 && c!='\''; i++){}
    #####: 8914:      if( c=='\'' ) i++;
    #####: 8915:      if( i ){
    #####: 8916:        utf8_printf(out, "%.*s", i, z);
    #####: 8917:        z += i;
        -: 8918:      }
    #####: 8919:      if( c=='\'' ){
    #####: 8920:        raw_printf(out, "'");
    #####: 8921:        continue;
        -: 8922:      }
    #####: 8923:      if( c==0 ){
    #####: 8924:        break;
        -: 8925:      }
    #####: 8926:      z++;
        -: 8927:    }
    #####: 8928:    raw_printf(out, "'");
        -: 8929:  }
        -: 8930:  setTextMode(out, 1);
    #####: 8931:}
        -: 8932:
        -: 8933:/*
        -: 8934:** Output the given string as a quoted string using SQL quoting conventions.
        -: 8935:** Additionallly , escape the "\n" and "\r" characters so that they do not
        -: 8936:** get corrupted by end-of-line translation facilities in some operating
        -: 8937:** systems.
        -: 8938:**
        -: 8939:** This is like output_quoted_string() but with the addition of the \r\n
        -: 8940:** escape mechanism.
        -: 8941:*/
    #####: 8942:static void output_quoted_escaped_string(FILE *out, const char *z){
        -: 8943:  int i;
        -: 8944:  char c;
        -: 8945:  setBinaryMode(out, 1);
    #####: 8946:  for(i=0; (c = z[i])!=0 && c!='\'' && c!='\n' && c!='\r'; i++){}
    #####: 8947:  if( c==0 ){
    #####: 8948:    utf8_printf(out,"'%s'",z);
        -: 8949:  }else{
    #####: 8950:    const char *zNL = 0;
    #####: 8951:    const char *zCR = 0;
    #####: 8952:    int nNL = 0;
    #####: 8953:    int nCR = 0;
        -: 8954:    char zBuf1[20], zBuf2[20];
    #####: 8955:    for(i=0; z[i]; i++){
    #####: 8956:      if( z[i]=='\n' ) nNL++;
    #####: 8957:      if( z[i]=='\r' ) nCR++;
        -: 8958:    }
    #####: 8959:    if( nNL ){
    #####: 8960:      raw_printf(out, "replace(");
    #####: 8961:      zNL = unused_string(z, "\\n", "\\012", zBuf1);
        -: 8962:    }
    #####: 8963:    if( nCR ){
    #####: 8964:      raw_printf(out, "replace(");
    #####: 8965:      zCR = unused_string(z, "\\r", "\\015", zBuf2);
        -: 8966:    }
    #####: 8967:    raw_printf(out, "'");
    #####: 8968:    while( *z ){
    #####: 8969:      for(i=0; (c = z[i])!=0 && c!='\n' && c!='\r' && c!='\''; i++){}
    #####: 8970:      if( c=='\'' ) i++;
    #####: 8971:      if( i ){
    #####: 8972:        utf8_printf(out, "%.*s", i, z);
    #####: 8973:        z += i;
        -: 8974:      }
    #####: 8975:      if( c=='\'' ){
    #####: 8976:        raw_printf(out, "'");
    #####: 8977:        continue;
        -: 8978:      }
    #####: 8979:      if( c==0 ){
    #####: 8980:        break;
        -: 8981:      }
    #####: 8982:      z++;
    #####: 8983:      if( c=='\n' ){
    #####: 8984:        raw_printf(out, "%s", zNL);
    #####: 8985:        continue;
        -: 8986:      }
    #####: 8987:      raw_printf(out, "%s", zCR);
        -: 8988:    }
    #####: 8989:    raw_printf(out, "'");
    #####: 8990:    if( nCR ){
    #####: 8991:      raw_printf(out, ",'%s',char(13))", zCR);
        -: 8992:    }
    #####: 8993:    if( nNL ){
    #####: 8994:      raw_printf(out, ",'%s',char(10))", zNL);
        -: 8995:    }
        -: 8996:  }
        -: 8997:  setTextMode(out, 1);
    #####: 8998:}
        -: 8999:
        -: 9000:/*
        -: 9001:** Output the given string as a quoted according to C or TCL quoting rules.
        -: 9002:*/
    #####: 9003:static void output_c_string(FILE *out, const char *z){
        -: 9004:  unsigned int c;
    #####: 9005:  fputc('"', out);
    #####: 9006:  while( (c = *(z++))!=0 ){
    #####: 9007:    if( c=='\\' ){
    #####: 9008:      fputc(c, out);
    #####: 9009:      fputc(c, out);
    #####: 9010:    }else if( c=='"' ){
    #####: 9011:      fputc('\\', out);
    #####: 9012:      fputc('"', out);
    #####: 9013:    }else if( c=='\t' ){
    #####: 9014:      fputc('\\', out);
    #####: 9015:      fputc('t', out);
    #####: 9016:    }else if( c=='\n' ){
    #####: 9017:      fputc('\\', out);
    #####: 9018:      fputc('n', out);
    #####: 9019:    }else if( c=='\r' ){
    #####: 9020:      fputc('\\', out);
    #####: 9021:      fputc('r', out);
    #####: 9022:    }else if( !isprint(c&0xff) ){
    #####: 9023:      raw_printf(out, "\\%03o", c&0xff);
        -: 9024:    }else{
    #####: 9025:      fputc(c, out);
        -: 9026:    }
        -: 9027:  }
    #####: 9028:  fputc('"', out);
    #####: 9029:}
        -: 9030:
        -: 9031:/*
        -: 9032:** Output the given string with characters that are special to
        -: 9033:** HTML escaped.
        -: 9034:*/
    #####: 9035:static void output_html_string(FILE *out, const char *z){
        -: 9036:  int i;
    #####: 9037:  if( z==0 ) z = "";
    #####: 9038:  while( *z ){
    #####: 9039:    for(i=0;   z[i]
    #####: 9040:            && z[i]!='<'
    #####: 9041:            && z[i]!='&'
    #####: 9042:            && z[i]!='>'
    #####: 9043:            && z[i]!='\"'
    #####: 9044:            && z[i]!='\'';
    #####: 9045:        i++){}
    #####: 9046:    if( i>0 ){
    #####: 9047:      utf8_printf(out,"%.*s",i,z);
        -: 9048:    }
    #####: 9049:    if( z[i]=='<' ){
    #####: 9050:      raw_printf(out,"&lt;");
    #####: 9051:    }else if( z[i]=='&' ){
    #####: 9052:      raw_printf(out,"&amp;");
    #####: 9053:    }else if( z[i]=='>' ){
    #####: 9054:      raw_printf(out,"&gt;");
    #####: 9055:    }else if( z[i]=='\"' ){
    #####: 9056:      raw_printf(out,"&quot;");
    #####: 9057:    }else if( z[i]=='\'' ){
    #####: 9058:      raw_printf(out,"&#39;");
        -: 9059:    }else{
    #####: 9060:      break;
        -: 9061:    }
    #####: 9062:    z += i + 1;
        -: 9063:  }
    #####: 9064:}
        -: 9065:
        -: 9066:/*
        -: 9067:** If a field contains any character identified by a 1 in the following
        -: 9068:** array, then the string must be quoted for CSV.
        -: 9069:*/
        -: 9070:static const char needCsvQuote[] = {
        -: 9071:  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,
        -: 9072:  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,
        -: 9073:  1, 0, 1, 0, 0, 0, 0, 1,   0, 0, 0, 0, 0, 0, 0, 0,
        -: 9074:  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,
        -: 9075:  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,
        -: 9076:  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,
        -: 9077:  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,
        -: 9078:  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 1,
        -: 9079:  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,
        -: 9080:  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,
        -: 9081:  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,
        -: 9082:  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,
        -: 9083:  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,
        -: 9084:  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,
        -: 9085:  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,
        -: 9086:  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,
        -: 9087:};
        -: 9088:
        -: 9089:/*
        -: 9090:** Output a single term of CSV.  Actually, p->colSeparator is used for
        -: 9091:** the separator, which may or may not be a comma.  p->nullValue is
        -: 9092:** the null value.  Strings are quoted if necessary.  The separator
        -: 9093:** is only issued if bSep is true.
        -: 9094:*/
    #####: 9095:static void output_csv(ShellState *p, const char *z, int bSep){
    #####: 9096:  FILE *out = p->out;
    #####: 9097:  if( z==0 ){
    #####: 9098:    utf8_printf(out,"%s",p->nullValue);
        -: 9099:  }else{
        -: 9100:    int i;
    #####: 9101:    int nSep = strlen30(p->colSeparator);
    #####: 9102:    for(i=0; z[i]; i++){
    #####: 9103:      if( needCsvQuote[((unsigned char*)z)[i]]
    #####: 9104:         || (z[i]==p->colSeparator[0] &&
    #####: 9105:             (nSep==1 || memcmp(z, p->colSeparator, nSep)==0)) ){
    #####: 9106:        i = 0;
    #####: 9107:        break;
        -: 9108:      }
        -: 9109:    }
    #####: 9110:    if( i==0 ){
    #####: 9111:      char *zQuoted = sqlite3_mprintf("\"%w\"", z);
    #####: 9112:      utf8_printf(out, "%s", zQuoted);
    #####: 9113:      sqlite3_free(zQuoted);
        -: 9114:    }else{
    #####: 9115:      utf8_printf(out, "%s", z);
        -: 9116:    }
        -: 9117:  }
    #####: 9118:  if( bSep ){
    #####: 9119:    utf8_printf(p->out, "%s", p->colSeparator);
        -: 9120:  }
    #####: 9121:}
        -: 9122:
        -: 9123:/*
        -: 9124:** This routine runs when the user presses Ctrl-C
        -: 9125:*/
    #####: 9126:static void interrupt_handler(int NotUsed){
        -: 9127:  UNUSED_PARAMETER(NotUsed);
    #####: 9128:  seenInterrupt++;
    #####: 9129:  if( seenInterrupt>2 ) exit(1);
    #####: 9130:  if( globalDb ) sqlite3_interrupt(globalDb);
    #####: 9131:}
        -: 9132:
        -: 9133:#if (defined(_WIN32) || defined(WIN32)) && !defined(_WIN32_WCE)
        -: 9134:/*
        -: 9135:** This routine runs for console events (e.g. Ctrl-C) on Win32
        -: 9136:*/
        -: 9137:static BOOL WINAPI ConsoleCtrlHandler(
        -: 9138:  DWORD dwCtrlType /* One of the CTRL_*_EVENT constants */
        -: 9139:){
        -: 9140:  if( dwCtrlType==CTRL_C_EVENT ){
        -: 9141:    interrupt_handler(0);
        -: 9142:    return TRUE;
        -: 9143:  }
        -: 9144:  return FALSE;
        -: 9145:}
        -: 9146:#endif
        -: 9147:
        -: 9148:#ifndef SQLITE_OMIT_AUTHORIZATION
        -: 9149:/*
        -: 9150:** When the ".auth ON" is set, the following authorizer callback is
        -: 9151:** invoked.  It always returns SQLITE_OK.
        -: 9152:*/
    #####: 9153:static int shellAuth(
        -: 9154:  void *pClientData,
        -: 9155:  int op,
        -: 9156:  const char *zA1,
        -: 9157:  const char *zA2,
        -: 9158:  const char *zA3,
        -: 9159:  const char *zA4
        -: 9160:){
    #####: 9161:  ShellState *p = (ShellState*)pClientData;
        -: 9162:  static const char *azAction[] = { 0,
        -: 9163:     "CREATE_INDEX",         "CREATE_TABLE",         "CREATE_TEMP_INDEX",
        -: 9164:     "CREATE_TEMP_TABLE",    "CREATE_TEMP_TRIGGER",  "CREATE_TEMP_VIEW",
        -: 9165:     "CREATE_TRIGGER",       "CREATE_VIEW",          "DELETE",
        -: 9166:     "DROP_INDEX",           "DROP_TABLE",           "DROP_TEMP_INDEX",
        -: 9167:     "DROP_TEMP_TABLE",      "DROP_TEMP_TRIGGER",    "DROP_TEMP_VIEW",
        -: 9168:     "DROP_TRIGGER",         "DROP_VIEW",            "INSERT",
        -: 9169:     "PRAGMA",               "READ",                 "SELECT",
        -: 9170:     "TRANSACTION",          "UPDATE",               "ATTACH",
        -: 9171:     "DETACH",               "ALTER_TABLE",          "REINDEX",
        -: 9172:     "ANALYZE",              "CREATE_VTABLE",        "DROP_VTABLE",
        -: 9173:     "FUNCTION",             "SAVEPOINT",            "RECURSIVE"
        -: 9174:  };
        -: 9175:  int i;
        -: 9176:  const char *az[4];
    #####: 9177:  az[0] = zA1;
    #####: 9178:  az[1] = zA2;
    #####: 9179:  az[2] = zA3;
    #####: 9180:  az[3] = zA4;
    #####: 9181:  utf8_printf(p->out, "authorizer: %s", azAction[op]);
    #####: 9182:  for(i=0; i<4; i++){
    #####: 9183:    raw_printf(p->out, " ");
    #####: 9184:    if( az[i] ){
    #####: 9185:      output_c_string(p->out, az[i]);
        -: 9186:    }else{
    #####: 9187:      raw_printf(p->out, "NULL");
        -: 9188:    }
        -: 9189:  }
    #####: 9190:  raw_printf(p->out, "\n");
    #####: 9191:  return SQLITE_OK;
        -: 9192:}
        -: 9193:#endif
        -: 9194:
        -: 9195:/*
        -: 9196:** Print a schema statement.  Part of MODE_Semi and MODE_Pretty output.
        -: 9197:**
        -: 9198:** This routine converts some CREATE TABLE statements for shadow tables
        -: 9199:** in FTS3/4/5 into CREATE TABLE IF NOT EXISTS statements.
        -: 9200:*/
    #####: 9201:static void printSchemaLine(FILE *out, const char *z, const char *zTail){
    #####: 9202:  if( sqlite3_strglob("CREATE TABLE ['\"]*", z)==0 ){
    #####: 9203:    utf8_printf(out, "CREATE TABLE IF NOT EXISTS %s%s", z+13, zTail);
        -: 9204:  }else{
    #####: 9205:    utf8_printf(out, "%s%s", z, zTail);
        -: 9206:  }
    #####: 9207:}
    #####: 9208:static void printSchemaLineN(FILE *out, char *z, int n, const char *zTail){
    #####: 9209:  char c = z[n];
    #####: 9210:  z[n] = 0;
    #####: 9211:  printSchemaLine(out, z, zTail);
    #####: 9212:  z[n] = c;
    #####: 9213:}
        -: 9214:
        -: 9215:/*
        -: 9216:** Return true if string z[] has nothing but whitespace and comments to the
        -: 9217:** end of the first line.
        -: 9218:*/
    #####: 9219:static int wsToEol(const char *z){
        -: 9220:  int i;
    #####: 9221:  for(i=0; z[i]; i++){
    #####: 9222:    if( z[i]=='\n' ) return 1;
    #####: 9223:    if( IsSpace(z[i]) ) continue;
    #####: 9224:    if( z[i]=='-' && z[i+1]=='-' ) return 1;
    #####: 9225:    return 0;
        -: 9226:  }
    #####: 9227:  return 1;
        -: 9228:}
        -: 9229:
        -: 9230:/*
        -: 9231:** Add a new entry to the EXPLAIN QUERY PLAN data
        -: 9232:*/
    #####: 9233:static void eqp_append(ShellState *p, int iEqpId, int p2, const char *zText){
        -: 9234:  EQPGraphRow *pNew;
    #####: 9235:  int nText = strlen30(zText);
    #####: 9236:  if( p->autoEQPtest ){
    #####: 9237:    utf8_printf(p->out, "%d,%d,%s\n", iEqpId, p2, zText);
        -: 9238:  }
    #####: 9239:  pNew = sqlite3_malloc64( sizeof(*pNew) + nText );
    #####: 9240:  if( pNew==0 ) shell_out_of_memory();
    #####: 9241:  pNew->iEqpId = iEqpId;
    #####: 9242:  pNew->iParentId = p2;
    #####: 9243:  memcpy(pNew->zText, zText, nText+1);
    #####: 9244:  pNew->pNext = 0;
    #####: 9245:  if( p->sGraph.pLast ){
    #####: 9246:    p->sGraph.pLast->pNext = pNew;
        -: 9247:  }else{
    #####: 9248:    p->sGraph.pRow = pNew;
        -: 9249:  }
    #####: 9250:  p->sGraph.pLast = pNew;
    #####: 9251:}
        -: 9252:
        -: 9253:/*
        -: 9254:** Free and reset the EXPLAIN QUERY PLAN data that has been collected
        -: 9255:** in p->sGraph.
        -: 9256:*/
    #####: 9257:static void eqp_reset(ShellState *p){
        -: 9258:  EQPGraphRow *pRow, *pNext;
    #####: 9259:  for(pRow = p->sGraph.pRow; pRow; pRow = pNext){
    #####: 9260:    pNext = pRow->pNext;
    #####: 9261:    sqlite3_free(pRow);
        -: 9262:  }
    #####: 9263:  memset(&p->sGraph, 0, sizeof(p->sGraph));
    #####: 9264:}
        -: 9265:
        -: 9266:/* Return the next EXPLAIN QUERY PLAN line with iEqpId that occurs after
        -: 9267:** pOld, or return the first such line if pOld is NULL
        -: 9268:*/
    #####: 9269:static EQPGraphRow *eqp_next_row(ShellState *p, int iEqpId, EQPGraphRow *pOld){
    #####: 9270:  EQPGraphRow *pRow = pOld ? pOld->pNext : p->sGraph.pRow;
    #####: 9271:  while( pRow && pRow->iParentId!=iEqpId ) pRow = pRow->pNext;
    #####: 9272:  return pRow;
        -: 9273:}
        -: 9274:
        -: 9275:/* Render a single level of the graph that has iEqpId as its parent.  Called
        -: 9276:** recursively to render sublevels.
        -: 9277:*/
    #####: 9278:static void eqp_render_level(ShellState *p, int iEqpId){
        -: 9279:  EQPGraphRow *pRow, *pNext;
    #####: 9280:  int n = strlen30(p->sGraph.zPrefix);
        -: 9281:  char *z;
    #####: 9282:  for(pRow = eqp_next_row(p, iEqpId, 0); pRow; pRow = pNext){
    #####: 9283:    pNext = eqp_next_row(p, iEqpId, pRow);
    #####: 9284:    z = pRow->zText;
    #####: 9285:    utf8_printf(p->out, "%s%s%s\n", p->sGraph.zPrefix, pNext ? "|--" : "`--", z);
    #####: 9286:    if( n<(int)sizeof(p->sGraph.zPrefix)-7 ){
    #####: 9287:      memcpy(&p->sGraph.zPrefix[n], pNext ? "|  " : "   ", 4);
    #####: 9288:      eqp_render_level(p, pRow->iEqpId);
    #####: 9289:      p->sGraph.zPrefix[n] = 0;
        -: 9290:    }
        -: 9291:  }
    #####: 9292:}
        -: 9293:
        -: 9294:/*
        -: 9295:** Display and reset the EXPLAIN QUERY PLAN data
        -: 9296:*/
    #####: 9297:static void eqp_render(ShellState *p){
    #####: 9298:  EQPGraphRow *pRow = p->sGraph.pRow;
    #####: 9299:  if( pRow ){
    #####: 9300:    if( pRow->zText[0]=='-' ){
    #####: 9301:      if( pRow->pNext==0 ){
    #####: 9302:        eqp_reset(p);
    #####: 9303:        return;
        -: 9304:      }
    #####: 9305:      utf8_printf(p->out, "%s\n", pRow->zText+3);
    #####: 9306:      p->sGraph.pRow = pRow->pNext;
    #####: 9307:      sqlite3_free(pRow);
        -: 9308:    }else{
    #####: 9309:      utf8_printf(p->out, "QUERY PLAN\n");
        -: 9310:    }
    #####: 9311:    p->sGraph.zPrefix[0] = 0;
    #####: 9312:    eqp_render_level(p, 0);
    #####: 9313:    eqp_reset(p);
        -: 9314:  }
        -: 9315:}
        -: 9316:
        -: 9317:/*
        -: 9318:** This is the callback routine that the shell
        -: 9319:** invokes for each row of a query result.
        -: 9320:*/
    #####: 9321:static int shell_callback(
        -: 9322:  void *pArg,
        -: 9323:  int nArg,        /* Number of result columns */
        -: 9324:  char **azArg,    /* Text of each result column */
        -: 9325:  char **azCol,    /* Column names */
        -: 9326:  int *aiType      /* Column types */
        -: 9327:){
        -: 9328:  int i;
    #####: 9329:  ShellState *p = (ShellState*)pArg;
        -: 9330:
    #####: 9331:  if( azArg==0 ) return 0;
    #####: 9332:  switch( p->cMode ){
    #####: 9333:    case MODE_Line: {
    #####: 9334:      int w = 5;
    #####: 9335:      if( azArg==0 ) break;
    #####: 9336:      for(i=0; i<nArg; i++){
    #####: 9337:        int len = strlen30(azCol[i] ? azCol[i] : "");
    #####: 9338:        if( len>w ) w = len;
        -: 9339:      }
    #####: 9340:      if( p->cnt++>0 ) utf8_printf(p->out, "%s", p->rowSeparator);
    #####: 9341:      for(i=0; i<nArg; i++){
    #####: 9342:        utf8_printf(p->out,"%*s = %s%s", w, azCol[i],
    #####: 9343:                azArg[i] ? azArg[i] : p->nullValue, p->rowSeparator);
        -: 9344:      }
    #####: 9345:      break;
        -: 9346:    }
    #####: 9347:    case MODE_Explain:
        -: 9348:    case MODE_Column: {
        -: 9349:      static const int aExplainWidths[] = {4, 13, 4, 4, 4, 13, 2, 13};
        -: 9350:      const int *colWidth;
        -: 9351:      int showHdr;
        -: 9352:      char *rowSep;
    #####: 9353:      if( p->cMode==MODE_Column ){
    #####: 9354:        colWidth = p->colWidth;
    #####: 9355:        showHdr = p->showHeader;
    #####: 9356:        rowSep = p->rowSeparator;
        -: 9357:      }else{
    #####: 9358:        colWidth = aExplainWidths;
    #####: 9359:        showHdr = 1;
    #####: 9360:        rowSep = SEP_Row;
        -: 9361:      }
    #####: 9362:      if( p->cnt++==0 ){
    #####: 9363:        for(i=0; i<nArg; i++){
        -: 9364:          int w, n;
    #####: 9365:          if( i<ArraySize(p->colWidth) ){
    #####: 9366:            w = colWidth[i];
        -: 9367:          }else{
    #####: 9368:            w = 0;
        -: 9369:          }
    #####: 9370:          if( w==0 ){
    #####: 9371:            w = strlenChar(azCol[i] ? azCol[i] : "");
    #####: 9372:            if( w<10 ) w = 10;
    #####: 9373:            n = strlenChar(azArg && azArg[i] ? azArg[i] : p->nullValue);
    #####: 9374:            if( w<n ) w = n;
        -: 9375:          }
    #####: 9376:          if( i<ArraySize(p->actualWidth) ){
    #####: 9377:            p->actualWidth[i] = w;
        -: 9378:          }
    #####: 9379:          if( showHdr ){
    #####: 9380:            utf8_width_print(p->out, w, azCol[i]);
    #####: 9381:            utf8_printf(p->out, "%s", i==nArg-1 ? rowSep : "  ");
        -: 9382:          }
        -: 9383:        }
    #####: 9384:        if( showHdr ){
    #####: 9385:          for(i=0; i<nArg; i++){
        -: 9386:            int w;
    #####: 9387:            if( i<ArraySize(p->actualWidth) ){
    #####: 9388:               w = p->actualWidth[i];
    #####: 9389:               if( w<0 ) w = -w;
        -: 9390:            }else{
    #####: 9391:               w = 10;
        -: 9392:            }
    #####: 9393:            utf8_printf(p->out,"%-*.*s%s",w,w,
        -: 9394:                   "----------------------------------------------------------"
        -: 9395:                   "----------------------------------------------------------",
    #####: 9396:                    i==nArg-1 ? rowSep : "  ");
        -: 9397:          }
        -: 9398:        }
        -: 9399:      }
    #####: 9400:      if( azArg==0 ) break;
    #####: 9401:      for(i=0; i<nArg; i++){
        -: 9402:        int w;
    #####: 9403:        if( i<ArraySize(p->actualWidth) ){
    #####: 9404:           w = p->actualWidth[i];
        -: 9405:        }else{
    #####: 9406:           w = 10;
        -: 9407:        }
    #####: 9408:        if( p->cMode==MODE_Explain && azArg[i] && strlenChar(azArg[i])>w ){
    #####: 9409:          w = strlenChar(azArg[i]);
        -: 9410:        }
    #####: 9411:        if( i==1 && p->aiIndent && p->pStmt ){
    #####: 9412:          if( p->iIndent<p->nIndent ){
    #####: 9413:            utf8_printf(p->out, "%*.s", p->aiIndent[p->iIndent], "");
        -: 9414:          }
    #####: 9415:          p->iIndent++;
        -: 9416:        }
    #####: 9417:        utf8_width_print(p->out, w, azArg[i] ? azArg[i] : p->nullValue);
    #####: 9418:        utf8_printf(p->out, "%s", i==nArg-1 ? rowSep : "  ");
        -: 9419:      }
    #####: 9420:      break;
        -: 9421:    }
    #####: 9422:    case MODE_Semi: {   /* .schema and .fullschema output */
    #####: 9423:      printSchemaLine(p->out, azArg[0], ";\n");
    #####: 9424:      break;
        -: 9425:    }
    #####: 9426:    case MODE_Pretty: {  /* .schema and .fullschema with --indent */
        -: 9427:      char *z;
        -: 9428:      int j;
    #####: 9429:      int nParen = 0;
    #####: 9430:      char cEnd = 0;
        -: 9431:      char c;
    #####: 9432:      int nLine = 0;
        -: 9433:      assert( nArg==1 );
    #####: 9434:      if( azArg[0]==0 ) break;
    #####: 9435:      if( sqlite3_strlike("CREATE VIEW%", azArg[0], 0)==0
    #####: 9436:       || sqlite3_strlike("CREATE TRIG%", azArg[0], 0)==0
        -: 9437:      ){
    #####: 9438:        utf8_printf(p->out, "%s;\n", azArg[0]);
    #####: 9439:        break;
        -: 9440:      }
    #####: 9441:      z = sqlite3_mprintf("%s", azArg[0]);
    #####: 9442:      j = 0;
    #####: 9443:      for(i=0; IsSpace(z[i]); i++){}
    #####: 9444:      for(; (c = z[i])!=0; i++){
    #####: 9445:        if( IsSpace(c) ){
    #####: 9446:          if( z[j-1]=='\r' ) z[j-1] = '\n';
    #####: 9447:          if( IsSpace(z[j-1]) || z[j-1]=='(' ) continue;
    #####: 9448:        }else if( (c=='(' || c==')') && j>0 && IsSpace(z[j-1]) ){
    #####: 9449:          j--;
        -: 9450:        }
    #####: 9451:        z[j++] = c;
        -: 9452:      }
    #####: 9453:      while( j>0 && IsSpace(z[j-1]) ){ j--; }
    #####: 9454:      z[j] = 0;
    #####: 9455:      if( strlen30(z)>=79 ){
    #####: 9456:        for(i=j=0; (c = z[i])!=0; i++){  /* Copy changes from z[i] back to z[j] */
    #####: 9457:          if( c==cEnd ){
    #####: 9458:            cEnd = 0;
    #####: 9459:          }else if( c=='"' || c=='\'' || c=='`' ){
    #####: 9460:            cEnd = c;
    #####: 9461:          }else if( c=='[' ){
    #####: 9462:            cEnd = ']';
    #####: 9463:          }else if( c=='-' && z[i+1]=='-' ){
    #####: 9464:            cEnd = '\n';
    #####: 9465:          }else if( c=='(' ){
    #####: 9466:            nParen++;
    #####: 9467:          }else if( c==')' ){
    #####: 9468:            nParen--;
    #####: 9469:            if( nLine>0 && nParen==0 && j>0 ){
    #####: 9470:              printSchemaLineN(p->out, z, j, "\n");
    #####: 9471:              j = 0;
        -: 9472:            }
        -: 9473:          }
    #####: 9474:          z[j++] = c;
    #####: 9475:          if( nParen==1 && cEnd==0
    #####: 9476:           && (c=='(' || c=='\n' || (c==',' && !wsToEol(z+i+1)))
        -: 9477:          ){
    #####: 9478:            if( c=='\n' ) j--;
    #####: 9479:            printSchemaLineN(p->out, z, j, "\n  ");
    #####: 9480:            j = 0;
    #####: 9481:            nLine++;
    #####: 9482:            while( IsSpace(z[i+1]) ){ i++; }
        -: 9483:          }
        -: 9484:        }
    #####: 9485:        z[j] = 0;
        -: 9486:      }
    #####: 9487:      printSchemaLine(p->out, z, ";\n");
    #####: 9488:      sqlite3_free(z);
    #####: 9489:      break;
        -: 9490:    }
    #####: 9491:    case MODE_List: {
    #####: 9492:      if( p->cnt++==0 && p->showHeader ){
    #####: 9493:        for(i=0; i<nArg; i++){
    #####: 9494:          utf8_printf(p->out,"%s%s",azCol[i],
    #####: 9495:                  i==nArg-1 ? p->rowSeparator : p->colSeparator);
        -: 9496:        }
        -: 9497:      }
    #####: 9498:      if( azArg==0 ) break;
    #####: 9499:      for(i=0; i<nArg; i++){
    #####: 9500:        char *z = azArg[i];
    #####: 9501:        if( z==0 ) z = p->nullValue;
    #####: 9502:        utf8_printf(p->out, "%s", z);
    #####: 9503:        if( i<nArg-1 ){
    #####: 9504:          utf8_printf(p->out, "%s", p->colSeparator);
        -: 9505:        }else{
    #####: 9506:          utf8_printf(p->out, "%s", p->rowSeparator);
        -: 9507:        }
        -: 9508:      }
    #####: 9509:      break;
        -: 9510:    }
    #####: 9511:    case MODE_Html: {
    #####: 9512:      if( p->cnt++==0 && p->showHeader ){
    #####: 9513:        raw_printf(p->out,"<TR>");
    #####: 9514:        for(i=0; i<nArg; i++){
    #####: 9515:          raw_printf(p->out,"<TH>");
    #####: 9516:          output_html_string(p->out, azCol[i]);
    #####: 9517:          raw_printf(p->out,"</TH>\n");
        -: 9518:        }
    #####: 9519:        raw_printf(p->out,"</TR>\n");
        -: 9520:      }
    #####: 9521:      if( azArg==0 ) break;
    #####: 9522:      raw_printf(p->out,"<TR>");
    #####: 9523:      for(i=0; i<nArg; i++){
    #####: 9524:        raw_printf(p->out,"<TD>");
    #####: 9525:        output_html_string(p->out, azArg[i] ? azArg[i] : p->nullValue);
    #####: 9526:        raw_printf(p->out,"</TD>\n");
        -: 9527:      }
    #####: 9528:      raw_printf(p->out,"</TR>\n");
    #####: 9529:      break;
        -: 9530:    }
    #####: 9531:    case MODE_Tcl: {
    #####: 9532:      if( p->cnt++==0 && p->showHeader ){
    #####: 9533:        for(i=0; i<nArg; i++){
    #####: 9534:          output_c_string(p->out,azCol[i] ? azCol[i] : "");
    #####: 9535:          if(i<nArg-1) utf8_printf(p->out, "%s", p->colSeparator);
        -: 9536:        }
    #####: 9537:        utf8_printf(p->out, "%s", p->rowSeparator);
        -: 9538:      }
    #####: 9539:      if( azArg==0 ) break;
    #####: 9540:      for(i=0; i<nArg; i++){
    #####: 9541:        output_c_string(p->out, azArg[i] ? azArg[i] : p->nullValue);
    #####: 9542:        if(i<nArg-1) utf8_printf(p->out, "%s", p->colSeparator);
        -: 9543:      }
    #####: 9544:      utf8_printf(p->out, "%s", p->rowSeparator);
    #####: 9545:      break;
        -: 9546:    }
    #####: 9547:    case MODE_Csv: {
        -: 9548:      setBinaryMode(p->out, 1);
    #####: 9549:      if( p->cnt++==0 && p->showHeader ){
    #####: 9550:        for(i=0; i<nArg; i++){
    #####: 9551:          output_csv(p, azCol[i] ? azCol[i] : "", i<nArg-1);
        -: 9552:        }
    #####: 9553:        utf8_printf(p->out, "%s", p->rowSeparator);
        -: 9554:      }
    #####: 9555:      if( nArg>0 ){
    #####: 9556:        for(i=0; i<nArg; i++){
    #####: 9557:          output_csv(p, azArg[i], i<nArg-1);
        -: 9558:        }
    #####: 9559:        utf8_printf(p->out, "%s", p->rowSeparator);
        -: 9560:      }
        -: 9561:      setTextMode(p->out, 1);
    #####: 9562:      break;
        -: 9563:    }
    #####: 9564:    case MODE_Insert: {
    #####: 9565:      if( azArg==0 ) break;
    #####: 9566:      utf8_printf(p->out,"INSERT INTO %s",p->zDestTable);
    #####: 9567:      if( p->showHeader ){
    #####: 9568:        raw_printf(p->out,"(");
    #####: 9569:        for(i=0; i<nArg; i++){
    #####: 9570:          if( i>0 ) raw_printf(p->out, ",");
    #####: 9571:          if( quoteChar(azCol[i]) ){
    #####: 9572:            char *z = sqlite3_mprintf("\"%w\"", azCol[i]);
    #####: 9573:            utf8_printf(p->out, "%s", z);
    #####: 9574:            sqlite3_free(z);
        -: 9575:          }else{
    #####: 9576:            raw_printf(p->out, "%s", azCol[i]);
        -: 9577:          }
        -: 9578:        }
    #####: 9579:        raw_printf(p->out,")");
        -: 9580:      }
    #####: 9581:      p->cnt++;
    #####: 9582:      for(i=0; i<nArg; i++){
    #####: 9583:        raw_printf(p->out, i>0 ? "," : " VALUES(");
    #####: 9584:        if( (azArg[i]==0) || (aiType && aiType[i]==SQLITE_NULL) ){
    #####: 9585:          utf8_printf(p->out,"NULL");
    #####: 9586:        }else if( aiType && aiType[i]==SQLITE_TEXT ){
    #####: 9587:          if( ShellHasFlag(p, SHFLG_Newlines) ){
    #####: 9588:            output_quoted_string(p->out, azArg[i]);
        -: 9589:          }else{
    #####: 9590:            output_quoted_escaped_string(p->out, azArg[i]);
        -: 9591:          }
    #####: 9592:        }else if( aiType && aiType[i]==SQLITE_INTEGER ){
    #####: 9593:          utf8_printf(p->out,"%s", azArg[i]);
    #####: 9594:        }else if( aiType && aiType[i]==SQLITE_FLOAT ){
        -: 9595:          char z[50];
    #####: 9596:          double r = sqlite3_column_double(p->pStmt, i);
        -: 9597:          sqlite3_uint64 ur;
    #####: 9598:          memcpy(&ur,&r,sizeof(r));
    #####: 9599:          if( ur==0x7ff0000000000000LL ){
    #####: 9600:            raw_printf(p->out, "1e999");
    #####: 9601:          }else if( ur==0xfff0000000000000LL ){
    #####: 9602:            raw_printf(p->out, "-1e999");
        -: 9603:          }else{
    #####: 9604:            sqlite3_snprintf(50,z,"%!.20g", r);
    #####: 9605:            raw_printf(p->out, "%s", z);
        -: 9606:          }
    #####: 9607:        }else if( aiType && aiType[i]==SQLITE_BLOB && p->pStmt ){
    #####: 9608:          const void *pBlob = sqlite3_column_blob(p->pStmt, i);
    #####: 9609:          int nBlob = sqlite3_column_bytes(p->pStmt, i);
    #####: 9610:          output_hex_blob(p->out, pBlob, nBlob);
    #####: 9611:        }else if( isNumber(azArg[i], 0) ){
    #####: 9612:          utf8_printf(p->out,"%s", azArg[i]);
    #####: 9613:        }else if( ShellHasFlag(p, SHFLG_Newlines) ){
    #####: 9614:          output_quoted_string(p->out, azArg[i]);
        -: 9615:        }else{
    #####: 9616:          output_quoted_escaped_string(p->out, azArg[i]);
        -: 9617:        }
        -: 9618:      }
    #####: 9619:      raw_printf(p->out,");\n");
    #####: 9620:      break;
        -: 9621:    }
    #####: 9622:    case MODE_Quote: {
    #####: 9623:      if( azArg==0 ) break;
    #####: 9624:      if( p->cnt==0 && p->showHeader ){
    #####: 9625:        for(i=0; i<nArg; i++){
    #####: 9626:          if( i>0 ) raw_printf(p->out, ",");
    #####: 9627:          output_quoted_string(p->out, azCol[i]);
        -: 9628:        }
    #####: 9629:        raw_printf(p->out,"\n");
        -: 9630:      }
    #####: 9631:      p->cnt++;
    #####: 9632:      for(i=0; i<nArg; i++){
    #####: 9633:        if( i>0 ) raw_printf(p->out, ",");
    #####: 9634:        if( (azArg[i]==0) || (aiType && aiType[i]==SQLITE_NULL) ){
    #####: 9635:          utf8_printf(p->out,"NULL");
    #####: 9636:        }else if( aiType && aiType[i]==SQLITE_TEXT ){
    #####: 9637:          output_quoted_string(p->out, azArg[i]);
    #####: 9638:        }else if( aiType && aiType[i]==SQLITE_INTEGER ){
    #####: 9639:          utf8_printf(p->out,"%s", azArg[i]);
    #####: 9640:        }else if( aiType && aiType[i]==SQLITE_FLOAT ){
        -: 9641:          char z[50];
    #####: 9642:          double r = sqlite3_column_double(p->pStmt, i);
    #####: 9643:          sqlite3_snprintf(50,z,"%!.20g", r);
    #####: 9644:          raw_printf(p->out, "%s", z);
    #####: 9645:        }else if( aiType && aiType[i]==SQLITE_BLOB && p->pStmt ){
    #####: 9646:          const void *pBlob = sqlite3_column_blob(p->pStmt, i);
    #####: 9647:          int nBlob = sqlite3_column_bytes(p->pStmt, i);
    #####: 9648:          output_hex_blob(p->out, pBlob, nBlob);
    #####: 9649:        }else if( isNumber(azArg[i], 0) ){
    #####: 9650:          utf8_printf(p->out,"%s", azArg[i]);
        -: 9651:        }else{
    #####: 9652:          output_quoted_string(p->out, azArg[i]);
        -: 9653:        }
        -: 9654:      }
    #####: 9655:      raw_printf(p->out,"\n");
    #####: 9656:      break;
        -: 9657:    }
    #####: 9658:    case MODE_Ascii: {
    #####: 9659:      if( p->cnt++==0 && p->showHeader ){
    #####: 9660:        for(i=0; i<nArg; i++){
    #####: 9661:          if( i>0 ) utf8_printf(p->out, "%s", p->colSeparator);
    #####: 9662:          utf8_printf(p->out,"%s",azCol[i] ? azCol[i] : "");
        -: 9663:        }
    #####: 9664:        utf8_printf(p->out, "%s", p->rowSeparator);
        -: 9665:      }
    #####: 9666:      if( azArg==0 ) break;
    #####: 9667:      for(i=0; i<nArg; i++){
    #####: 9668:        if( i>0 ) utf8_printf(p->out, "%s", p->colSeparator);
    #####: 9669:        utf8_printf(p->out,"%s",azArg[i] ? azArg[i] : p->nullValue);
        -: 9670:      }
    #####: 9671:      utf8_printf(p->out, "%s", p->rowSeparator);
    #####: 9672:      break;
        -: 9673:    }
    #####: 9674:    case MODE_EQP: {
    #####: 9675:      eqp_append(p, atoi(azArg[0]), atoi(azArg[1]), azArg[3]);
    #####: 9676:      break;
        -: 9677:    }
        -: 9678:  }
    #####: 9679:  return 0;
        -: 9680:}
        -: 9681:
        -: 9682:/*
        -: 9683:** This is the callback routine that the SQLite library
        -: 9684:** invokes for each row of a query result.
        -: 9685:*/
    #####: 9686:static int callback(void *pArg, int nArg, char **azArg, char **azCol){
        -: 9687:  /* since we don't have type info, call the shell_callback with a NULL value */
    #####: 9688:  return shell_callback(pArg, nArg, azArg, azCol, NULL);
        -: 9689:}
        -: 9690:
        -: 9691:/*
        -: 9692:** This is the callback routine from sqlite3_exec() that appends all
        -: 9693:** output onto the end of a ShellText object.
        -: 9694:*/
    #####: 9695:static int captureOutputCallback(void *pArg, int nArg, char **azArg, char **az){
    #####: 9696:  ShellText *p = (ShellText*)pArg;
        -: 9697:  int i;
        -: 9698:  UNUSED_PARAMETER(az);
    #####: 9699:  if( azArg==0 ) return 0;
    #####: 9700:  if( p->n ) appendText(p, "|", 0);
    #####: 9701:  for(i=0; i<nArg; i++){
    #####: 9702:    if( i ) appendText(p, ",", 0);
    #####: 9703:    if( azArg[i] ) appendText(p, azArg[i], 0);
        -: 9704:  }
    #####: 9705:  return 0;
        -: 9706:}
        -: 9707:
        -: 9708:/*
        -: 9709:** Generate an appropriate SELFTEST table in the main database.
        -: 9710:*/
    #####: 9711:static void createSelftestTable(ShellState *p){
    #####: 9712:  char *zErrMsg = 0;
    #####: 9713:  sqlite3_exec(p->db,
        -: 9714:    "SAVEPOINT selftest_init;\n"
        -: 9715:    "CREATE TABLE IF NOT EXISTS selftest(\n"
        -: 9716:    "  tno INTEGER PRIMARY KEY,\n"   /* Test number */
        -: 9717:    "  op TEXT,\n"                   /* Operator:  memo run */
        -: 9718:    "  cmd TEXT,\n"                  /* Command text */
        -: 9719:    "  ans TEXT\n"                   /* Desired answer */
        -: 9720:    ");"
        -: 9721:    "CREATE TEMP TABLE [_shell$self](op,cmd,ans);\n"
        -: 9722:    "INSERT INTO [_shell$self](rowid,op,cmd)\n"
        -: 9723:    "  VALUES(coalesce((SELECT (max(tno)+100)/10 FROM selftest),10),\n"
        -: 9724:    "         'memo','Tests generated by --init');\n"
        -: 9725:    "INSERT INTO [_shell$self]\n"
        -: 9726:    "  SELECT 'run',\n"
        -: 9727:    "    'SELECT hex(sha3_query(''SELECT type,name,tbl_name,sql "
        -: 9728:                                 "FROM sqlite_master ORDER BY 2'',224))',\n"
        -: 9729:    "    hex(sha3_query('SELECT type,name,tbl_name,sql "
        -: 9730:                          "FROM sqlite_master ORDER BY 2',224));\n"
        -: 9731:    "INSERT INTO [_shell$self]\n"
        -: 9732:    "  SELECT 'run',"
        -: 9733:    "    'SELECT hex(sha3_query(''SELECT * FROM \"' ||"
        -: 9734:    "        printf('%w',name) || '\" NOT INDEXED'',224))',\n"
        -: 9735:    "    hex(sha3_query(printf('SELECT * FROM \"%w\" NOT INDEXED',name),224))\n"
        -: 9736:    "  FROM (\n"
        -: 9737:    "    SELECT name FROM sqlite_master\n"
        -: 9738:    "     WHERE type='table'\n"
        -: 9739:    "       AND name<>'selftest'\n"
        -: 9740:    "       AND coalesce(rootpage,0)>0\n"
        -: 9741:    "  )\n"
        -: 9742:    " ORDER BY name;\n"
        -: 9743:    "INSERT INTO [_shell$self]\n"
        -: 9744:    "  VALUES('run','PRAGMA integrity_check','ok');\n"
        -: 9745:    "INSERT INTO selftest(tno,op,cmd,ans)"
        -: 9746:    "  SELECT rowid*10,op,cmd,ans FROM [_shell$self];\n"
        -: 9747:    "DROP TABLE [_shell$self];"
        -: 9748:    ,0,0,&zErrMsg);
    #####: 9749:  if( zErrMsg ){
    #####: 9750:    utf8_printf(stderr, "SELFTEST initialization failure: %s\n", zErrMsg);
    #####: 9751:    sqlite3_free(zErrMsg);
        -: 9752:  }
    #####: 9753:  sqlite3_exec(p->db, "RELEASE selftest_init",0,0,0);
    #####: 9754:}
        -: 9755:
        -: 9756:
        -: 9757:/*
        -: 9758:** Set the destination table field of the ShellState structure to
        -: 9759:** the name of the table given.  Escape any quote characters in the
        -: 9760:** table name.
        -: 9761:*/
        2: 9762:static void set_table_name(ShellState *p, const char *zName){
        -: 9763:  int i, n;
        -: 9764:  char cQuote;
        -: 9765:  char *z;
        -: 9766:
        2: 9767:  if( p->zDestTable ){
    #####: 9768:    free(p->zDestTable);
    #####: 9769:    p->zDestTable = 0;
        -: 9770:  }
        2: 9771:  if( zName==0 ) return;
    #####: 9772:  cQuote = quoteChar(zName);
    #####: 9773:  n = strlen30(zName);
    #####: 9774:  if( cQuote ) n += n+2;
    #####: 9775:  z = p->zDestTable = malloc( n+1 );
    #####: 9776:  if( z==0 ) shell_out_of_memory();
    #####: 9777:  n = 0;
    #####: 9778:  if( cQuote ) z[n++] = cQuote;
    #####: 9779:  for(i=0; zName[i]; i++){
    #####: 9780:    z[n++] = zName[i];
    #####: 9781:    if( zName[i]==cQuote ) z[n++] = cQuote;
        -: 9782:  }
    #####: 9783:  if( cQuote ) z[n++] = cQuote;
    #####: 9784:  z[n] = 0;
        -: 9785:}
        -: 9786:
        -: 9787:
        -: 9788:/*
        -: 9789:** Execute a query statement that will generate SQL output.  Print
        -: 9790:** the result columns, comma-separated, on a line and then add a
        -: 9791:** semicolon terminator to the end of that line.
        -: 9792:**
        -: 9793:** If the number of columns is 1 and that column contains text "--"
        -: 9794:** then write the semicolon on a separate line.  That way, if a
        -: 9795:** "--" comment occurs at the end of the statement, the comment
        -: 9796:** won't consume the semicolon terminator.
        -: 9797:*/
    #####: 9798:static int run_table_dump_query(
        -: 9799:  ShellState *p,           /* Query context */
        -: 9800:  const char *zSelect,     /* SELECT statement to extract content */
        -: 9801:  const char *zFirstRow    /* Print before first row, if not NULL */
        -: 9802:){
        -: 9803:  sqlite3_stmt *pSelect;
        -: 9804:  int rc;
        -: 9805:  int nResult;
        -: 9806:  int i;
        -: 9807:  const char *z;
    #####: 9808:  rc = sqlite3_prepare_v2(p->db, zSelect, -1, &pSelect, 0);
    #####: 9809:  if( rc!=SQLITE_OK || !pSelect ){
    #####: 9810:    utf8_printf(p->out, "/**** ERROR: (%d) %s *****/\n", rc,
        -: 9811:                sqlite3_errmsg(p->db));
    #####: 9812:    if( (rc&0xff)!=SQLITE_CORRUPT ) p->nErr++;
    #####: 9813:    return rc;
        -: 9814:  }
    #####: 9815:  rc = sqlite3_step(pSelect);
    #####: 9816:  nResult = sqlite3_column_count(pSelect);
    #####: 9817:  while( rc==SQLITE_ROW ){
    #####: 9818:    if( zFirstRow ){
    #####: 9819:      utf8_printf(p->out, "%s", zFirstRow);
    #####: 9820:      zFirstRow = 0;
        -: 9821:    }
    #####: 9822:    z = (const char*)sqlite3_column_text(pSelect, 0);
    #####: 9823:    utf8_printf(p->out, "%s", z);
    #####: 9824:    for(i=1; i<nResult; i++){
    #####: 9825:      utf8_printf(p->out, ",%s", sqlite3_column_text(pSelect, i));
        -: 9826:    }
    #####: 9827:    if( z==0 ) z = "";
    #####: 9828:    while( z[0] && (z[0]!='-' || z[1]!='-') ) z++;
    #####: 9829:    if( z[0] ){
    #####: 9830:      raw_printf(p->out, "\n;\n");
        -: 9831:    }else{
    #####: 9832:      raw_printf(p->out, ";\n");
        -: 9833:    }
    #####: 9834:    rc = sqlite3_step(pSelect);
        -: 9835:  }
    #####: 9836:  rc = sqlite3_finalize(pSelect);
    #####: 9837:  if( rc!=SQLITE_OK ){
    #####: 9838:    utf8_printf(p->out, "/**** ERROR: (%d) %s *****/\n", rc,
        -: 9839:                sqlite3_errmsg(p->db));
    #####: 9840:    if( (rc&0xff)!=SQLITE_CORRUPT ) p->nErr++;
        -: 9841:  }
    #####: 9842:  return rc;
        -: 9843:}
        -: 9844:
        -: 9845:/*
        -: 9846:** Allocate space and save off current error string.
        -: 9847:*/
        2: 9848:static char *save_err_msg(
        -: 9849:  sqlite3 *db            /* Database to query */
        -: 9850:){
        2: 9851:  int nErrMsg = 1+strlen30(sqlite3_errmsg(db));
        2: 9852:  char *zErrMsg = sqlite3_malloc64(nErrMsg);
        2: 9853:  if( zErrMsg ){
        2: 9854:    memcpy(zErrMsg, sqlite3_errmsg(db), nErrMsg);
        -: 9855:  }
        2: 9856:  return zErrMsg;
        -: 9857:}
        -: 9858:
        -: 9859:#ifdef __linux__
        -: 9860:/*
        -: 9861:** Attempt to display I/O stats on Linux using /proc/PID/io
        -: 9862:*/
    #####: 9863:static void displayLinuxIoStats(FILE *out){
        -: 9864:  FILE *in;
        -: 9865:  char z[200];
    #####: 9866:  sqlite3_snprintf(sizeof(z), z, "/proc/%d/io", getpid());
    #####: 9867:  in = fopen(z, "rb");
    #####: 9868:  if( in==0 ) return;
    #####: 9869:  while( fgets(z, sizeof(z), in)!=0 ){
        -: 9870:    static const struct {
        -: 9871:      const char *zPattern;
        -: 9872:      const char *zDesc;
        -: 9873:    } aTrans[] = {
        -: 9874:      { "rchar: ",                  "Bytes received by read():" },
        -: 9875:      { "wchar: ",                  "Bytes sent to write():"    },
        -: 9876:      { "syscr: ",                  "Read() system calls:"      },
        -: 9877:      { "syscw: ",                  "Write() system calls:"     },
        -: 9878:      { "read_bytes: ",             "Bytes read from storage:"  },
        -: 9879:      { "write_bytes: ",            "Bytes written to storage:" },
        -: 9880:      { "cancelled_write_bytes: ",  "Cancelled write bytes:"    },
        -: 9881:    };
        -: 9882:    int i;
    #####: 9883:    for(i=0; i<ArraySize(aTrans); i++){
    #####: 9884:      int n = strlen30(aTrans[i].zPattern);
    #####: 9885:      if( strncmp(aTrans[i].zPattern, z, n)==0 ){
    #####: 9886:        utf8_printf(out, "%-36s %s", aTrans[i].zDesc, &z[n]);
    #####: 9887:        break;
        -: 9888:      }
        -: 9889:    }
        -: 9890:  }
    #####: 9891:  fclose(in);
        -: 9892:}
        -: 9893:#endif
        -: 9894:
        -: 9895:/*
        -: 9896:** Display a single line of status using 64-bit values.
        -: 9897:*/
    #####: 9898:static void displayStatLine(
        -: 9899:  ShellState *p,            /* The shell context */
        -: 9900:  char *zLabel,             /* Label for this one line */
        -: 9901:  char *zFormat,            /* Format for the result */
        -: 9902:  int iStatusCtrl,          /* Which status to display */
        -: 9903:  int bReset                /* True to reset the stats */
        -: 9904:){
    #####: 9905:  sqlite3_int64 iCur = -1;
    #####: 9906:  sqlite3_int64 iHiwtr = -1;
        -: 9907:  int i, nPercent;
        -: 9908:  char zLine[200];
    #####: 9909:  sqlite3_status64(iStatusCtrl, &iCur, &iHiwtr, bReset);
    #####: 9910:  for(i=0, nPercent=0; zFormat[i]; i++){
    #####: 9911:    if( zFormat[i]=='%' ) nPercent++;
        -: 9912:  }
    #####: 9913:  if( nPercent>1 ){
    #####: 9914:    sqlite3_snprintf(sizeof(zLine), zLine, zFormat, iCur, iHiwtr);
        -: 9915:  }else{
    #####: 9916:    sqlite3_snprintf(sizeof(zLine), zLine, zFormat, iHiwtr);
        -: 9917:  }
    #####: 9918:  raw_printf(p->out, "%-36s %s\n", zLabel, zLine);
    #####: 9919:}
        -: 9920:
        -: 9921:/*
        -: 9922:** Display memory stats.
        -: 9923:*/
    #####: 9924:static int display_stats(
        -: 9925:  sqlite3 *db,                /* Database to query */
        -: 9926:  ShellState *pArg,           /* Pointer to ShellState */
        -: 9927:  int bReset                  /* True to reset the stats */
        -: 9928:){
        -: 9929:  int iCur;
        -: 9930:  int iHiwtr;
        -: 9931:  FILE *out;
    #####: 9932:  if( pArg==0 || pArg->out==0 ) return 0;
    #####: 9933:  out = pArg->out;
        -: 9934:
    #####: 9935:  if( pArg->pStmt && (pArg->statsOn & 2) ){
        -: 9936:    int nCol, i, x;
    #####: 9937:    sqlite3_stmt *pStmt = pArg->pStmt;
        -: 9938:    char z[100];
    #####: 9939:    nCol = sqlite3_column_count(pStmt);
    #####: 9940:    raw_printf(out, "%-36s %d\n", "Number of output columns:", nCol);
    #####: 9941:    for(i=0; i<nCol; i++){
    #####: 9942:      sqlite3_snprintf(sizeof(z),z,"Column %d %nname:", i, &x);
    #####: 9943:      utf8_printf(out, "%-36s %s\n", z, sqlite3_column_name(pStmt,i));
        -: 9944:#ifndef SQLITE_OMIT_DECLTYPE
    #####: 9945:      sqlite3_snprintf(30, z+x, "declared type:");
    #####: 9946:      utf8_printf(out, "%-36s %s\n", z, sqlite3_column_decltype(pStmt, i));
        -: 9947:#endif
        -: 9948:#ifdef SQLITE_ENABLE_COLUMN_METADATA
        -: 9949:      sqlite3_snprintf(30, z+x, "database name:");
        -: 9950:      utf8_printf(out, "%-36s %s\n", z, sqlite3_column_database_name(pStmt,i));
        -: 9951:      sqlite3_snprintf(30, z+x, "table name:");
        -: 9952:      utf8_printf(out, "%-36s %s\n", z, sqlite3_column_table_name(pStmt,i));
        -: 9953:      sqlite3_snprintf(30, z+x, "origin name:");
        -: 9954:      utf8_printf(out, "%-36s %s\n", z, sqlite3_column_origin_name(pStmt,i));
        -: 9955:#endif
        -: 9956:    }
        -: 9957:  }
        -: 9958:
    #####: 9959:  displayStatLine(pArg, "Memory Used:",
        -: 9960:     "%lld (max %lld) bytes", SQLITE_STATUS_MEMORY_USED, bReset);
    #####: 9961:  displayStatLine(pArg, "Number of Outstanding Allocations:",
        -: 9962:     "%lld (max %lld)", SQLITE_STATUS_MALLOC_COUNT, bReset);
    #####: 9963:  if( pArg->shellFlgs & SHFLG_Pagecache ){
    #####: 9964:    displayStatLine(pArg, "Number of Pcache Pages Used:",
        -: 9965:       "%lld (max %lld) pages", SQLITE_STATUS_PAGECACHE_USED, bReset);
        -: 9966:  }
    #####: 9967:  displayStatLine(pArg, "Number of Pcache Overflow Bytes:",
        -: 9968:     "%lld (max %lld) bytes", SQLITE_STATUS_PAGECACHE_OVERFLOW, bReset);
    #####: 9969:  displayStatLine(pArg, "Largest Allocation:",
        -: 9970:     "%lld bytes", SQLITE_STATUS_MALLOC_SIZE, bReset);
    #####: 9971:  displayStatLine(pArg, "Largest Pcache Allocation:",
        -: 9972:     "%lld bytes", SQLITE_STATUS_PAGECACHE_SIZE, bReset);
        -: 9973:#ifdef YYTRACKMAXSTACKDEPTH
        -: 9974:  displayStatLine(pArg, "Deepest Parser Stack:",
        -: 9975:     "%lld (max %lld)", SQLITE_STATUS_PARSER_STACK, bReset);
        -: 9976:#endif
        -: 9977:
    #####: 9978:  if( db ){
    #####: 9979:    if( pArg->shellFlgs & SHFLG_Lookaside ){
    #####: 9980:      iHiwtr = iCur = -1;
    #####: 9981:      sqlite3_db_status(db, SQLITE_DBSTATUS_LOOKASIDE_USED,
        -: 9982:                        &iCur, &iHiwtr, bReset);
    #####: 9983:      raw_printf(pArg->out,
        -: 9984:              "Lookaside Slots Used:                %d (max %d)\n",
        -: 9985:              iCur, iHiwtr);
    #####: 9986:      sqlite3_db_status(db, SQLITE_DBSTATUS_LOOKASIDE_HIT,
        -: 9987:                        &iCur, &iHiwtr, bReset);
    #####: 9988:      raw_printf(pArg->out, "Successful lookaside attempts:       %d\n",
        -: 9989:              iHiwtr);
    #####: 9990:      sqlite3_db_status(db, SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE,
        -: 9991:                        &iCur, &iHiwtr, bReset);
    #####: 9992:      raw_printf(pArg->out, "Lookaside failures due to size:      %d\n",
        -: 9993:              iHiwtr);
    #####: 9994:      sqlite3_db_status(db, SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL,
        -: 9995:                        &iCur, &iHiwtr, bReset);
    #####: 9996:      raw_printf(pArg->out, "Lookaside failures due to OOM:       %d\n",
        -: 9997:              iHiwtr);
        -: 9998:    }
    #####: 9999:    iHiwtr = iCur = -1;
    #####:10000:    sqlite3_db_status(db, SQLITE_DBSTATUS_CACHE_USED, &iCur, &iHiwtr, bReset);
    #####:10001:    raw_printf(pArg->out, "Pager Heap Usage:                    %d bytes\n",
        -:10002:            iCur);
    #####:10003:    iHiwtr = iCur = -1;
    #####:10004:    sqlite3_db_status(db, SQLITE_DBSTATUS_CACHE_HIT, &iCur, &iHiwtr, 1);
    #####:10005:    raw_printf(pArg->out, "Page cache hits:                     %d\n", iCur);
    #####:10006:    iHiwtr = iCur = -1;
    #####:10007:    sqlite3_db_status(db, SQLITE_DBSTATUS_CACHE_MISS, &iCur, &iHiwtr, 1);
    #####:10008:    raw_printf(pArg->out, "Page cache misses:                   %d\n", iCur);
    #####:10009:    iHiwtr = iCur = -1;
    #####:10010:    sqlite3_db_status(db, SQLITE_DBSTATUS_CACHE_WRITE, &iCur, &iHiwtr, 1);
    #####:10011:    raw_printf(pArg->out, "Page cache writes:                   %d\n", iCur);
    #####:10012:    iHiwtr = iCur = -1;
    #####:10013:    sqlite3_db_status(db, SQLITE_DBSTATUS_CACHE_SPILL, &iCur, &iHiwtr, 1);
    #####:10014:    raw_printf(pArg->out, "Page cache spills:                   %d\n", iCur);
    #####:10015:    iHiwtr = iCur = -1;
    #####:10016:    sqlite3_db_status(db, SQLITE_DBSTATUS_SCHEMA_USED, &iCur, &iHiwtr, bReset);
    #####:10017:    raw_printf(pArg->out, "Schema Heap Usage:                   %d bytes\n",
        -:10018:            iCur);
    #####:10019:    iHiwtr = iCur = -1;
    #####:10020:    sqlite3_db_status(db, SQLITE_DBSTATUS_STMT_USED, &iCur, &iHiwtr, bReset);
    #####:10021:    raw_printf(pArg->out, "Statement Heap/Lookaside Usage:      %d bytes\n",
        -:10022:            iCur);
        -:10023:  }
        -:10024:
    #####:10025:  if( pArg->pStmt ){
    #####:10026:    iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_FULLSCAN_STEP,
        -:10027:                               bReset);
    #####:10028:    raw_printf(pArg->out, "Fullscan Steps:                      %d\n", iCur);
    #####:10029:    iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_SORT, bReset);
    #####:10030:    raw_printf(pArg->out, "Sort Operations:                     %d\n", iCur);
    #####:10031:    iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_AUTOINDEX,bReset);
    #####:10032:    raw_printf(pArg->out, "Autoindex Inserts:                   %d\n", iCur);
    #####:10033:    iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_VM_STEP, bReset);
    #####:10034:    raw_printf(pArg->out, "Virtual Machine Steps:               %d\n", iCur);
    #####:10035:    iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_REPREPARE, bReset);
    #####:10036:    raw_printf(pArg->out, "Reprepare operations:                %d\n", iCur);
    #####:10037:    iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_RUN, bReset);
    #####:10038:    raw_printf(pArg->out, "Number of times run:                 %d\n", iCur);
    #####:10039:    iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_MEMUSED, bReset);
    #####:10040:    raw_printf(pArg->out, "Memory used by prepared stmt:        %d\n", iCur);
        -:10041:  }
        -:10042:
        -:10043:#ifdef __linux__
    #####:10044:  displayLinuxIoStats(pArg->out);
        -:10045:#endif
        -:10046:
        -:10047:  /* Do not remove this machine readable comment: extra-stats-output-here */
        -:10048:
    #####:10049:  return 0;
        -:10050:}
        -:10051:
        -:10052:/*
        -:10053:** Display scan stats.
        -:10054:*/
    #####:10055:static void display_scanstats(
        -:10056:  sqlite3 *db,                    /* Database to query */
        -:10057:  ShellState *pArg                /* Pointer to ShellState */
        -:10058:){
        -:10059:#ifndef SQLITE_ENABLE_STMT_SCANSTATUS
        -:10060:  UNUSED_PARAMETER(db);
        -:10061:  UNUSED_PARAMETER(pArg);
        -:10062:#else
        -:10063:  int i, k, n, mx;
        -:10064:  raw_printf(pArg->out, "-------- scanstats --------\n");
        -:10065:  mx = 0;
        -:10066:  for(k=0; k<=mx; k++){
        -:10067:    double rEstLoop = 1.0;
        -:10068:    for(i=n=0; 1; i++){
        -:10069:      sqlite3_stmt *p = pArg->pStmt;
        -:10070:      sqlite3_int64 nLoop, nVisit;
        -:10071:      double rEst;
        -:10072:      int iSid;
        -:10073:      const char *zExplain;
        -:10074:      if( sqlite3_stmt_scanstatus(p, i, SQLITE_SCANSTAT_NLOOP, (void*)&nLoop) ){
        -:10075:        break;
        -:10076:      }
        -:10077:      sqlite3_stmt_scanstatus(p, i, SQLITE_SCANSTAT_SELECTID, (void*)&iSid);
        -:10078:      if( iSid>mx ) mx = iSid;
        -:10079:      if( iSid!=k ) continue;
        -:10080:      if( n==0 ){
        -:10081:        rEstLoop = (double)nLoop;
        -:10082:        if( k>0 ) raw_printf(pArg->out, "-------- subquery %d -------\n", k);
        -:10083:      }
        -:10084:      n++;
        -:10085:      sqlite3_stmt_scanstatus(p, i, SQLITE_SCANSTAT_NVISIT, (void*)&nVisit);
        -:10086:      sqlite3_stmt_scanstatus(p, i, SQLITE_SCANSTAT_EST, (void*)&rEst);
        -:10087:      sqlite3_stmt_scanstatus(p, i, SQLITE_SCANSTAT_EXPLAIN, (void*)&zExplain);
        -:10088:      utf8_printf(pArg->out, "Loop %2d: %s\n", n, zExplain);
        -:10089:      rEstLoop *= rEst;
        -:10090:      raw_printf(pArg->out,
        -:10091:          "         nLoop=%-8lld nRow=%-8lld estRow=%-8lld estRow/Loop=%-8g\n",
        -:10092:          nLoop, nVisit, (sqlite3_int64)(rEstLoop+0.5), rEst
        -:10093:      );
        -:10094:    }
        -:10095:  }
        -:10096:  raw_printf(pArg->out, "---------------------------\n");
        -:10097:#endif
    #####:10098:}
        -:10099:
        -:10100:/*
        -:10101:** Parameter azArray points to a zero-terminated array of strings. zStr
        -:10102:** points to a single nul-terminated string. Return non-zero if zStr
        -:10103:** is equal, according to strcmp(), to any of the strings in the array.
        -:10104:** Otherwise, return zero.
        -:10105:*/
    #####:10106:static int str_in_array(const char *zStr, const char **azArray){
        -:10107:  int i;
    #####:10108:  for(i=0; azArray[i]; i++){
    #####:10109:    if( 0==strcmp(zStr, azArray[i]) ) return 1;
        -:10110:  }
    #####:10111:  return 0;
        -:10112:}
        -:10113:
        -:10114:/*
        -:10115:** If compiled statement pSql appears to be an EXPLAIN statement, allocate
        -:10116:** and populate the ShellState.aiIndent[] array with the number of
        -:10117:** spaces each opcode should be indented before it is output.
        -:10118:**
        -:10119:** The indenting rules are:
        -:10120:**
        -:10121:**     * For each "Next", "Prev", "VNext" or "VPrev" instruction, indent
        -:10122:**       all opcodes that occur between the p2 jump destination and the opcode
        -:10123:**       itself by 2 spaces.
        -:10124:**
        -:10125:**     * For each "Goto", if the jump destination is earlier in the program
        -:10126:**       and ends on one of:
        -:10127:**          Yield  SeekGt  SeekLt  RowSetRead  Rewind
        -:10128:**       or if the P1 parameter is one instead of zero,
        -:10129:**       then indent all opcodes between the earlier instruction
        -:10130:**       and "Goto" by 2 spaces.
        -:10131:*/
    #####:10132:static void explain_data_prepare(ShellState *p, sqlite3_stmt *pSql){
        -:10133:  const char *zSql;               /* The text of the SQL statement */
        -:10134:  const char *z;                  /* Used to check if this is an EXPLAIN */
    #####:10135:  int *abYield = 0;               /* True if op is an OP_Yield */
    #####:10136:  int nAlloc = 0;                 /* Allocated size of p->aiIndent[], abYield */
        -:10137:  int iOp;                        /* Index of operation in p->aiIndent[] */
        -:10138:
    #####:10139:  const char *azNext[] = { "Next", "Prev", "VPrev", "VNext", "SorterNext", 0 };
    #####:10140:  const char *azYield[] = { "Yield", "SeekLT", "SeekGT", "RowSetRead",
        -:10141:                            "Rewind", 0 };
    #####:10142:  const char *azGoto[] = { "Goto", 0 };
        -:10143:
        -:10144:  /* Try to figure out if this is really an EXPLAIN statement. If this
        -:10145:  ** cannot be verified, return early.  */
    #####:10146:  if( sqlite3_column_count(pSql)!=8 ){
    #####:10147:    p->cMode = p->mode;
    #####:10148:    return;
        -:10149:  }
    #####:10150:  zSql = sqlite3_sql(pSql);
    #####:10151:  if( zSql==0 ) return;
    #####:10152:  for(z=zSql; *z==' ' || *z=='\t' || *z=='\n' || *z=='\f' || *z=='\r'; z++);
    #####:10153:  if( sqlite3_strnicmp(z, "explain", 7) ){
    #####:10154:    p->cMode = p->mode;
    #####:10155:    return;
        -:10156:  }
        -:10157:
    #####:10158:  for(iOp=0; SQLITE_ROW==sqlite3_step(pSql); iOp++){
        -:10159:    int i;
    #####:10160:    int iAddr = sqlite3_column_int(pSql, 0);
    #####:10161:    const char *zOp = (const char*)sqlite3_column_text(pSql, 1);
        -:10162:
        -:10163:    /* Set p2 to the P2 field of the current opcode. Then, assuming that
        -:10164:    ** p2 is an instruction address, set variable p2op to the index of that
        -:10165:    ** instruction in the aiIndent[] array. p2 and p2op may be different if
        -:10166:    ** the current instruction is part of a sub-program generated by an
        -:10167:    ** SQL trigger or foreign key.  */
    #####:10168:    int p2 = sqlite3_column_int(pSql, 3);
    #####:10169:    int p2op = (p2 + (iOp-iAddr));
        -:10170:
        -:10171:    /* Grow the p->aiIndent array as required */
    #####:10172:    if( iOp>=nAlloc ){
    #####:10173:      if( iOp==0 ){
        -:10174:        /* Do further verfication that this is explain output.  Abort if
        -:10175:        ** it is not */
        -:10176:        static const char *explainCols[] = {
        -:10177:           "addr", "opcode", "p1", "p2", "p3", "p4", "p5", "comment" };
        -:10178:        int jj;
    #####:10179:        for(jj=0; jj<ArraySize(explainCols); jj++){
    #####:10180:          if( strcmp(sqlite3_column_name(pSql,jj),explainCols[jj])!=0 ){
    #####:10181:            p->cMode = p->mode;
    #####:10182:            sqlite3_reset(pSql);
    #####:10183:            return;
        -:10184:          }
        -:10185:        }
        -:10186:      }
    #####:10187:      nAlloc += 100;
    #####:10188:      p->aiIndent = (int*)sqlite3_realloc64(p->aiIndent, nAlloc*sizeof(int));
    #####:10189:      if( p->aiIndent==0 ) shell_out_of_memory();
    #####:10190:      abYield = (int*)sqlite3_realloc64(abYield, nAlloc*sizeof(int));
    #####:10191:      if( abYield==0 ) shell_out_of_memory();
        -:10192:    }
    #####:10193:    abYield[iOp] = str_in_array(zOp, azYield);
    #####:10194:    p->aiIndent[iOp] = 0;
    #####:10195:    p->nIndent = iOp+1;
        -:10196:
    #####:10197:    if( str_in_array(zOp, azNext) ){
    #####:10198:      for(i=p2op; i<iOp; i++) p->aiIndent[i] += 2;
        -:10199:    }
    #####:10200:    if( str_in_array(zOp, azGoto) && p2op<p->nIndent
    #####:10201:     && (abYield[p2op] || sqlite3_column_int(pSql, 2))
        -:10202:    ){
    #####:10203:      for(i=p2op; i<iOp; i++) p->aiIndent[i] += 2;
        -:10204:    }
        -:10205:  }
        -:10206:
    #####:10207:  p->iIndent = 0;
    #####:10208:  sqlite3_free(abYield);
    #####:10209:  sqlite3_reset(pSql);
        -:10210:}
        -:10211:
        -:10212:/*
        -:10213:** Free the array allocated by explain_data_prepare().
        -:10214:*/
    #####:10215:static void explain_data_delete(ShellState *p){
    #####:10216:  sqlite3_free(p->aiIndent);
    #####:10217:  p->aiIndent = 0;
    #####:10218:  p->nIndent = 0;
    #####:10219:  p->iIndent = 0;
    #####:10220:}
        -:10221:
        -:10222:/*
        -:10223:** Disable and restore .wheretrace and .selecttrace settings.
        -:10224:*/
        -:10225:#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_SELECTTRACE)
        -:10226:extern int sqlite3SelectTrace;
        -:10227:static int savedSelectTrace;
        -:10228:#endif
        -:10229:#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)
        -:10230:extern int sqlite3WhereTrace;
        -:10231:static int savedWhereTrace;
        -:10232:#endif
    #####:10233:static void disable_debug_trace_modes(void){
        -:10234:#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_SELECTTRACE)
        -:10235:  savedSelectTrace = sqlite3SelectTrace;
        -:10236:  sqlite3SelectTrace = 0;
        -:10237:#endif
        -:10238:#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)
        -:10239:  savedWhereTrace = sqlite3WhereTrace;
        -:10240:  sqlite3WhereTrace = 0;
        -:10241:#endif
    #####:10242:}
    #####:10243:static void restore_debug_trace_modes(void){
        -:10244:#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_SELECTTRACE)
        -:10245:  sqlite3SelectTrace = savedSelectTrace;
        -:10246:#endif
        -:10247:#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)
        -:10248:  sqlite3WhereTrace = savedWhereTrace;
        -:10249:#endif
    #####:10250:}
        -:10251:
        -:10252:/*
        -:10253:** Run a prepared statement
        -:10254:*/
    #####:10255:static void exec_prepared_stmt(
        -:10256:  ShellState *pArg,                                /* Pointer to ShellState */
        -:10257:  sqlite3_stmt *pStmt                              /* Statment to run */
        -:10258:){
        -:10259:  int rc;
        -:10260:
        -:10261:  /* perform the first step.  this will tell us if we
        -:10262:  ** have a result set or not and how wide it is.
        -:10263:  */
    #####:10264:  rc = sqlite3_step(pStmt);
        -:10265:  /* if we have a result set... */
    #####:10266:  if( SQLITE_ROW == rc ){
        -:10267:    /* allocate space for col name ptr, value ptr, and type */
    #####:10268:    int nCol = sqlite3_column_count(pStmt);
    #####:10269:    void *pData = sqlite3_malloc64(3*nCol*sizeof(const char*) + 1);
    #####:10270:    if( !pData ){
    #####:10271:      rc = SQLITE_NOMEM;
        -:10272:    }else{
    #####:10273:      char **azCols = (char **)pData;      /* Names of result columns */
    #####:10274:      char **azVals = &azCols[nCol];       /* Results */
    #####:10275:      int *aiTypes = (int *)&azVals[nCol]; /* Result types */
        -:10276:      int i, x;
        -:10277:      assert(sizeof(int) <= sizeof(char *));
        -:10278:      /* save off ptrs to column names */
    #####:10279:      for(i=0; i<nCol; i++){
    #####:10280:        azCols[i] = (char *)sqlite3_column_name(pStmt, i);
        -:10281:      }
        -:10282:      do{
        -:10283:        /* extract the data and data types */
    #####:10284:        for(i=0; i<nCol; i++){
    #####:10285:          aiTypes[i] = x = sqlite3_column_type(pStmt, i);
    #####:10286:          if( x==SQLITE_BLOB && pArg && pArg->cMode==MODE_Insert ){
    #####:10287:            azVals[i] = "";
        -:10288:          }else{
    #####:10289:            azVals[i] = (char*)sqlite3_column_text(pStmt, i);
        -:10290:          }
    #####:10291:          if( !azVals[i] && (aiTypes[i]!=SQLITE_NULL) ){
    #####:10292:            rc = SQLITE_NOMEM;
    #####:10293:            break; /* from for */
        -:10294:          }
        -:10295:        } /* end for */
        -:10296:
        -:10297:        /* if data and types extracted successfully... */
    #####:10298:        if( SQLITE_ROW == rc ){
        -:10299:          /* call the supplied callback with the result row data */
    #####:10300:          if( shell_callback(pArg, nCol, azVals, azCols, aiTypes) ){
    #####:10301:            rc = SQLITE_ABORT;
        -:10302:          }else{
    #####:10303:            rc = sqlite3_step(pStmt);
        -:10304:          }
        -:10305:        }
    #####:10306:      } while( SQLITE_ROW == rc );
    #####:10307:      sqlite3_free(pData);
        -:10308:    }
        -:10309:  }
    #####:10310:}
        -:10311:
        -:10312:#ifndef SQLITE_OMIT_VIRTUALTABLE
        -:10313:/*
        -:10314:** This function is called to process SQL if the previous shell command
        -:10315:** was ".expert". It passes the SQL in the second argument directly to
        -:10316:** the sqlite3expert object.
        -:10317:**
        -:10318:** If successful, SQLITE_OK is returned. Otherwise, an SQLite error
        -:10319:** code. In this case, (*pzErr) may be set to point to a buffer containing
        -:10320:** an English language error message. It is the responsibility of the
        -:10321:** caller to eventually free this buffer using sqlite3_free().
        -:10322:*/
    #####:10323:static int expertHandleSQL(
        -:10324:  ShellState *pState, 
        -:10325:  const char *zSql, 
        -:10326:  char **pzErr
        -:10327:){
        -:10328:  assert( pState->expert.pExpert );
        -:10329:  assert( pzErr==0 || *pzErr==0 );
    #####:10330:  return sqlite3_expert_sql(pState->expert.pExpert, zSql, pzErr);
        -:10331:}
        -:10332:
        -:10333:/*
        -:10334:** This function is called either to silently clean up the object
        -:10335:** created by the ".expert" command (if bCancel==1), or to generate a 
        -:10336:** report from it and then clean it up (if bCancel==0).
        -:10337:**
        -:10338:** If successful, SQLITE_OK is returned. Otherwise, an SQLite error
        -:10339:** code. In this case, (*pzErr) may be set to point to a buffer containing
        -:10340:** an English language error message. It is the responsibility of the
        -:10341:** caller to eventually free this buffer using sqlite3_free().
        -:10342:*/
    #####:10343:static int expertFinish(
        -:10344:  ShellState *pState,
        -:10345:  int bCancel,
        -:10346:  char **pzErr
        -:10347:){
    #####:10348:  int rc = SQLITE_OK;
    #####:10349:  sqlite3expert *p = pState->expert.pExpert;
        -:10350:  assert( p );
        -:10351:  assert( bCancel || pzErr==0 || *pzErr==0 );
    #####:10352:  if( bCancel==0 ){
    #####:10353:    FILE *out = pState->out;
    #####:10354:    int bVerbose = pState->expert.bVerbose;
        -:10355:
    #####:10356:    rc = sqlite3_expert_analyze(p, pzErr);
    #####:10357:    if( rc==SQLITE_OK ){
    #####:10358:      int nQuery = sqlite3_expert_count(p);
        -:10359:      int i;
        -:10360:
    #####:10361:      if( bVerbose ){
    #####:10362:        const char *zCand = sqlite3_expert_report(p,0,EXPERT_REPORT_CANDIDATES);
    #####:10363:        raw_printf(out, "-- Candidates -----------------------------\n");
    #####:10364:        raw_printf(out, "%s\n", zCand);
        -:10365:      }
    #####:10366:      for(i=0; i<nQuery; i++){
    #####:10367:        const char *zSql = sqlite3_expert_report(p, i, EXPERT_REPORT_SQL);
    #####:10368:        const char *zIdx = sqlite3_expert_report(p, i, EXPERT_REPORT_INDEXES);
    #####:10369:        const char *zEQP = sqlite3_expert_report(p, i, EXPERT_REPORT_PLAN);
    #####:10370:        if( zIdx==0 ) zIdx = "(no new indexes)\n";
    #####:10371:        if( bVerbose ){
    #####:10372:          raw_printf(out, "-- Query %d --------------------------------\n",i+1);
    #####:10373:          raw_printf(out, "%s\n\n", zSql);
        -:10374:        }
    #####:10375:        raw_printf(out, "%s\n", zIdx);
    #####:10376:        raw_printf(out, "%s\n", zEQP);
        -:10377:      }
        -:10378:    }
        -:10379:  }
    #####:10380:  sqlite3_expert_destroy(p);
    #####:10381:  pState->expert.pExpert = 0;
    #####:10382:  return rc;
        -:10383:}
        -:10384:
        -:10385:/*
        -:10386:** Implementation of ".expert" dot command.
        -:10387:*/
    #####:10388:static int expertDotCommand(
        -:10389:  ShellState *pState,             /* Current shell tool state */
        -:10390:  char **azArg,                   /* Array of arguments passed to dot command */
        -:10391:  int nArg                        /* Number of entries in azArg[] */
        -:10392:){
    #####:10393:  int rc = SQLITE_OK;
    #####:10394:  char *zErr = 0;
        -:10395:  int i;
    #####:10396:  int iSample = 0;
        -:10397:
        -:10398:  assert( pState->expert.pExpert==0 );
    #####:10399:  memset(&pState->expert, 0, sizeof(ExpertInfo));
        -:10400:
    #####:10401:  for(i=1; rc==SQLITE_OK && i<nArg; i++){
    #####:10402:    char *z = azArg[i];
        -:10403:    int n;
    #####:10404:    if( z[0]=='-' && z[1]=='-' ) z++;
    #####:10405:    n = strlen30(z);
    #####:10406:    if( n>=2 && 0==strncmp(z, "-verbose", n) ){
    #####:10407:      pState->expert.bVerbose = 1;
        -:10408:    }
    #####:10409:    else if( n>=2 && 0==strncmp(z, "-sample", n) ){
    #####:10410:      if( i==(nArg-1) ){
    #####:10411:        raw_printf(stderr, "option requires an argument: %s\n", z);
    #####:10412:        rc = SQLITE_ERROR;
        -:10413:      }else{
    #####:10414:        iSample = (int)integerValue(azArg[++i]);
    #####:10415:        if( iSample<0 || iSample>100 ){
    #####:10416:          raw_printf(stderr, "value out of range: %s\n", azArg[i]);
    #####:10417:          rc = SQLITE_ERROR;
        -:10418:        }
        -:10419:      }
        -:10420:    }
        -:10421:    else{
    #####:10422:      raw_printf(stderr, "unknown option: %s\n", z);
    #####:10423:      rc = SQLITE_ERROR;
        -:10424:    }
        -:10425:  }
        -:10426:
    #####:10427:  if( rc==SQLITE_OK ){
    #####:10428:    pState->expert.pExpert = sqlite3_expert_new(pState->db, &zErr);
    #####:10429:    if( pState->expert.pExpert==0 ){
    #####:10430:      raw_printf(stderr, "sqlite3_expert_new: %s\n", zErr);
    #####:10431:      rc = SQLITE_ERROR;
        -:10432:    }else{
    #####:10433:      sqlite3_expert_config(
        -:10434:          pState->expert.pExpert, EXPERT_CONFIG_SAMPLE, iSample
        -:10435:      );
        -:10436:    }
        -:10437:  }
        -:10438:
    #####:10439:  return rc;
        -:10440:}
        -:10441:#endif /* ifndef SQLITE_OMIT_VIRTUALTABLE */
        -:10442:
        -:10443:/*
        -:10444:** Execute a statement or set of statements.  Print
        -:10445:** any result rows/columns depending on the current mode
        -:10446:** set via the supplied callback.
        -:10447:**
        -:10448:** This is very similar to SQLite's built-in sqlite3_exec()
        -:10449:** function except it takes a slightly different callback
        -:10450:** and callback data argument.
        -:10451:*/
        2:10452:static int shell_exec(
        -:10453:  ShellState *pArg,                         /* Pointer to ShellState */
        -:10454:  const char *zSql,                         /* SQL to be evaluated */
        -:10455:  char **pzErrMsg                           /* Error msg written here */
        -:10456:){
        2:10457:  sqlite3_stmt *pStmt = NULL;     /* Statement to execute. */
        2:10458:  int rc = SQLITE_OK;             /* Return Code */
        -:10459:  int rc2;
        -:10460:  const char *zLeftover;          /* Tail of unprocessed SQL */
        2:10461:  sqlite3 *db = pArg->db;
        -:10462:
        2:10463:  if( pzErrMsg ){
        2:10464:    *pzErrMsg = NULL;
        -:10465:  }
        -:10466:
        -:10467:#ifndef SQLITE_OMIT_VIRTUALTABLE
        2:10468:  if( pArg->expert.pExpert ){
    #####:10469:    rc = expertHandleSQL(pArg, zSql, pzErrMsg);
    #####:10470:    return expertFinish(pArg, (rc!=SQLITE_OK), pzErrMsg);
        -:10471:  }
        -:10472:#endif
        -:10473:
        4:10474:  while( zSql[0] && (SQLITE_OK == rc) ){
        -:10475:    static const char *zStmtSql;
        2:10476:    rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, &zLeftover);
        2:10477:    if( SQLITE_OK != rc ){
        2:10478:      if( pzErrMsg ){
        2:10479:        *pzErrMsg = save_err_msg(db);
        -:10480:      }
        -:10481:    }else{
    #####:10482:      if( !pStmt ){
        -:10483:        /* this happens for a comment or white-space */
    #####:10484:        zSql = zLeftover;
    #####:10485:        while( IsSpace(zSql[0]) ) zSql++;
    #####:10486:        continue;
        -:10487:      }
    #####:10488:      zStmtSql = sqlite3_sql(pStmt);
    #####:10489:      if( zStmtSql==0 ) zStmtSql = "";
    #####:10490:      while( IsSpace(zStmtSql[0]) ) zStmtSql++;
        -:10491:
        -:10492:      /* save off the prepared statment handle and reset row count */
    #####:10493:      if( pArg ){
    #####:10494:        pArg->pStmt = pStmt;
    #####:10495:        pArg->cnt = 0;
        -:10496:      }
        -:10497:
        -:10498:      /* echo the sql statement if echo on */
    #####:10499:      if( pArg && ShellHasFlag(pArg, SHFLG_Echo) ){
    #####:10500:        utf8_printf(pArg->out, "%s\n", zStmtSql ? zStmtSql : zSql);
        -:10501:      }
        -:10502:
        -:10503:      /* Show the EXPLAIN QUERY PLAN if .eqp is on */
    #####:10504:      if( pArg && pArg->autoEQP && sqlite3_strlike("EXPLAIN%",zStmtSql,0)!=0 ){
        -:10505:        sqlite3_stmt *pExplain;
        -:10506:        char *zEQP;
    #####:10507:        int triggerEQP = 0;
    #####:10508:        disable_debug_trace_modes();
    #####:10509:        sqlite3_db_config(db, SQLITE_DBCONFIG_TRIGGER_EQP, -1, &triggerEQP);
    #####:10510:        if( pArg->autoEQP>=AUTOEQP_trigger ){
    #####:10511:          sqlite3_db_config(db, SQLITE_DBCONFIG_TRIGGER_EQP, 1, 0);
        -:10512:        }
    #####:10513:        zEQP = sqlite3_mprintf("EXPLAIN QUERY PLAN %s", zStmtSql);
    #####:10514:        rc = sqlite3_prepare_v2(db, zEQP, -1, &pExplain, 0);
    #####:10515:        if( rc==SQLITE_OK ){
    #####:10516:          while( sqlite3_step(pExplain)==SQLITE_ROW ){
    #####:10517:            const char *zEQPLine = (const char*)sqlite3_column_text(pExplain,3);
    #####:10518:            int iEqpId = sqlite3_column_int(pExplain, 0);
    #####:10519:            int iParentId = sqlite3_column_int(pExplain, 1);
    #####:10520:            if( zEQPLine[0]=='-' ) eqp_render(pArg);
    #####:10521:            eqp_append(pArg, iEqpId, iParentId, zEQPLine);
        -:10522:          }
    #####:10523:          eqp_render(pArg);
        -:10524:        }
    #####:10525:        sqlite3_finalize(pExplain);
    #####:10526:        sqlite3_free(zEQP);
    #####:10527:        if( pArg->autoEQP>=AUTOEQP_full ){
        -:10528:          /* Also do an EXPLAIN for ".eqp full" mode */
    #####:10529:          zEQP = sqlite3_mprintf("EXPLAIN %s", zStmtSql);
    #####:10530:          rc = sqlite3_prepare_v2(db, zEQP, -1, &pExplain, 0);
    #####:10531:          if( rc==SQLITE_OK ){
    #####:10532:            pArg->cMode = MODE_Explain;
    #####:10533:            explain_data_prepare(pArg, pExplain);
    #####:10534:            exec_prepared_stmt(pArg, pExplain);
    #####:10535:            explain_data_delete(pArg);
        -:10536:          }
    #####:10537:          sqlite3_finalize(pExplain);
    #####:10538:          sqlite3_free(zEQP);
        -:10539:        }
    #####:10540:        if( pArg->autoEQP>=AUTOEQP_trigger && triggerEQP==0 ){
    #####:10541:          sqlite3_db_config(db, SQLITE_DBCONFIG_TRIGGER_EQP, 0, 0);
        -:10542:          /* Reprepare pStmt before reactiving trace modes */
    #####:10543:          sqlite3_finalize(pStmt);
    #####:10544:          sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);
    #####:10545:          if( pArg ) pArg->pStmt = pStmt;
        -:10546:        }
    #####:10547:        restore_debug_trace_modes();
        -:10548:      }
        -:10549:
    #####:10550:      if( pArg ){
    #####:10551:        pArg->cMode = pArg->mode;
    #####:10552:        if( pArg->autoExplain ){
    #####:10553:          if( sqlite3_column_count(pStmt)==8
    #####:10554:           && sqlite3_strlike("EXPLAIN%", zStmtSql,0)==0
        -:10555:          ){
    #####:10556:            pArg->cMode = MODE_Explain;
        -:10557:          }
    #####:10558:          if( sqlite3_column_count(pStmt)==4
    #####:10559:           && sqlite3_strlike("EXPLAIN QUERY PLAN%", zStmtSql,0)==0 ){
    #####:10560:            pArg->cMode = MODE_EQP;
        -:10561:          }
        -:10562:        }
        -:10563:
        -:10564:        /* If the shell is currently in ".explain" mode, gather the extra
        -:10565:        ** data required to add indents to the output.*/
    #####:10566:        if( pArg->cMode==MODE_Explain ){
    #####:10567:          explain_data_prepare(pArg, pStmt);
        -:10568:        }
        -:10569:      }
        -:10570:
    #####:10571:      exec_prepared_stmt(pArg, pStmt);
    #####:10572:      explain_data_delete(pArg);
    #####:10573:      eqp_render(pArg);
        -:10574:
        -:10575:      /* print usage stats if stats on */
    #####:10576:      if( pArg && pArg->statsOn ){
    #####:10577:        display_stats(db, pArg, 0);
        -:10578:      }
        -:10579:
        -:10580:      /* print loop-counters if required */
    #####:10581:      if( pArg && pArg->scanstatsOn ){
    #####:10582:        display_scanstats(db, pArg);
        -:10583:      }
        -:10584:
        -:10585:      /* Finalize the statement just executed. If this fails, save a
        -:10586:      ** copy of the error message. Otherwise, set zSql to point to the
        -:10587:      ** next statement to execute. */
    #####:10588:      rc2 = sqlite3_finalize(pStmt);
    #####:10589:      if( rc!=SQLITE_NOMEM ) rc = rc2;
    #####:10590:      if( rc==SQLITE_OK ){
    #####:10591:        zSql = zLeftover;
    #####:10592:        while( IsSpace(zSql[0]) ) zSql++;
    #####:10593:      }else if( pzErrMsg ){
    #####:10594:        *pzErrMsg = save_err_msg(db);
        -:10595:      }
        -:10596:
        -:10597:      /* clear saved stmt handle */
    #####:10598:      if( pArg ){
    #####:10599:        pArg->pStmt = NULL;
        -:10600:      }
        -:10601:    }
        -:10602:  } /* end while */
        -:10603:
        2:10604:  return rc;
        -:10605:}
        -:10606:
        -:10607:/*
        -:10608:** Release memory previously allocated by tableColumnList().
        -:10609:*/
    #####:10610:static void freeColumnList(char **azCol){
        -:10611:  int i;
    #####:10612:  for(i=1; azCol[i]; i++){
    #####:10613:    sqlite3_free(azCol[i]);
        -:10614:  }
        -:10615:  /* azCol[0] is a static string */
    #####:10616:  sqlite3_free(azCol);
    #####:10617:}
        -:10618:
        -:10619:/*
        -:10620:** Return a list of pointers to strings which are the names of all
        -:10621:** columns in table zTab.   The memory to hold the names is dynamically
        -:10622:** allocated and must be released by the caller using a subsequent call
        -:10623:** to freeColumnList().
        -:10624:**
        -:10625:** The azCol[0] entry is usually NULL.  However, if zTab contains a rowid
        -:10626:** value that needs to be preserved, then azCol[0] is filled in with the
        -:10627:** name of the rowid column.
        -:10628:**
        -:10629:** The first regular column in the table is azCol[1].  The list is terminated
        -:10630:** by an entry with azCol[i]==0.
        -:10631:*/
    #####:10632:static char **tableColumnList(ShellState *p, const char *zTab){
    #####:10633:  char **azCol = 0;
        -:10634:  sqlite3_stmt *pStmt;
        -:10635:  char *zSql;
    #####:10636:  int nCol = 0;
    #####:10637:  int nAlloc = 0;
    #####:10638:  int nPK = 0;       /* Number of PRIMARY KEY columns seen */
    #####:10639:  int isIPK = 0;     /* True if one PRIMARY KEY column of type INTEGER */
    #####:10640:  int preserveRowid = ShellHasFlag(p, SHFLG_PreserveRowid);
        -:10641:  int rc;
        -:10642:
    #####:10643:  zSql = sqlite3_mprintf("PRAGMA table_info=%Q", zTab);
    #####:10644:  rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
    #####:10645:  sqlite3_free(zSql);
    #####:10646:  if( rc ) return 0;
    #####:10647:  while( sqlite3_step(pStmt)==SQLITE_ROW ){
    #####:10648:    if( nCol>=nAlloc-2 ){
    #####:10649:      nAlloc = nAlloc*2 + nCol + 10;
    #####:10650:      azCol = sqlite3_realloc(azCol, nAlloc*sizeof(azCol[0]));
    #####:10651:      if( azCol==0 ) shell_out_of_memory();
        -:10652:    }
    #####:10653:    azCol[++nCol] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 1));
    #####:10654:    if( sqlite3_column_int(pStmt, 5) ){
    #####:10655:      nPK++;
    #####:10656:      if( nPK==1
    #####:10657:       && sqlite3_stricmp((const char*)sqlite3_column_text(pStmt,2),
        -:10658:                          "INTEGER")==0
        -:10659:      ){
    #####:10660:        isIPK = 1;
        -:10661:      }else{
    #####:10662:        isIPK = 0;
        -:10663:      }
        -:10664:    }
        -:10665:  }
    #####:10666:  sqlite3_finalize(pStmt);
    #####:10667:  if( azCol==0 ) return 0;
    #####:10668:  azCol[0] = 0;
    #####:10669:  azCol[nCol+1] = 0;
        -:10670:
        -:10671:  /* The decision of whether or not a rowid really needs to be preserved
        -:10672:  ** is tricky.  We never need to preserve a rowid for a WITHOUT ROWID table
        -:10673:  ** or a table with an INTEGER PRIMARY KEY.  We are unable to preserve
        -:10674:  ** rowids on tables where the rowid is inaccessible because there are other
        -:10675:  ** columns in the table named "rowid", "_rowid_", and "oid".
        -:10676:  */
    #####:10677:  if( preserveRowid && isIPK ){
        -:10678:    /* If a single PRIMARY KEY column with type INTEGER was seen, then it
        -:10679:    ** might be an alise for the ROWID.  But it might also be a WITHOUT ROWID
        -:10680:    ** table or a INTEGER PRIMARY KEY DESC column, neither of which are
        -:10681:    ** ROWID aliases.  To distinguish these cases, check to see if
        -:10682:    ** there is a "pk" entry in "PRAGMA index_list".  There will be
        -:10683:    ** no "pk" index if the PRIMARY KEY really is an alias for the ROWID.
        -:10684:    */
    #####:10685:    zSql = sqlite3_mprintf("SELECT 1 FROM pragma_index_list(%Q)"
        -:10686:                           " WHERE origin='pk'", zTab);
    #####:10687:    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
    #####:10688:    sqlite3_free(zSql);
    #####:10689:    if( rc ){
    #####:10690:      freeColumnList(azCol);
    #####:10691:      return 0;
        -:10692:    }
    #####:10693:    rc = sqlite3_step(pStmt);
    #####:10694:    sqlite3_finalize(pStmt);
    #####:10695:    preserveRowid = rc==SQLITE_ROW;
        -:10696:  }
    #####:10697:  if( preserveRowid ){
        -:10698:    /* Only preserve the rowid if we can find a name to use for the
        -:10699:    ** rowid */
        -:10700:    static char *azRowid[] = { "rowid", "_rowid_", "oid" };
        -:10701:    int i, j;
    #####:10702:    for(j=0; j<3; j++){
    #####:10703:      for(i=1; i<=nCol; i++){
    #####:10704:        if( sqlite3_stricmp(azRowid[j],azCol[i])==0 ) break;
        -:10705:      }
    #####:10706:      if( i>nCol ){
        -:10707:        /* At this point, we know that azRowid[j] is not the name of any
        -:10708:        ** ordinary column in the table.  Verify that azRowid[j] is a valid
        -:10709:        ** name for the rowid before adding it to azCol[0].  WITHOUT ROWID
        -:10710:        ** tables will fail this last check */
    #####:10711:        rc = sqlite3_table_column_metadata(p->db,0,zTab,azRowid[j],0,0,0,0,0);
    #####:10712:        if( rc==SQLITE_OK ) azCol[0] = azRowid[j];
    #####:10713:        break;
        -:10714:      }
        -:10715:    }
        -:10716:  }
    #####:10717:  return azCol;
        -:10718:}
        -:10719:
        -:10720:/*
        -:10721:** Toggle the reverse_unordered_selects setting.
        -:10722:*/
    #####:10723:static void toggleSelectOrder(sqlite3 *db){
    #####:10724:  sqlite3_stmt *pStmt = 0;
    #####:10725:  int iSetting = 0;
        -:10726:  char zStmt[100];
    #####:10727:  sqlite3_prepare_v2(db, "PRAGMA reverse_unordered_selects", -1, &pStmt, 0);
    #####:10728:  if( sqlite3_step(pStmt)==SQLITE_ROW ){
    #####:10729:    iSetting = sqlite3_column_int(pStmt, 0);
        -:10730:  }
    #####:10731:  sqlite3_finalize(pStmt);
    #####:10732:  sqlite3_snprintf(sizeof(zStmt), zStmt,
        -:10733:       "PRAGMA reverse_unordered_selects(%d)", !iSetting);
    #####:10734:  sqlite3_exec(db, zStmt, 0, 0, 0);
    #####:10735:}
        -:10736:
        -:10737:/*
        -:10738:** This is a different callback routine used for dumping the database.
        -:10739:** Each row received by this callback consists of a table name,
        -:10740:** the table type ("index" or "table") and SQL to create the table.
        -:10741:** This routine should print text sufficient to recreate the table.
        -:10742:*/
    #####:10743:static int dump_callback(void *pArg, int nArg, char **azArg, char **azNotUsed){
        -:10744:  int rc;
        -:10745:  const char *zTable;
        -:10746:  const char *zType;
        -:10747:  const char *zSql;
    #####:10748:  ShellState *p = (ShellState *)pArg;
        -:10749:
        -:10750:  UNUSED_PARAMETER(azNotUsed);
    #####:10751:  if( nArg!=3 || azArg==0 ) return 0;
    #####:10752:  zTable = azArg[0];
    #####:10753:  zType = azArg[1];
    #####:10754:  zSql = azArg[2];
        -:10755:
    #####:10756:  if( strcmp(zTable, "sqlite_sequence")==0 ){
    #####:10757:    raw_printf(p->out, "DELETE FROM sqlite_sequence;\n");
    #####:10758:  }else if( sqlite3_strglob("sqlite_stat?", zTable)==0 ){
    #####:10759:    raw_printf(p->out, "ANALYZE sqlite_master;\n");
    #####:10760:  }else if( strncmp(zTable, "sqlite_", 7)==0 ){
    #####:10761:    return 0;
    #####:10762:  }else if( strncmp(zSql, "CREATE VIRTUAL TABLE", 20)==0 ){
        -:10763:    char *zIns;
    #####:10764:    if( !p->writableSchema ){
    #####:10765:      raw_printf(p->out, "PRAGMA writable_schema=ON;\n");
    #####:10766:      p->writableSchema = 1;
        -:10767:    }
    #####:10768:    zIns = sqlite3_mprintf(
        -:10769:       "INSERT INTO sqlite_master(type,name,tbl_name,rootpage,sql)"
        -:10770:       "VALUES('table','%q','%q',0,'%q');",
        -:10771:       zTable, zTable, zSql);
    #####:10772:    utf8_printf(p->out, "%s\n", zIns);
    #####:10773:    sqlite3_free(zIns);
    #####:10774:    return 0;
        -:10775:  }else{
    #####:10776:    printSchemaLine(p->out, zSql, ";\n");
        -:10777:  }
        -:10778:
    #####:10779:  if( strcmp(zType, "table")==0 ){
        -:10780:    ShellText sSelect;
        -:10781:    ShellText sTable;
        -:10782:    char **azCol;
        -:10783:    int i;
        -:10784:    char *savedDestTable;
        -:10785:    int savedMode;
        -:10786:
    #####:10787:    azCol = tableColumnList(p, zTable);
    #####:10788:    if( azCol==0 ){
    #####:10789:      p->nErr++;
    #####:10790:      return 0;
        -:10791:    }
        -:10792:
        -:10793:    /* Always quote the table name, even if it appears to be pure ascii,
        -:10794:    ** in case it is a keyword. Ex:  INSERT INTO "table" ... */
    #####:10795:    initText(&sTable);
    #####:10796:    appendText(&sTable, zTable, quoteChar(zTable));
        -:10797:    /* If preserving the rowid, add a column list after the table name.
        -:10798:    ** In other words:  "INSERT INTO tab(rowid,a,b,c,...) VALUES(...)"
        -:10799:    ** instead of the usual "INSERT INTO tab VALUES(...)".
        -:10800:    */
    #####:10801:    if( azCol[0] ){
    #####:10802:      appendText(&sTable, "(", 0);
    #####:10803:      appendText(&sTable, azCol[0], 0);
    #####:10804:      for(i=1; azCol[i]; i++){
    #####:10805:        appendText(&sTable, ",", 0);
    #####:10806:        appendText(&sTable, azCol[i], quoteChar(azCol[i]));
        -:10807:      }
    #####:10808:      appendText(&sTable, ")", 0);
        -:10809:    }
        -:10810:
        -:10811:    /* Build an appropriate SELECT statement */
    #####:10812:    initText(&sSelect);
    #####:10813:    appendText(&sSelect, "SELECT ", 0);
    #####:10814:    if( azCol[0] ){
    #####:10815:      appendText(&sSelect, azCol[0], 0);
    #####:10816:      appendText(&sSelect, ",", 0);
        -:10817:    }
    #####:10818:    for(i=1; azCol[i]; i++){
    #####:10819:      appendText(&sSelect, azCol[i], quoteChar(azCol[i]));
    #####:10820:      if( azCol[i+1] ){
    #####:10821:        appendText(&sSelect, ",", 0);
        -:10822:      }
        -:10823:    }
    #####:10824:    freeColumnList(azCol);
    #####:10825:    appendText(&sSelect, " FROM ", 0);
    #####:10826:    appendText(&sSelect, zTable, quoteChar(zTable));
        -:10827:
    #####:10828:    savedDestTable = p->zDestTable;
    #####:10829:    savedMode = p->mode;
    #####:10830:    p->zDestTable = sTable.z;
    #####:10831:    p->mode = p->cMode = MODE_Insert;
    #####:10832:    rc = shell_exec(p, sSelect.z, 0);
    #####:10833:    if( (rc&0xff)==SQLITE_CORRUPT ){
    #####:10834:      raw_printf(p->out, "/****** CORRUPTION ERROR *******/\n");
    #####:10835:      toggleSelectOrder(p->db);
    #####:10836:      shell_exec(p, sSelect.z, 0);
    #####:10837:      toggleSelectOrder(p->db);
        -:10838:    }
    #####:10839:    p->zDestTable = savedDestTable;
    #####:10840:    p->mode = savedMode;
    #####:10841:    freeText(&sTable);
    #####:10842:    freeText(&sSelect);
    #####:10843:    if( rc ) p->nErr++;
        -:10844:  }
    #####:10845:  return 0;
        -:10846:}
        -:10847:
        -:10848:/*
        -:10849:** Run zQuery.  Use dump_callback() as the callback routine so that
        -:10850:** the contents of the query are output as SQL statements.
        -:10851:**
        -:10852:** If we get a SQLITE_CORRUPT error, rerun the query after appending
        -:10853:** "ORDER BY rowid DESC" to the end.
        -:10854:*/
    #####:10855:static int run_schema_dump_query(
        -:10856:  ShellState *p,
        -:10857:  const char *zQuery
        -:10858:){
        -:10859:  int rc;
    #####:10860:  char *zErr = 0;
    #####:10861:  rc = sqlite3_exec(p->db, zQuery, dump_callback, p, &zErr);
    #####:10862:  if( rc==SQLITE_CORRUPT ){
        -:10863:    char *zQ2;
    #####:10864:    int len = strlen30(zQuery);
    #####:10865:    raw_printf(p->out, "/****** CORRUPTION ERROR *******/\n");
    #####:10866:    if( zErr ){
    #####:10867:      utf8_printf(p->out, "/****** %s ******/\n", zErr);
    #####:10868:      sqlite3_free(zErr);
    #####:10869:      zErr = 0;
        -:10870:    }
    #####:10871:    zQ2 = malloc( len+100 );
    #####:10872:    if( zQ2==0 ) return rc;
    #####:10873:    sqlite3_snprintf(len+100, zQ2, "%s ORDER BY rowid DESC", zQuery);
    #####:10874:    rc = sqlite3_exec(p->db, zQ2, dump_callback, p, &zErr);
    #####:10875:    if( rc ){
    #####:10876:      utf8_printf(p->out, "/****** ERROR: %s ******/\n", zErr);
        -:10877:    }else{
    #####:10878:      rc = SQLITE_CORRUPT;
        -:10879:    }
    #####:10880:    sqlite3_free(zErr);
    #####:10881:    free(zQ2);
        -:10882:  }
    #####:10883:  return rc;
        -:10884:}
        -:10885:
        -:10886:/*
        -:10887:** Text of help messages.
        -:10888:**
        -:10889:** The help text for each individual command begins with a line that starts
        -:10890:** with ".".  Subsequent lines are supplimental information.
        -:10891:**
        -:10892:** There must be two or more spaces between the end of the command and the
        -:10893:** start of the description of what that command does.
        -:10894:*/
        -:10895:static const char *(azHelp[]) = {
        -:10896:#if defined(SQLITE_HAVE_ZLIB) && !defined(SQLITE_OMIT_VIRTUALTABLE)
        -:10897:  ".archive ...             Manage SQL archives",
        -:10898:  "   Each command must have exactly one of the following options:",
        -:10899:  "     -c, --create               Create a new archive",
        -:10900:  "     -u, --update               Update or add files to an existing archive",
        -:10901:  "     -t, --list                 List contents of archive",
        -:10902:  "     -x, --extract              Extract files from archive",
        -:10903:  "   Optional arguments:",
        -:10904:  "     -v, --verbose              Print each filename as it is processed",
        -:10905:  "     -f FILE, --file FILE       Operate on archive FILE (default is current db)",
        -:10906:  "     -a FILE, --append FILE     Operate on FILE opened using the apndvfs VFS",
        -:10907:  "     -C DIR, --directory DIR    Change to directory DIR to read/extract files",
        -:10908:  "     -n, --dryrun               Show the SQL that would have occurred",
        -:10909:  "   Examples:",
        -:10910:  "     .ar -cf archive.sar foo bar  # Create archive.sar from files foo and bar",
        -:10911:  "     .ar -tf archive.sar          # List members of archive.sar",
        -:10912:  "     .ar -xvf archive.sar         # Verbosely extract files from archive.sar",
        -:10913:  "   See also:",
        -:10914:  "      http://sqlite.org/cli.html#sqlar_archive_support",
        -:10915:#endif
        -:10916:#ifndef SQLITE_OMIT_AUTHORIZATION
        -:10917:  ".auth ON|OFF             Show authorizer callbacks",
        -:10918:#endif
        -:10919:  ".backup ?DB? FILE        Backup DB (default \"main\") to FILE",
        -:10920:  "       --append            Use the appendvfs",
        -:10921:  ".bail on|off             Stop after hitting an error.  Default OFF",
        -:10922:  ".binary on|off           Turn binary output on or off.  Default OFF",
        -:10923:  ".cd DIRECTORY            Change the working directory to DIRECTORY",
        -:10924:  ".changes on|off          Show number of rows changed by SQL",
        -:10925:  ".check GLOB              Fail if output since .testcase does not match",
        -:10926:  ".clone NEWDB             Clone data into NEWDB from the existing database",
        -:10927:  ".databases               List names and files of attached databases",
        -:10928:  ".dbconfig ?op? ?val?     List or change sqlite3_db_config() options",
        -:10929:  ".dbinfo ?DB?             Show status information about the database",
        -:10930:  ".dump ?TABLE? ...        Render all database content as SQL",
        -:10931:  "   Options:",
        -:10932:  "     --preserve-rowids      Include ROWID values in the output",
        -:10933:  "     --newlines             Allow unescaped newline characters in output",
        -:10934:  "   TABLE is LIKE pattern for the tables to dump",
        -:10935:  ".echo on|off             Turn command echo on or off",
        -:10936:  ".eqp on|off|full         Enable or disable automatic EXPLAIN QUERY PLAN",
        -:10937:  ".excel                   Display the output of next command in a spreadsheet",
        -:10938:  ".exit ?CODE?             Exit this program with return-code CODE",
        -:10939:  ".expert                  EXPERIMENTAL. Suggest indexes for specified queries",
        -:10940:/* Because explain mode comes on automatically now, the ".explain" mode
        -:10941:** is removed from the help screen.  It is still supported for legacy, however */
        -:10942:/*".explain ?on|off|auto?   Turn EXPLAIN output mode on or off or to automatic",*/
        -:10943:  ".fullschema ?--indent?   Show schema and the content of sqlite_stat tables",
        -:10944:  ".headers on|off          Turn display of headers on or off",
        -:10945:  ".help ?-all? ?PATTERN?   Show help text for PATTERN",
        -:10946:  ".import FILE TABLE       Import data from FILE into TABLE",
        -:10947:#ifndef SQLITE_OMIT_TEST_CONTROL
        -:10948:  ".imposter INDEX TABLE    Create imposter table TABLE on index INDEX",
        -:10949:#endif
        -:10950:  ".indexes ?TABLE?         Show names of indexes",
        -:10951:  "                           If TABLE is specified, only show indexes for",
        -:10952:  "                           tables matching TABLE using the LIKE operator.",
        -:10953:#ifdef SQLITE_ENABLE_IOTRACE
        -:10954:  ".iotrace FILE            Enable I/O diagnostic logging to FILE",
        -:10955:#endif
        -:10956:  ".limit ?LIMIT? ?VAL?     Display or change the value of an SQLITE_LIMIT",
        -:10957:  ".lint OPTIONS            Report potential schema issues.",
        -:10958:  "     Options:",
        -:10959:  "        fkey-indexes     Find missing foreign key indexes",
        -:10960:#ifndef SQLITE_OMIT_LOAD_EXTENSION
        -:10961:  ".load FILE ?ENTRY?       Load an extension library",
        -:10962:#endif
        -:10963:  ".log FILE|off            Turn logging on or off.  FILE can be stderr/stdout",
        -:10964:  ".mode MODE ?TABLE?       Set output mode",
        -:10965:  "   MODE is one of:",
        -:10966:  "     ascii    Columns/rows delimited by 0x1F and 0x1E",
        -:10967:  "     csv      Comma-separated values",
        -:10968:  "     column   Left-aligned columns.  (See .width)",
        -:10969:  "     html     HTML <table> code",
        -:10970:  "     insert   SQL insert statements for TABLE",
        -:10971:  "     line     One value per line",
        -:10972:  "     list     Values delimited by \"|\"",
        -:10973:  "     quote    Escape answers as for SQL",
        -:10974:  "     tabs     Tab-separated values",
        -:10975:  "     tcl      TCL list elements",
        -:10976:  ".nullvalue STRING        Use STRING in place of NULL values",
        -:10977:  ".once (-e|-x|FILE)       Output for the next SQL command only to FILE",
        -:10978:  "     If FILE begins with '|' then open as a pipe",
        -:10979:  "     Other options:",
        -:10980:  "       -e    Invoke system text editor",
        -:10981:  "       -x    Open in a spreadsheet",
        -:10982:  ".open ?OPTIONS? ?FILE?   Close existing database and reopen FILE",
        -:10983:  "     Options:",
        -:10984:  "        --append        Use appendvfs to append database to the end of FILE",
        -:10985:#ifdef SQLITE_ENABLE_DESERIALIZE
        -:10986:  "        --deserialize   Load into memory useing sqlite3_deserialize()",
        -:10987:#endif
        -:10988:  "        --new           Initialize FILE to an empty database",
        -:10989:  "        --readonly      Open FILE readonly",
        -:10990:  "        --zip           FILE is a ZIP archive",
        -:10991:  ".output ?FILE?           Send output to FILE or stdout if FILE is omitted",
        -:10992:  "     If FILE begins with '|' then open it as a pipe.",
        -:10993:  ".print STRING...         Print literal STRING",
        -:10994:  ".prompt MAIN CONTINUE    Replace the standard prompts",
        -:10995:  ".quit                    Exit this program",
        -:10996:  ".read FILE               Read input from FILE",
        -:10997:  ".restore ?DB? FILE       Restore content of DB (default \"main\") from FILE",
        -:10998:  ".save FILE               Write in-memory database into FILE",
        -:10999:  ".scanstats on|off        Turn sqlite3_stmt_scanstatus() metrics on or off",
        -:11000:  ".schema ?PATTERN?        Show the CREATE statements matching PATTERN",
        -:11001:  "     Options:",
        -:11002:  "         --indent            Try to pretty-print the schema",
        -:11003:  ".selftest ?OPTIONS?      Run tests defined in the SELFTEST table",
        -:11004:  "    Options:",
        -:11005:  "       --init               Create a new SELFTEST table",
        -:11006:  "       -v                   Verbose output",
        -:11007:  ".separator COL ?ROW?     Change the column and row separators",
        -:11008:#if defined(SQLITE_ENABLE_SESSION)
        -:11009:  ".session ?NAME? CMD ...  Create or control sessions",
        -:11010:  "   Subcommands:",
        -:11011:  "     attach TABLE             Attach TABLE",
        -:11012:  "     changeset FILE           Write a changeset into FILE",
        -:11013:  "     close                    Close one session",
        -:11014:  "     enable ?BOOLEAN?         Set or query the enable bit",
        -:11015:  "     filter GLOB...           Reject tables matching GLOBs",
        -:11016:  "     indirect ?BOOLEAN?       Mark or query the indirect status",
        -:11017:  "     isempty                  Query whether the session is empty",
        -:11018:  "     list                     List currently open session names",
        -:11019:  "     open DB NAME             Open a new session on DB",
        -:11020:  "     patchset FILE            Write a patchset into FILE",
        -:11021:  "   If ?NAME? is omitted, the first defined session is used.",
        -:11022:#endif
        -:11023:  ".sha3sum ...             Compute a SHA3 hash of database content",
        -:11024:  "    Options:",
        -:11025:  "      --schema              Also hash the sqlite_master table",
        -:11026:  "      --sha3-224            Use the sha3-224 algorithm",
        -:11027:  "      --sha3-256            Use the sha3-256 algorithm.  This is the default.",
        -:11028:  "      --sha3-384            Use the sha3-384 algorithm",
        -:11029:  "      --sha3-512            Use the sha3-512 algorithm",
        -:11030:  "    Any other argument is a LIKE pattern for tables to hash",
        -:11031:#ifndef SQLITE_NOHAVE_SYSTEM
        -:11032:  ".shell CMD ARGS...       Run CMD ARGS... in a system shell",
        -:11033:#endif
        -:11034:  ".show                    Show the current values for various settings",
        -:11035:  ".stats ?on|off?          Show stats or turn stats on or off",
        -:11036:#ifndef SQLITE_NOHAVE_SYSTEM
        -:11037:  ".system CMD ARGS...      Run CMD ARGS... in a system shell",
        -:11038:#endif
        -:11039:  ".tables ?TABLE?          List names of tables matching LIKE pattern TABLE",
        -:11040:  ".testcase NAME           Begin redirecting output to 'testcase-out.txt'",
        -:11041:  ".timeout MS              Try opening locked tables for MS milliseconds",
        -:11042:  ".timer on|off            Turn SQL timer on or off",
        -:11043:  ".trace FILE|off          Output each SQL statement as it is run",
        -:11044:  ".vfsinfo ?AUX?           Information about the top-level VFS",
        -:11045:  ".vfslist                 List all available VFSes",
        -:11046:  ".vfsname ?AUX?           Print the name of the VFS stack",
        -:11047:  ".width NUM1 NUM2 ...     Set column widths for \"column\" mode",
        -:11048:  "     Negative values right-justify",
        -:11049:};
        -:11050:
        -:11051:/*
        -:11052:** Output help text.
        -:11053:**
        -:11054:** zPattern describes the set of commands for which help text is provided.
        -:11055:** If zPattern is NULL, then show all commands, but only give a one-line
        -:11056:** description of each.
        -:11057:**
        -:11058:** Return the number of matches.
        -:11059:*/
    #####:11060:static int showHelp(FILE *out, const char *zPattern){
    #####:11061:  int i = 0;
    #####:11062:  int j = 0;
    #####:11063:  int n = 0;
        -:11064:  char *zPat;
    #####:11065:  if( zPattern==0
    #####:11066:   || zPattern[0]=='0'
    #####:11067:   || strcmp(zPattern,"-a")==0
    #####:11068:   || strcmp(zPattern,"-all")==0
        -:11069:  ){
        -:11070:    /* Show all commands, but only one line per command */
    #####:11071:    if( zPattern==0 ) zPattern = "";
    #####:11072:    for(i=0; i<ArraySize(azHelp); i++){
    #####:11073:      if( azHelp[i][0]=='.' || zPattern[0] ){
    #####:11074:        utf8_printf(out, "%s\n", azHelp[i]);
    #####:11075:        n++;
        -:11076:      }
        -:11077:    }
        -:11078:  }else{
        -:11079:    /* Look for commands that for which zPattern is an exact prefix */
    #####:11080:    zPat = sqlite3_mprintf(".%s*", zPattern);
    #####:11081:    for(i=0; i<ArraySize(azHelp); i++){
    #####:11082:      if( sqlite3_strglob(zPat, azHelp[i])==0 ){
    #####:11083:        utf8_printf(out, "%s\n", azHelp[i]);
    #####:11084:        j = i+1;
    #####:11085:        n++;
        -:11086:      }
        -:11087:    }
    #####:11088:    sqlite3_free(zPat);
    #####:11089:    if( n ){
    #####:11090:      if( n==1 ){
        -:11091:        /* when zPattern is a prefix of exactly one command, then include the
        -:11092:        ** details of that command, which should begin at offset j */
    #####:11093:        while( j<ArraySize(azHelp)-1 && azHelp[j][0]!='.' ){
    #####:11094:          utf8_printf(out, "%s\n", azHelp[j]);
    #####:11095:          j++;
        -:11096:        }
        -:11097:      }
    #####:11098:      return n;
        -:11099:    }
        -:11100:    /* Look for commands that contain zPattern anywhere.  Show the complete
        -:11101:    ** text of all commands that match. */
    #####:11102:    zPat = sqlite3_mprintf("%%%s%%", zPattern);
    #####:11103:    for(i=0; i<ArraySize(azHelp); i++){
    #####:11104:      if( azHelp[i][0]=='.' ) j = i;
    #####:11105:      if( sqlite3_strlike(zPat, azHelp[i], 0)==0 ){
    #####:11106:        utf8_printf(out, "%s\n", azHelp[j]);
    #####:11107:        while( j<ArraySize(azHelp)-1 && azHelp[j+1][0]!='.' ){
    #####:11108:          j++;
    #####:11109:          utf8_printf(out, "%s\n", azHelp[j]);
        -:11110:        }
    #####:11111:        i = j;
    #####:11112:        n++;
        -:11113:      }
        -:11114:    }
    #####:11115:    sqlite3_free(zPat);
        -:11116:  }
    #####:11117:  return n;
        -:11118:}
        -:11119:
        -:11120:/* Forward reference */
        -:11121:static int process_input(ShellState *p, FILE *in);
        -:11122:
        -:11123:/*
        -:11124:** Read the content of file zName into memory obtained from sqlite3_malloc64()
        -:11125:** and return a pointer to the buffer. The caller is responsible for freeing
        -:11126:** the memory.
        -:11127:**
        -:11128:** If parameter pnByte is not NULL, (*pnByte) is set to the number of bytes
        -:11129:** read.
        -:11130:**
        -:11131:** For convenience, a nul-terminator byte is always appended to the data read
        -:11132:** from the file before the buffer is returned. This byte is not included in
        -:11133:** the final value of (*pnByte), if applicable.
        -:11134:**
        -:11135:** NULL is returned if any error is encountered. The final value of *pnByte
        -:11136:** is undefined in this case.
        -:11137:*/
    #####:11138:static char *readFile(const char *zName, int *pnByte){
    #####:11139:  FILE *in = fopen(zName, "rb");
        -:11140:  long nIn;
        -:11141:  size_t nRead;
        -:11142:  char *pBuf;
    #####:11143:  if( in==0 ) return 0;
    #####:11144:  fseek(in, 0, SEEK_END);
    #####:11145:  nIn = ftell(in);
    #####:11146:  rewind(in);
    #####:11147:  pBuf = sqlite3_malloc64( nIn+1 );
    #####:11148:  if( pBuf==0 ){ fclose(in); return 0; }
    #####:11149:  nRead = fread(pBuf, nIn, 1, in);
    #####:11150:  fclose(in);
    #####:11151:  if( nRead!=1 ){
    #####:11152:    sqlite3_free(pBuf);
    #####:11153:    return 0;
        -:11154:  }
    #####:11155:  pBuf[nIn] = 0;
    #####:11156:  if( pnByte ) *pnByte = nIn;
    #####:11157:  return pBuf;
        -:11158:}
        -:11159:
        -:11160:#if defined(SQLITE_ENABLE_SESSION)
        -:11161:/*
        -:11162:** Close a single OpenSession object and release all of its associated
        -:11163:** resources.
        -:11164:*/
        -:11165:static void session_close(OpenSession *pSession){
        -:11166:  int i;
        -:11167:  sqlite3session_delete(pSession->p);
        -:11168:  sqlite3_free(pSession->zName);
        -:11169:  for(i=0; i<pSession->nFilter; i++){
        -:11170:    sqlite3_free(pSession->azFilter[i]);
        -:11171:  }
        -:11172:  sqlite3_free(pSession->azFilter);
        -:11173:  memset(pSession, 0, sizeof(OpenSession));
        -:11174:}
        -:11175:#endif
        -:11176:
        -:11177:/*
        -:11178:** Close all OpenSession objects and release all associated resources.
        -:11179:*/
        -:11180:#if defined(SQLITE_ENABLE_SESSION)
        -:11181:static void session_close_all(ShellState *p){
        -:11182:  int i;
        -:11183:  for(i=0; i<p->nSession; i++){
        -:11184:    session_close(&p->aSession[i]);
        -:11185:  }
        -:11186:  p->nSession = 0;
        -:11187:}
        -:11188:#else
        -:11189:# define session_close_all(X)
        -:11190:#endif
        -:11191:
        -:11192:/*
        -:11193:** Implementation of the xFilter function for an open session.  Omit
        -:11194:** any tables named by ".session filter" but let all other table through.
        -:11195:*/
        -:11196:#if defined(SQLITE_ENABLE_SESSION)
        -:11197:static int session_filter(void *pCtx, const char *zTab){
        -:11198:  OpenSession *pSession = (OpenSession*)pCtx;
        -:11199:  int i;
        -:11200:  for(i=0; i<pSession->nFilter; i++){
        -:11201:    if( sqlite3_strglob(pSession->azFilter[i], zTab)==0 ) return 0;
        -:11202:  }
        -:11203:  return 1;
        -:11204:}
        -:11205:#endif
        -:11206:
        -:11207:/*
        -:11208:** Try to deduce the type of file for zName based on its content.  Return
        -:11209:** one of the SHELL_OPEN_* constants.
        -:11210:**
        -:11211:** If the file does not exist or is empty but its name looks like a ZIP
        -:11212:** archive and the dfltZip flag is true, then assume it is a ZIP archive.
        -:11213:** Otherwise, assume an ordinary database regardless of the filename if
        -:11214:** the type cannot be determined from content.
        -:11215:*/
        2:11216:int deduceDatabaseType(const char *zName, int dfltZip){
        2:11217:  FILE *f = fopen(zName, "rb");
        -:11218:  size_t n;
        2:11219:  int rc = SHELL_OPEN_UNSPEC;
        -:11220:  char zBuf[100];
        2:11221:  if( f==0 ){
       2*:11222:    if( dfltZip && sqlite3_strlike("%.zip",zName,0)==0 ){
    #####:11223:       return SHELL_OPEN_ZIPFILE;
        -:11224:    }else{
        2:11225:       return SHELL_OPEN_NORMAL;
        -:11226:    }
        -:11227:  }
    #####:11228:  n = fread(zBuf, 16, 1, f);
    #####:11229:  if( n==1 && memcmp(zBuf, "SQLite format 3", 16)==0 ){
    #####:11230:    fclose(f);
    #####:11231:    return SHELL_OPEN_NORMAL;
        -:11232:  }
    #####:11233:  fseek(f, -25, SEEK_END);
    #####:11234:  n = fread(zBuf, 25, 1, f);
    #####:11235:  if( n==1 && memcmp(zBuf, "Start-Of-SQLite3-", 17)==0 ){
    #####:11236:    rc = SHELL_OPEN_APPENDVFS;
        -:11237:  }else{
    #####:11238:    fseek(f, -22, SEEK_END);
    #####:11239:    n = fread(zBuf, 22, 1, f);
    #####:11240:    if( n==1 && zBuf[0]==0x50 && zBuf[1]==0x4b && zBuf[2]==0x05
    #####:11241:       && zBuf[3]==0x06 ){
    #####:11242:      rc = SHELL_OPEN_ZIPFILE;
    #####:11243:    }else if( n==0 && dfltZip && sqlite3_strlike("%.zip",zName,0)==0 ){
    #####:11244:      rc = SHELL_OPEN_ZIPFILE;
        -:11245:    }
        -:11246:  }
    #####:11247:  fclose(f);
    #####:11248:  return rc;  
        -:11249:}
        -:11250:
        -:11251:/* Flags for open_db().
        -:11252:**
        -:11253:** The default behavior of open_db() is to exit(1) if the database fails to
        -:11254:** open.  The OPEN_DB_KEEPALIVE flag changes that so that it prints an error
        -:11255:** but still returns without calling exit.
        -:11256:**
        -:11257:** The OPEN_DB_ZIPFILE flag causes open_db() to prefer to open files as a
        -:11258:** ZIP archive if the file does not exist or is empty and its name matches
        -:11259:** the *.zip pattern.
        -:11260:*/
        -:11261:#define OPEN_DB_KEEPALIVE   0x001   /* Return after error if true */
        -:11262:#define OPEN_DB_ZIPFILE     0x002   /* Open as ZIP if name matches *.zip */
        -:11263:
        -:11264:/*
        -:11265:** Make sure the database is open.  If it is not, then open it.  If
        -:11266:** the database fails to open, print an error message and exit.
        -:11267:*/
        2:11268:static void open_db(ShellState *p, int openFlags){
        2:11269:  if( p->db==0 ){
        2:11270:    if( p->openMode==SHELL_OPEN_UNSPEC ){
        2:11271:      if( p->zDbFilename==0 || p->zDbFilename[0]==0 ){
    #####:11272:        p->openMode = SHELL_OPEN_NORMAL;
        -:11273:      }else{
        2:11274:        p->openMode = (u8)deduceDatabaseType(p->zDbFilename, 
        2:11275:                             (openFlags & OPEN_DB_ZIPFILE)!=0);
        -:11276:      }
        -:11277:    }
        2:11278:    switch( p->openMode ){
    #####:11279:      case SHELL_OPEN_APPENDVFS: {
    #####:11280:        sqlite3_open_v2(p->zDbFilename, &p->db, 
        -:11281:           SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE, "apndvfs");
    #####:11282:        break;
        -:11283:      }
    #####:11284:      case SHELL_OPEN_DESERIALIZE: {
    #####:11285:        sqlite3_open(0, &p->db);
    #####:11286:        break;
        -:11287:      }
    #####:11288:      case SHELL_OPEN_ZIPFILE: {
    #####:11289:        sqlite3_open(":memory:", &p->db);
    #####:11290:        break;
        -:11291:      }
    #####:11292:      case SHELL_OPEN_READONLY: {
    #####:11293:        sqlite3_open_v2(p->zDbFilename, &p->db, SQLITE_OPEN_READONLY, 0);
    #####:11294:        break;
        -:11295:      }
        2:11296:      case SHELL_OPEN_UNSPEC:
        -:11297:      case SHELL_OPEN_NORMAL: {
        2:11298:        sqlite3_open(p->zDbFilename, &p->db);
        2:11299:        break;
        -:11300:      }
        -:11301:    }
        2:11302:    globalDb = p->db;
        2:11303:    if( p->db==0 || SQLITE_OK!=sqlite3_errcode(p->db) ){
    #####:11304:      utf8_printf(stderr,"Error: unable to open database \"%s\": %s\n",
        -:11305:          p->zDbFilename, sqlite3_errmsg(p->db));
    #####:11306:      if( openFlags & OPEN_DB_KEEPALIVE ) return;
    #####:11307:      exit(1);
        -:11308:    }
        -:11309:#ifndef SQLITE_OMIT_LOAD_EXTENSION
        2:11310:    sqlite3_enable_load_extension(p->db, 1);
        -:11311:#endif
        2:11312:    sqlite3_fileio_init(p->db, 0, 0);
        2:11313:    sqlite3_shathree_init(p->db, 0, 0);
        2:11314:    sqlite3_completion_init(p->db, 0, 0);
        -:11315:#ifdef SQLITE_HAVE_ZLIB
        2:11316:    sqlite3_zipfile_init(p->db, 0, 0);
        2:11317:    sqlite3_sqlar_init(p->db, 0, 0);
        -:11318:#endif
        2:11319:    sqlite3_create_function(p->db, "shell_add_schema", 3, SQLITE_UTF8, 0,
        -:11320:                            shellAddSchemaName, 0, 0);
        2:11321:    sqlite3_create_function(p->db, "shell_module_schema", 1, SQLITE_UTF8, 0,
        -:11322:                            shellModuleSchema, 0, 0);
        2:11323:    sqlite3_create_function(p->db, "shell_putsnl", 1, SQLITE_UTF8, p,
        -:11324:                            shellPutsFunc, 0, 0);
        -:11325:#ifndef SQLITE_NOHAVE_SYSTEM
        2:11326:    sqlite3_create_function(p->db, "edit", 1, SQLITE_UTF8, 0,
        -:11327:                            editFunc, 0, 0);
        2:11328:    sqlite3_create_function(p->db, "edit", 2, SQLITE_UTF8, 0,
        -:11329:                            editFunc, 0, 0);
        -:11330:#endif
        2:11331:    if( p->openMode==SHELL_OPEN_ZIPFILE ){
    #####:11332:      char *zSql = sqlite3_mprintf(
        -:11333:         "CREATE VIRTUAL TABLE zip USING zipfile(%Q);", p->zDbFilename);
    #####:11334:      sqlite3_exec(p->db, zSql, 0, 0, 0);
    #####:11335:      sqlite3_free(zSql);
        -:11336:    }
        -:11337:#ifdef SQLITE_ENABLE_DESERIALIZE
        2:11338:    else if( p->openMode==SHELL_OPEN_DESERIALIZE ){
    #####:11339:      int nData = 0;
    #####:11340:      unsigned char *aData = (unsigned char*)readFile(p->zDbFilename, &nData);
    #####:11341:      int rc = sqlite3_deserialize(p->db, "main", aData, nData, nData,
        -:11342:                   SQLITE_DESERIALIZE_RESIZEABLE |
        -:11343:                   SQLITE_DESERIALIZE_FREEONCLOSE);
    #####:11344:      if( rc ){
    #####:11345:        utf8_printf(stderr, "Error: sqlite3_deserialize() returns %d\n", rc);
        -:11346:      }
        -:11347:    }
        -:11348:#endif
        -:11349:  }
        -:11350:}
        -:11351:
        -:11352:/*
        -:11353:** Attempt to close the databaes connection.  Report errors.
        -:11354:*/
        2:11355:void close_db(sqlite3 *db){
        2:11356:  int rc = sqlite3_close(db);
        2:11357:  if( rc ){
    #####:11358:    utf8_printf(stderr, "Error: sqlite3_close() returns %d: %s\n",
        -:11359:        rc, sqlite3_errmsg(db));
        -:11360:  } 
        2:11361:}
        -:11362:
        -:11363:#if HAVE_READLINE || HAVE_EDITLINE
        -:11364:/*
        -:11365:** Readline completion callbacks
        -:11366:*/
        -:11367:static char *readline_completion_generator(const char *text, int state){
        -:11368:  static sqlite3_stmt *pStmt = 0;
        -:11369:  char *zRet;
        -:11370:  if( state==0 ){
        -:11371:    char *zSql;
        -:11372:    sqlite3_finalize(pStmt);
        -:11373:    zSql = sqlite3_mprintf("SELECT DISTINCT candidate COLLATE nocase"
        -:11374:                           "  FROM completion(%Q) ORDER BY 1", text);
        -:11375:    sqlite3_prepare_v2(globalDb, zSql, -1, &pStmt, 0);
        -:11376:    sqlite3_free(zSql);
        -:11377:  }
        -:11378:  if( sqlite3_step(pStmt)==SQLITE_ROW ){
        -:11379:    zRet = strdup((const char*)sqlite3_column_text(pStmt, 0));
        -:11380:  }else{
        -:11381:    sqlite3_finalize(pStmt);
        -:11382:    pStmt = 0;
        -:11383:    zRet = 0;
        -:11384:  }
        -:11385:  return zRet;
        -:11386:}
        -:11387:static char **readline_completion(const char *zText, int iStart, int iEnd){
        -:11388:  rl_attempted_completion_over = 1;
        -:11389:  return rl_completion_matches(zText, readline_completion_generator);
        -:11390:}
        -:11391:
        -:11392:#elif HAVE_LINENOISE
        -:11393:/*
        -:11394:** Linenoise completion callback
        -:11395:*/
        -:11396:static void linenoise_completion(const char *zLine, linenoiseCompletions *lc){
        -:11397:  int nLine = strlen30(zLine);
        -:11398:  int i, iStart;
        -:11399:  sqlite3_stmt *pStmt = 0;
        -:11400:  char *zSql;
        -:11401:  char zBuf[1000];
        -:11402:
        -:11403:  if( nLine>sizeof(zBuf)-30 ) return;
        -:11404:  if( zLine[0]=='.' || zLine[0]=='#') return;
        -:11405:  for(i=nLine-1; i>=0 && (isalnum(zLine[i]) || zLine[i]=='_'); i--){}
        -:11406:  if( i==nLine-1 ) return;
        -:11407:  iStart = i+1;
        -:11408:  memcpy(zBuf, zLine, iStart);
        -:11409:  zSql = sqlite3_mprintf("SELECT DISTINCT candidate COLLATE nocase"
        -:11410:                         "  FROM completion(%Q,%Q) ORDER BY 1",
        -:11411:                         &zLine[iStart], zLine);
        -:11412:  sqlite3_prepare_v2(globalDb, zSql, -1, &pStmt, 0);
        -:11413:  sqlite3_free(zSql);
        -:11414:  sqlite3_exec(globalDb, "PRAGMA page_count", 0, 0, 0); /* Load the schema */
        -:11415:  while( sqlite3_step(pStmt)==SQLITE_ROW ){
        -:11416:    const char *zCompletion = (const char*)sqlite3_column_text(pStmt, 0);
        -:11417:    int nCompletion = sqlite3_column_bytes(pStmt, 0);
        -:11418:    if( iStart+nCompletion < sizeof(zBuf)-1 ){
        -:11419:      memcpy(zBuf+iStart, zCompletion, nCompletion+1);
        -:11420:      linenoiseAddCompletion(lc, zBuf);
        -:11421:    }
        -:11422:  }
        -:11423:  sqlite3_finalize(pStmt);
        -:11424:}
        -:11425:#endif
        -:11426:
        -:11427:/*
        -:11428:** Do C-language style dequoting.
        -:11429:**
        -:11430:**    \a    -> alarm
        -:11431:**    \b    -> backspace
        -:11432:**    \t    -> tab
        -:11433:**    \n    -> newline
        -:11434:**    \v    -> vertical tab
        -:11435:**    \f    -> form feed
        -:11436:**    \r    -> carriage return
        -:11437:**    \s    -> space
        -:11438:**    \"    -> "
        -:11439:**    \'    -> '
        -:11440:**    \\    -> backslash
        -:11441:**    \NNN  -> ascii character NNN in octal
        -:11442:*/
        2:11443:static void resolve_backslashes(char *z){
        -:11444:  int i, j;
        -:11445:  char c;
       10:11446:  while( *z && *z!='\\' ) z++;
       2*:11447:  for(i=j=0; (c = z[i])!=0; i++, j++){
    #####:11448:    if( c=='\\' && z[i+1]!=0 ){
    #####:11449:      c = z[++i];
    #####:11450:      if( c=='a' ){
    #####:11451:        c = '\a';
    #####:11452:      }else if( c=='b' ){
    #####:11453:        c = '\b';
    #####:11454:      }else if( c=='t' ){
    #####:11455:        c = '\t';
    #####:11456:      }else if( c=='n' ){
    #####:11457:        c = '\n';
    #####:11458:      }else if( c=='v' ){
    #####:11459:        c = '\v';
    #####:11460:      }else if( c=='f' ){
    #####:11461:        c = '\f';
    #####:11462:      }else if( c=='r' ){
    #####:11463:        c = '\r';
    #####:11464:      }else if( c=='"' ){
    #####:11465:        c = '"';
    #####:11466:      }else if( c=='\'' ){
    #####:11467:        c = '\'';
    #####:11468:      }else if( c=='\\' ){
    #####:11469:        c = '\\';
    #####:11470:      }else if( c>='0' && c<='7' ){
    #####:11471:        c -= '0';
    #####:11472:        if( z[i+1]>='0' && z[i+1]<='7' ){
    #####:11473:          i++;
    #####:11474:          c = (c<<3) + z[i] - '0';
    #####:11475:          if( z[i+1]>='0' && z[i+1]<='7' ){
    #####:11476:            i++;
    #####:11477:            c = (c<<3) + z[i] - '0';
        -:11478:          }
        -:11479:        }
        -:11480:      }
        -:11481:    }
    #####:11482:    z[j] = c;
        -:11483:  }
       2*:11484:  if( j<i ) z[j] = 0;
        2:11485:}
        -:11486:
        -:11487:/*
        -:11488:** Interpret zArg as either an integer or a boolean value.  Return 1 or 0
        -:11489:** for TRUE and FALSE.  Return the integer value if appropriate.
        -:11490:*/
    #####:11491:static int booleanValue(const char *zArg){
        -:11492:  int i;
    #####:11493:  if( zArg[0]=='0' && zArg[1]=='x' ){
    #####:11494:    for(i=2; hexDigitValue(zArg[i])>=0; i++){}
        -:11495:  }else{
    #####:11496:    for(i=0; zArg[i]>='0' && zArg[i]<='9'; i++){}
        -:11497:  }
    #####:11498:  if( i>0 && zArg[i]==0 ) return (int)(integerValue(zArg) & 0xffffffff);
    #####:11499:  if( sqlite3_stricmp(zArg, "on")==0 || sqlite3_stricmp(zArg,"yes")==0 ){
    #####:11500:    return 1;
        -:11501:  }
    #####:11502:  if( sqlite3_stricmp(zArg, "off")==0 || sqlite3_stricmp(zArg,"no")==0 ){
    #####:11503:    return 0;
        -:11504:  }
    #####:11505:  utf8_printf(stderr, "ERROR: Not a boolean value: \"%s\". Assuming \"no\".\n",
        -:11506:          zArg);
    #####:11507:  return 0;
        -:11508:}
        -:11509:
        -:11510:/*
        -:11511:** Set or clear a shell flag according to a boolean value.
        -:11512:*/
    #####:11513:static void setOrClearFlag(ShellState *p, unsigned mFlag, const char *zArg){
    #####:11514:  if( booleanValue(zArg) ){
    #####:11515:    ShellSetFlag(p, mFlag);
        -:11516:  }else{
    #####:11517:    ShellClearFlag(p, mFlag);
        -:11518:  }
    #####:11519:}
        -:11520:
        -:11521:/*
        -:11522:** Close an output file, assuming it is not stderr or stdout
        -:11523:*/
        2:11524:static void output_file_close(FILE *f){
       2*:11525:  if( f && f!=stdout && f!=stderr ) fclose(f);
        2:11526:}
        -:11527:
        -:11528:/*
        -:11529:** Try to open an output file.   The names "stdout" and "stderr" are
        -:11530:** recognized and do the right thing.  NULL is returned if the output
        -:11531:** filename is "off".
        -:11532:*/
    #####:11533:static FILE *output_file_open(const char *zFile, int bTextMode){
        -:11534:  FILE *f;
    #####:11535:  if( strcmp(zFile,"stdout")==0 ){
    #####:11536:    f = stdout;
    #####:11537:  }else if( strcmp(zFile, "stderr")==0 ){
    #####:11538:    f = stderr;
    #####:11539:  }else if( strcmp(zFile, "off")==0 ){
    #####:11540:    f = 0;
        -:11541:  }else{
    #####:11542:    f = fopen(zFile, bTextMode ? "w" : "wb");
    #####:11543:    if( f==0 ){
    #####:11544:      utf8_printf(stderr, "Error: cannot open \"%s\"\n", zFile);
        -:11545:    }
        -:11546:  }
    #####:11547:  return f;
        -:11548:}
        -:11549:
        -:11550:#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)
        -:11551:/*
        -:11552:** A routine for handling output from sqlite3_trace().
        -:11553:*/
    #####:11554:static int sql_trace_callback(
        -:11555:  unsigned mType,
        -:11556:  void *pArg,
        -:11557:  void *pP,
        -:11558:  void *pX
        -:11559:){
    #####:11560:  FILE *f = (FILE*)pArg;
        -:11561:  UNUSED_PARAMETER(mType);
        -:11562:  UNUSED_PARAMETER(pP);
    #####:11563:  if( f ){
    #####:11564:    const char *z = (const char*)pX;
    #####:11565:    int i = strlen30(z);
    #####:11566:    while( i>0 && z[i-1]==';' ){ i--; }
    #####:11567:    utf8_printf(f, "%.*s;\n", i, z);
        -:11568:  }
    #####:11569:  return 0;
        -:11570:}
        -:11571:#endif
        -:11572:
        -:11573:/*
        -:11574:** A no-op routine that runs with the ".breakpoint" doc-command.  This is
        -:11575:** a useful spot to set a debugger breakpoint.
        -:11576:*/
    #####:11577:static void test_breakpoint(void){
        -:11578:  static int nCall = 0;
    #####:11579:  nCall++;
    #####:11580:}
        -:11581:
        -:11582:/*
        -:11583:** An object used to read a CSV and other files for import.
        -:11584:*/
        -:11585:typedef struct ImportCtx ImportCtx;
        -:11586:struct ImportCtx {
        -:11587:  const char *zFile;  /* Name of the input file */
        -:11588:  FILE *in;           /* Read the CSV text from this input stream */
        -:11589:  char *z;            /* Accumulated text for a field */
        -:11590:  int n;              /* Number of bytes in z */
        -:11591:  int nAlloc;         /* Space allocated for z[] */
        -:11592:  int nLine;          /* Current line number */
        -:11593:  int bNotFirst;      /* True if one or more bytes already read */
        -:11594:  int cTerm;          /* Character that terminated the most recent field */
        -:11595:  int cColSep;        /* The column separator character.  (Usually ",") */
        -:11596:  int cRowSep;        /* The row separator character.  (Usually "\n") */
        -:11597:};
        -:11598:
        -:11599:/* Append a single byte to z[] */
    #####:11600:static void import_append_char(ImportCtx *p, int c){
    #####:11601:  if( p->n+1>=p->nAlloc ){
    #####:11602:    p->nAlloc += p->nAlloc + 100;
    #####:11603:    p->z = sqlite3_realloc64(p->z, p->nAlloc);
    #####:11604:    if( p->z==0 ) shell_out_of_memory();
        -:11605:  }
    #####:11606:  p->z[p->n++] = (char)c;
    #####:11607:}
        -:11608:
        -:11609:/* Read a single field of CSV text.  Compatible with rfc4180 and extended
        -:11610:** with the option of having a separator other than ",".
        -:11611:**
        -:11612:**   +  Input comes from p->in.
        -:11613:**   +  Store results in p->z of length p->n.  Space to hold p->z comes
        -:11614:**      from sqlite3_malloc64().
        -:11615:**   +  Use p->cSep as the column separator.  The default is ",".
        -:11616:**   +  Use p->rSep as the row separator.  The default is "\n".
        -:11617:**   +  Keep track of the line number in p->nLine.
        -:11618:**   +  Store the character that terminates the field in p->cTerm.  Store
        -:11619:**      EOF on end-of-file.
        -:11620:**   +  Report syntax errors on stderr
        -:11621:*/
    #####:11622:static char *SQLITE_CDECL csv_read_one_field(ImportCtx *p){
        -:11623:  int c;
    #####:11624:  int cSep = p->cColSep;
    #####:11625:  int rSep = p->cRowSep;
    #####:11626:  p->n = 0;
    #####:11627:  c = fgetc(p->in);
    #####:11628:  if( c==EOF || seenInterrupt ){
    #####:11629:    p->cTerm = EOF;
    #####:11630:    return 0;
        -:11631:  }
    #####:11632:  if( c=='"' ){
        -:11633:    int pc, ppc;
    #####:11634:    int startLine = p->nLine;
    #####:11635:    int cQuote = c;
    #####:11636:    pc = ppc = 0;
        -:11637:    while( 1 ){
    #####:11638:      c = fgetc(p->in);
    #####:11639:      if( c==rSep ) p->nLine++;
    #####:11640:      if( c==cQuote ){
    #####:11641:        if( pc==cQuote ){
    #####:11642:          pc = 0;
    #####:11643:          continue;
        -:11644:        }
        -:11645:      }
    #####:11646:      if( (c==cSep && pc==cQuote)
    #####:11647:       || (c==rSep && pc==cQuote)
    #####:11648:       || (c==rSep && pc=='\r' && ppc==cQuote)
    #####:11649:       || (c==EOF && pc==cQuote)
        -:11650:      ){
    #####:11651:        do{ p->n--; }while( p->z[p->n]!=cQuote );
    #####:11652:        p->cTerm = c;
    #####:11653:        break;
        -:11654:      }
    #####:11655:      if( pc==cQuote && c!='\r' ){
    #####:11656:        utf8_printf(stderr, "%s:%d: unescaped %c character\n",
        -:11657:                p->zFile, p->nLine, cQuote);
        -:11658:      }
    #####:11659:      if( c==EOF ){
    #####:11660:        utf8_printf(stderr, "%s:%d: unterminated %c-quoted field\n",
        -:11661:                p->zFile, startLine, cQuote);
    #####:11662:        p->cTerm = c;
    #####:11663:        break;
        -:11664:      }
    #####:11665:      import_append_char(p, c);
    #####:11666:      ppc = pc;
    #####:11667:      pc = c;
        -:11668:    }
        -:11669:  }else{
        -:11670:    /* If this is the first field being parsed and it begins with the
        -:11671:    ** UTF-8 BOM  (0xEF BB BF) then skip the BOM */
    #####:11672:    if( (c&0xff)==0xef && p->bNotFirst==0 ){
    #####:11673:      import_append_char(p, c);
    #####:11674:      c = fgetc(p->in);
    #####:11675:      if( (c&0xff)==0xbb ){
    #####:11676:        import_append_char(p, c);
    #####:11677:        c = fgetc(p->in);
    #####:11678:        if( (c&0xff)==0xbf ){
    #####:11679:          p->bNotFirst = 1;
    #####:11680:          p->n = 0;
    #####:11681:          return csv_read_one_field(p);
        -:11682:        }
        -:11683:      }
        -:11684:    }
    #####:11685:    while( c!=EOF && c!=cSep && c!=rSep ){
    #####:11686:      import_append_char(p, c);
    #####:11687:      c = fgetc(p->in);
        -:11688:    }
    #####:11689:    if( c==rSep ){
    #####:11690:      p->nLine++;
    #####:11691:      if( p->n>0 && p->z[p->n-1]=='\r' ) p->n--;
        -:11692:    }
    #####:11693:    p->cTerm = c;
        -:11694:  }
    #####:11695:  if( p->z ) p->z[p->n] = 0;
    #####:11696:  p->bNotFirst = 1;
    #####:11697:  return p->z;
        -:11698:}
        -:11699:
        -:11700:/* Read a single field of ASCII delimited text.
        -:11701:**
        -:11702:**   +  Input comes from p->in.
        -:11703:**   +  Store results in p->z of length p->n.  Space to hold p->z comes
        -:11704:**      from sqlite3_malloc64().
        -:11705:**   +  Use p->cSep as the column separator.  The default is "\x1F".
        -:11706:**   +  Use p->rSep as the row separator.  The default is "\x1E".
        -:11707:**   +  Keep track of the row number in p->nLine.
        -:11708:**   +  Store the character that terminates the field in p->cTerm.  Store
        -:11709:**      EOF on end-of-file.
        -:11710:**   +  Report syntax errors on stderr
        -:11711:*/
    #####:11712:static char *SQLITE_CDECL ascii_read_one_field(ImportCtx *p){
        -:11713:  int c;
    #####:11714:  int cSep = p->cColSep;
    #####:11715:  int rSep = p->cRowSep;
    #####:11716:  p->n = 0;
    #####:11717:  c = fgetc(p->in);
    #####:11718:  if( c==EOF || seenInterrupt ){
    #####:11719:    p->cTerm = EOF;
    #####:11720:    return 0;
        -:11721:  }
    #####:11722:  while( c!=EOF && c!=cSep && c!=rSep ){
    #####:11723:    import_append_char(p, c);
    #####:11724:    c = fgetc(p->in);
        -:11725:  }
    #####:11726:  if( c==rSep ){
    #####:11727:    p->nLine++;
        -:11728:  }
    #####:11729:  p->cTerm = c;
    #####:11730:  if( p->z ) p->z[p->n] = 0;
    #####:11731:  return p->z;
        -:11732:}
        -:11733:
        -:11734:/*
        -:11735:** Try to transfer data for table zTable.  If an error is seen while
        -:11736:** moving forward, try to go backwards.  The backwards movement won't
        -:11737:** work for WITHOUT ROWID tables.
        -:11738:*/
    #####:11739:static void tryToCloneData(
        -:11740:  ShellState *p,
        -:11741:  sqlite3 *newDb,
        -:11742:  const char *zTable
        -:11743:){
    #####:11744:  sqlite3_stmt *pQuery = 0;
    #####:11745:  sqlite3_stmt *pInsert = 0;
    #####:11746:  char *zQuery = 0;
    #####:11747:  char *zInsert = 0;
        -:11748:  int rc;
        -:11749:  int i, j, n;
    #####:11750:  int nTable = strlen30(zTable);
    #####:11751:  int k = 0;
    #####:11752:  int cnt = 0;
    #####:11753:  const int spinRate = 10000;
        -:11754:
    #####:11755:  zQuery = sqlite3_mprintf("SELECT * FROM \"%w\"", zTable);
    #####:11756:  rc = sqlite3_prepare_v2(p->db, zQuery, -1, &pQuery, 0);
    #####:11757:  if( rc ){
    #####:11758:    utf8_printf(stderr, "Error %d: %s on [%s]\n",
        -:11759:            sqlite3_extended_errcode(p->db), sqlite3_errmsg(p->db),
        -:11760:            zQuery);
    #####:11761:    goto end_data_xfer;
        -:11762:  }
    #####:11763:  n = sqlite3_column_count(pQuery);
    #####:11764:  zInsert = sqlite3_malloc64(200 + nTable + n*3);
    #####:11765:  if( zInsert==0 ) shell_out_of_memory();
    #####:11766:  sqlite3_snprintf(200+nTable,zInsert,
        -:11767:                   "INSERT OR IGNORE INTO \"%s\" VALUES(?", zTable);
    #####:11768:  i = strlen30(zInsert);
    #####:11769:  for(j=1; j<n; j++){
    #####:11770:    memcpy(zInsert+i, ",?", 2);
    #####:11771:    i += 2;
        -:11772:  }
    #####:11773:  memcpy(zInsert+i, ");", 3);
    #####:11774:  rc = sqlite3_prepare_v2(newDb, zInsert, -1, &pInsert, 0);
    #####:11775:  if( rc ){
    #####:11776:    utf8_printf(stderr, "Error %d: %s on [%s]\n",
        -:11777:            sqlite3_extended_errcode(newDb), sqlite3_errmsg(newDb),
        -:11778:            zQuery);
    #####:11779:    goto end_data_xfer;
        -:11780:  }
    #####:11781:  for(k=0; k<2; k++){
    #####:11782:    while( (rc = sqlite3_step(pQuery))==SQLITE_ROW ){
    #####:11783:      for(i=0; i<n; i++){
    #####:11784:        switch( sqlite3_column_type(pQuery, i) ){
    #####:11785:          case SQLITE_NULL: {
    #####:11786:            sqlite3_bind_null(pInsert, i+1);
    #####:11787:            break;
        -:11788:          }
    #####:11789:          case SQLITE_INTEGER: {
    #####:11790:            sqlite3_bind_int64(pInsert, i+1, sqlite3_column_int64(pQuery,i));
    #####:11791:            break;
        -:11792:          }
    #####:11793:          case SQLITE_FLOAT: {
    #####:11794:            sqlite3_bind_double(pInsert, i+1, sqlite3_column_double(pQuery,i));
    #####:11795:            break;
        -:11796:          }
    #####:11797:          case SQLITE_TEXT: {
    #####:11798:            sqlite3_bind_text(pInsert, i+1,
    #####:11799:                             (const char*)sqlite3_column_text(pQuery,i),
        -:11800:                             -1, SQLITE_STATIC);
    #####:11801:            break;
        -:11802:          }
    #####:11803:          case SQLITE_BLOB: {
    #####:11804:            sqlite3_bind_blob(pInsert, i+1, sqlite3_column_blob(pQuery,i),
        -:11805:                                            sqlite3_column_bytes(pQuery,i),
        -:11806:                                            SQLITE_STATIC);
    #####:11807:            break;
        -:11808:          }
        -:11809:        }
        -:11810:      } /* End for */
    #####:11811:      rc = sqlite3_step(pInsert);
    #####:11812:      if( rc!=SQLITE_OK && rc!=SQLITE_ROW && rc!=SQLITE_DONE ){
    #####:11813:        utf8_printf(stderr, "Error %d: %s\n", sqlite3_extended_errcode(newDb),
        -:11814:                        sqlite3_errmsg(newDb));
        -:11815:      }
    #####:11816:      sqlite3_reset(pInsert);
    #####:11817:      cnt++;
    #####:11818:      if( (cnt%spinRate)==0 ){
    #####:11819:        printf("%c\b", "|/-\\"[(cnt/spinRate)%4]);
    #####:11820:        fflush(stdout);
        -:11821:      }
        -:11822:    } /* End while */
    #####:11823:    if( rc==SQLITE_DONE ) break;
    #####:11824:    sqlite3_finalize(pQuery);
    #####:11825:    sqlite3_free(zQuery);
    #####:11826:    zQuery = sqlite3_mprintf("SELECT * FROM \"%w\" ORDER BY rowid DESC;",
        -:11827:                             zTable);
    #####:11828:    rc = sqlite3_prepare_v2(p->db, zQuery, -1, &pQuery, 0);
    #####:11829:    if( rc ){
    #####:11830:      utf8_printf(stderr, "Warning: cannot step \"%s\" backwards", zTable);
    #####:11831:      break;
        -:11832:    }
        -:11833:  } /* End for(k=0...) */
        -:11834:
    #####:11835:end_data_xfer:
    #####:11836:  sqlite3_finalize(pQuery);
    #####:11837:  sqlite3_finalize(pInsert);
    #####:11838:  sqlite3_free(zQuery);
    #####:11839:  sqlite3_free(zInsert);
    #####:11840:}
        -:11841:
        -:11842:
        -:11843:/*
        -:11844:** Try to transfer all rows of the schema that match zWhere.  For
        -:11845:** each row, invoke xForEach() on the object defined by that row.
        -:11846:** If an error is encountered while moving forward through the
        -:11847:** sqlite_master table, try again moving backwards.
        -:11848:*/
    #####:11849:static void tryToCloneSchema(
        -:11850:  ShellState *p,
        -:11851:  sqlite3 *newDb,
        -:11852:  const char *zWhere,
        -:11853:  void (*xForEach)(ShellState*,sqlite3*,const char*)
        -:11854:){
    #####:11855:  sqlite3_stmt *pQuery = 0;
    #####:11856:  char *zQuery = 0;
        -:11857:  int rc;
        -:11858:  const unsigned char *zName;
        -:11859:  const unsigned char *zSql;
    #####:11860:  char *zErrMsg = 0;
        -:11861:
    #####:11862:  zQuery = sqlite3_mprintf("SELECT name, sql FROM sqlite_master"
        -:11863:                           " WHERE %s", zWhere);
    #####:11864:  rc = sqlite3_prepare_v2(p->db, zQuery, -1, &pQuery, 0);
    #####:11865:  if( rc ){
    #####:11866:    utf8_printf(stderr, "Error: (%d) %s on [%s]\n",
        -:11867:                    sqlite3_extended_errcode(p->db), sqlite3_errmsg(p->db),
        -:11868:                    zQuery);
    #####:11869:    goto end_schema_xfer;
        -:11870:  }
    #####:11871:  while( (rc = sqlite3_step(pQuery))==SQLITE_ROW ){
    #####:11872:    zName = sqlite3_column_text(pQuery, 0);
    #####:11873:    zSql = sqlite3_column_text(pQuery, 1);
    #####:11874:    printf("%s... ", zName); fflush(stdout);
    #####:11875:    sqlite3_exec(newDb, (const char*)zSql, 0, 0, &zErrMsg);
    #####:11876:    if( zErrMsg ){
    #####:11877:      utf8_printf(stderr, "Error: %s\nSQL: [%s]\n", zErrMsg, zSql);
    #####:11878:      sqlite3_free(zErrMsg);
    #####:11879:      zErrMsg = 0;
        -:11880:    }
    #####:11881:    if( xForEach ){
    #####:11882:      xForEach(p, newDb, (const char*)zName);
        -:11883:    }
    #####:11884:    printf("done\n");
        -:11885:  }
    #####:11886:  if( rc!=SQLITE_DONE ){
    #####:11887:    sqlite3_finalize(pQuery);
    #####:11888:    sqlite3_free(zQuery);
    #####:11889:    zQuery = sqlite3_mprintf("SELECT name, sql FROM sqlite_master"
        -:11890:                             " WHERE %s ORDER BY rowid DESC", zWhere);
    #####:11891:    rc = sqlite3_prepare_v2(p->db, zQuery, -1, &pQuery, 0);
    #####:11892:    if( rc ){
    #####:11893:      utf8_printf(stderr, "Error: (%d) %s on [%s]\n",
        -:11894:                      sqlite3_extended_errcode(p->db), sqlite3_errmsg(p->db),
        -:11895:                      zQuery);
    #####:11896:      goto end_schema_xfer;
        -:11897:    }
    #####:11898:    while( (rc = sqlite3_step(pQuery))==SQLITE_ROW ){
    #####:11899:      zName = sqlite3_column_text(pQuery, 0);
    #####:11900:      zSql = sqlite3_column_text(pQuery, 1);
    #####:11901:      printf("%s... ", zName); fflush(stdout);
    #####:11902:      sqlite3_exec(newDb, (const char*)zSql, 0, 0, &zErrMsg);
    #####:11903:      if( zErrMsg ){
    #####:11904:        utf8_printf(stderr, "Error: %s\nSQL: [%s]\n", zErrMsg, zSql);
    #####:11905:        sqlite3_free(zErrMsg);
    #####:11906:        zErrMsg = 0;
        -:11907:      }
    #####:11908:      if( xForEach ){
    #####:11909:        xForEach(p, newDb, (const char*)zName);
        -:11910:      }
    #####:11911:      printf("done\n");
        -:11912:    }
        -:11913:  }
    #####:11914:end_schema_xfer:
    #####:11915:  sqlite3_finalize(pQuery);
    #####:11916:  sqlite3_free(zQuery);
    #####:11917:}
        -:11918:
        -:11919:/*
        -:11920:** Open a new database file named "zNewDb".  Try to recover as much information
        -:11921:** as possible out of the main database (which might be corrupt) and write it
        -:11922:** into zNewDb.
        -:11923:*/
    #####:11924:static void tryToClone(ShellState *p, const char *zNewDb){
        -:11925:  int rc;
    #####:11926:  sqlite3 *newDb = 0;
    #####:11927:  if( access(zNewDb,0)==0 ){
    #####:11928:    utf8_printf(stderr, "File \"%s\" already exists.\n", zNewDb);
    #####:11929:    return;
        -:11930:  }
    #####:11931:  rc = sqlite3_open(zNewDb, &newDb);
    #####:11932:  if( rc ){
    #####:11933:    utf8_printf(stderr, "Cannot create output database: %s\n",
        -:11934:            sqlite3_errmsg(newDb));
        -:11935:  }else{
    #####:11936:    sqlite3_exec(p->db, "PRAGMA writable_schema=ON;", 0, 0, 0);
    #####:11937:    sqlite3_exec(newDb, "BEGIN EXCLUSIVE;", 0, 0, 0);
    #####:11938:    tryToCloneSchema(p, newDb, "type='table'", tryToCloneData);
    #####:11939:    tryToCloneSchema(p, newDb, "type!='table'", 0);
    #####:11940:    sqlite3_exec(newDb, "COMMIT;", 0, 0, 0);
    #####:11941:    sqlite3_exec(p->db, "PRAGMA writable_schema=OFF;", 0, 0, 0);
        -:11942:  }
    #####:11943:  close_db(newDb);
        -:11944:}
        -:11945:
        -:11946:/*
        -:11947:** Change the output file back to stdout.
        -:11948:**
        -:11949:** If the p->doXdgOpen flag is set, that means the output was being
        -:11950:** redirected to a temporary file named by p->zTempFile.  In that case,
        -:11951:** launch start/open/xdg-open on that temporary file.
        -:11952:*/
        2:11953:static void output_reset(ShellState *p){
        2:11954:  if( p->outfile[0]=='|' ){
        -:11955:#ifndef SQLITE_OMIT_POPEN
    #####:11956:    pclose(p->out);
        -:11957:#endif
        -:11958:  }else{
        2:11959:    output_file_close(p->out);
        -:11960:#ifndef SQLITE_NOHAVE_SYSTEM
        2:11961:    if( p->doXdgOpen ){
    #####:11962:      const char *zXdgOpenCmd =
        -:11963:#if defined(_WIN32)
        -:11964:      "start";
        -:11965:#elif defined(__APPLE__)
        -:11966:      "open";
        -:11967:#else
        -:11968:      "xdg-open";
        -:11969:#endif
        -:11970:      char *zCmd;
    #####:11971:      zCmd = sqlite3_mprintf("%s %s", zXdgOpenCmd, p->zTempFile);
    #####:11972:      if( system(zCmd) ){
    #####:11973:        utf8_printf(stderr, "Failed: [%s]\n", zCmd);
        -:11974:      }
    #####:11975:      sqlite3_free(zCmd);
    #####:11976:      outputModePop(p);
    #####:11977:      p->doXdgOpen = 0;
        -:11978:    }
        -:11979:#endif /* !defined(SQLITE_NOHAVE_SYSTEM) */
        -:11980:  }
        2:11981:  p->outfile[0] = 0;
        2:11982:  p->out = stdout;
        2:11983:}
        -:11984:
        -:11985:/*
        -:11986:** Run an SQL command and return the single integer result.
        -:11987:*/
    #####:11988:static int db_int(ShellState *p, const char *zSql){
        -:11989:  sqlite3_stmt *pStmt;
    #####:11990:  int res = 0;
    #####:11991:  sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
    #####:11992:  if( pStmt && sqlite3_step(pStmt)==SQLITE_ROW ){
    #####:11993:    res = sqlite3_column_int(pStmt,0);
        -:11994:  }
    #####:11995:  sqlite3_finalize(pStmt);
    #####:11996:  return res;
        -:11997:}
        -:11998:
        -:11999:/*
        -:12000:** Convert a 2-byte or 4-byte big-endian integer into a native integer
        -:12001:*/
    #####:12002:static unsigned int get2byteInt(unsigned char *a){
    #####:12003:  return (a[0]<<8) + a[1];
        -:12004:}
    #####:12005:static unsigned int get4byteInt(unsigned char *a){
    #####:12006:  return (a[0]<<24) + (a[1]<<16) + (a[2]<<8) + a[3];
        -:12007:}
        -:12008:
        -:12009:/*
        -:12010:** Implementation of the ".info" command.
        -:12011:**
        -:12012:** Return 1 on error, 2 to exit, and 0 otherwise.
        -:12013:*/
    #####:12014:static int shell_dbinfo_command(ShellState *p, int nArg, char **azArg){
        -:12015:  static const struct { const char *zName; int ofst; } aField[] = {
        -:12016:     { "file change counter:",  24  },
        -:12017:     { "database page count:",  28  },
        -:12018:     { "freelist page count:",  36  },
        -:12019:     { "schema cookie:",        40  },
        -:12020:     { "schema format:",        44  },
        -:12021:     { "default cache size:",   48  },
        -:12022:     { "autovacuum top root:",  52  },
        -:12023:     { "incremental vacuum:",   64  },
        -:12024:     { "text encoding:",        56  },
        -:12025:     { "user version:",         60  },
        -:12026:     { "application id:",       68  },
        -:12027:     { "software version:",     96  },
        -:12028:  };
        -:12029:  static const struct { const char *zName; const char *zSql; } aQuery[] = {
        -:12030:     { "number of tables:",
        -:12031:       "SELECT count(*) FROM %s WHERE type='table'" },
        -:12032:     { "number of indexes:",
        -:12033:       "SELECT count(*) FROM %s WHERE type='index'" },
        -:12034:     { "number of triggers:",
        -:12035:       "SELECT count(*) FROM %s WHERE type='trigger'" },
        -:12036:     { "number of views:",
        -:12037:       "SELECT count(*) FROM %s WHERE type='view'" },
        -:12038:     { "schema size:",
        -:12039:       "SELECT total(length(sql)) FROM %s" },
        -:12040:  };
        -:12041:  int i;
        -:12042:  unsigned iDataVersion;
        -:12043:  char *zSchemaTab;
    #####:12044:  char *zDb = nArg>=2 ? azArg[1] : "main";
    #####:12045:  sqlite3_stmt *pStmt = 0;
        -:12046:  unsigned char aHdr[100];
    #####:12047:  open_db(p, 0);
    #####:12048:  if( p->db==0 ) return 1;
    #####:12049:  sqlite3_prepare_v2(p->db,"SELECT data FROM sqlite_dbpage(?1) WHERE pgno=1",
        -:12050:                     -1, &pStmt, 0);
    #####:12051:  sqlite3_bind_text(pStmt, 1, zDb, -1, SQLITE_STATIC);
    #####:12052:  if( sqlite3_step(pStmt)==SQLITE_ROW
    #####:12053:   && sqlite3_column_bytes(pStmt,0)>100
        -:12054:  ){
    #####:12055:    memcpy(aHdr, sqlite3_column_blob(pStmt,0), 100);
    #####:12056:    sqlite3_finalize(pStmt);
        -:12057:  }else{
    #####:12058:    raw_printf(stderr, "unable to read database header\n");
    #####:12059:    sqlite3_finalize(pStmt);
    #####:12060:    return 1;
        -:12061:  }
    #####:12062:  i = get2byteInt(aHdr+16);
    #####:12063:  if( i==1 ) i = 65536;
    #####:12064:  utf8_printf(p->out, "%-20s %d\n", "database page size:", i);
    #####:12065:  utf8_printf(p->out, "%-20s %d\n", "write format:", aHdr[18]);
    #####:12066:  utf8_printf(p->out, "%-20s %d\n", "read format:", aHdr[19]);
    #####:12067:  utf8_printf(p->out, "%-20s %d\n", "reserved bytes:", aHdr[20]);
    #####:12068:  for(i=0; i<ArraySize(aField); i++){
    #####:12069:    int ofst = aField[i].ofst;
    #####:12070:    unsigned int val = get4byteInt(aHdr + ofst);
    #####:12071:    utf8_printf(p->out, "%-20s %u", aField[i].zName, val);
    #####:12072:    switch( ofst ){
    #####:12073:      case 56: {
    #####:12074:        if( val==1 ) raw_printf(p->out, " (utf8)");
    #####:12075:        if( val==2 ) raw_printf(p->out, " (utf16le)");
    #####:12076:        if( val==3 ) raw_printf(p->out, " (utf16be)");
        -:12077:      }
        -:12078:    }
    #####:12079:    raw_printf(p->out, "\n");
        -:12080:  }
    #####:12081:  if( zDb==0 ){
    #####:12082:    zSchemaTab = sqlite3_mprintf("main.sqlite_master");
    #####:12083:  }else if( strcmp(zDb,"temp")==0 ){
    #####:12084:    zSchemaTab = sqlite3_mprintf("%s", "sqlite_temp_master");
        -:12085:  }else{
    #####:12086:    zSchemaTab = sqlite3_mprintf("\"%w\".sqlite_master", zDb);
        -:12087:  }
    #####:12088:  for(i=0; i<ArraySize(aQuery); i++){
    #####:12089:    char *zSql = sqlite3_mprintf(aQuery[i].zSql, zSchemaTab);
    #####:12090:    int val = db_int(p, zSql);
    #####:12091:    sqlite3_free(zSql);
    #####:12092:    utf8_printf(p->out, "%-20s %d\n", aQuery[i].zName, val);
        -:12093:  }
    #####:12094:  sqlite3_free(zSchemaTab);
    #####:12095:  sqlite3_file_control(p->db, zDb, SQLITE_FCNTL_DATA_VERSION, &iDataVersion);
    #####:12096:  utf8_printf(p->out, "%-20s %u\n", "data version", iDataVersion);
    #####:12097:  return 0;
        -:12098:}
        -:12099:
        -:12100:/*
        -:12101:** Print the current sqlite3_errmsg() value to stderr and return 1.
        -:12102:*/
    #####:12103:static int shellDatabaseError(sqlite3 *db){
    #####:12104:  const char *zErr = sqlite3_errmsg(db);
    #####:12105:  utf8_printf(stderr, "Error: %s\n", zErr);
    #####:12106:  return 1;
        -:12107:}
        -:12108:
        -:12109:/*
        -:12110:** Compare the pattern in zGlob[] against the text in z[].  Return TRUE
        -:12111:** if they match and FALSE (0) if they do not match.
        -:12112:**
        -:12113:** Globbing rules:
        -:12114:**
        -:12115:**      '*'       Matches any sequence of zero or more characters.
        -:12116:**
        -:12117:**      '?'       Matches exactly one character.
        -:12118:**
        -:12119:**     [...]      Matches one character from the enclosed list of
        -:12120:**                characters.
        -:12121:**
        -:12122:**     [^...]     Matches one character not in the enclosed list.
        -:12123:**
        -:12124:**      '#'       Matches any sequence of one or more digits with an
        -:12125:**                optional + or - sign in front
        -:12126:**
        -:12127:**      ' '       Any span of whitespace matches any other span of
        -:12128:**                whitespace.
        -:12129:**
        -:12130:** Extra whitespace at the end of z[] is ignored.
        -:12131:*/
    #####:12132:static int testcase_glob(const char *zGlob, const char *z){
        -:12133:  int c, c2;
        -:12134:  int invert;
        -:12135:  int seen;
        -:12136:
    #####:12137:  while( (c = (*(zGlob++)))!=0 ){
    #####:12138:    if( IsSpace(c) ){
    #####:12139:      if( !IsSpace(*z) ) return 0;
    #####:12140:      while( IsSpace(*zGlob) ) zGlob++;
    #####:12141:      while( IsSpace(*z) ) z++;
    #####:12142:    }else if( c=='*' ){
    #####:12143:      while( (c=(*(zGlob++))) == '*' || c=='?' ){
    #####:12144:        if( c=='?' && (*(z++))==0 ) return 0;
        -:12145:      }
    #####:12146:      if( c==0 ){
    #####:12147:        return 1;
    #####:12148:      }else if( c=='[' ){
    #####:12149:        while( *z && testcase_glob(zGlob-1,z)==0 ){
    #####:12150:          z++;
        -:12151:        }
    #####:12152:        return (*z)!=0;
        -:12153:      }
    #####:12154:      while( (c2 = (*(z++)))!=0 ){
    #####:12155:        while( c2!=c ){
    #####:12156:          c2 = *(z++);
    #####:12157:          if( c2==0 ) return 0;
        -:12158:        }
    #####:12159:        if( testcase_glob(zGlob,z) ) return 1;
        -:12160:      }
    #####:12161:      return 0;
    #####:12162:    }else if( c=='?' ){
    #####:12163:      if( (*(z++))==0 ) return 0;
    #####:12164:    }else if( c=='[' ){
    #####:12165:      int prior_c = 0;
    #####:12166:      seen = 0;
    #####:12167:      invert = 0;
    #####:12168:      c = *(z++);
    #####:12169:      if( c==0 ) return 0;
    #####:12170:      c2 = *(zGlob++);
    #####:12171:      if( c2=='^' ){
    #####:12172:        invert = 1;
    #####:12173:        c2 = *(zGlob++);
        -:12174:      }
    #####:12175:      if( c2==']' ){
    #####:12176:        if( c==']' ) seen = 1;
    #####:12177:        c2 = *(zGlob++);
        -:12178:      }
    #####:12179:      while( c2 && c2!=']' ){
    #####:12180:        if( c2=='-' && zGlob[0]!=']' && zGlob[0]!=0 && prior_c>0 ){
    #####:12181:          c2 = *(zGlob++);
    #####:12182:          if( c>=prior_c && c<=c2 ) seen = 1;
    #####:12183:          prior_c = 0;
        -:12184:        }else{
    #####:12185:          if( c==c2 ){
    #####:12186:            seen = 1;
        -:12187:          }
    #####:12188:          prior_c = c2;
        -:12189:        }
    #####:12190:        c2 = *(zGlob++);
        -:12191:      }
    #####:12192:      if( c2==0 || (seen ^ invert)==0 ) return 0;
    #####:12193:    }else if( c=='#' ){
    #####:12194:      if( (z[0]=='-' || z[0]=='+') && IsDigit(z[1]) ) z++;
    #####:12195:      if( !IsDigit(z[0]) ) return 0;
    #####:12196:      z++;
    #####:12197:      while( IsDigit(z[0]) ){ z++; }
        -:12198:    }else{
    #####:12199:      if( c!=(*(z++)) ) return 0;
        -:12200:    }
        -:12201:  }
    #####:12202:  while( IsSpace(*z) ){ z++; }
    #####:12203:  return *z==0;
        -:12204:}
        -:12205:
        -:12206:
        -:12207:/*
        -:12208:** Compare the string as a command-line option with either one or two
        -:12209:** initial "-" characters.
        -:12210:*/
    #####:12211:static int optionMatch(const char *zStr, const char *zOpt){
    #####:12212:  if( zStr[0]!='-' ) return 0;
    #####:12213:  zStr++;
    #####:12214:  if( zStr[0]=='-' ) zStr++;
    #####:12215:  return strcmp(zStr, zOpt)==0;
        -:12216:}
        -:12217:
        -:12218:/*
        -:12219:** Delete a file.
        -:12220:*/
    #####:12221:int shellDeleteFile(const char *zFilename){
        -:12222:  int rc;
        -:12223:#ifdef _WIN32
        -:12224:  wchar_t *z = sqlite3_win32_utf8_to_unicode(zFilename);
        -:12225:  rc = _wunlink(z);
        -:12226:  sqlite3_free(z);
        -:12227:#else
    #####:12228:  rc = unlink(zFilename);
        -:12229:#endif
    #####:12230:  return rc;
        -:12231:}
        -:12232:
        -:12233:/*
        -:12234:** Try to delete the temporary file (if there is one) and free the
        -:12235:** memory used to hold the name of the temp file.
        -:12236:*/
        6:12237:static void clearTempFile(ShellState *p){
        6:12238:  if( p->zTempFile==0 ) return;
    #####:12239:  if( p->doXdgOpen ) return;
    #####:12240:  if( shellDeleteFile(p->zTempFile) ) return;
    #####:12241:  sqlite3_free(p->zTempFile);
    #####:12242:  p->zTempFile = 0;
        -:12243:}
        -:12244:
        -:12245:/*
        -:12246:** Create a new temp file name with the given suffix.
        -:12247:*/
    #####:12248:static void newTempFile(ShellState *p, const char *zSuffix){
    #####:12249:  clearTempFile(p);
    #####:12250:  sqlite3_free(p->zTempFile);
    #####:12251:  p->zTempFile = 0;
    #####:12252:  if( p->db ){
    #####:12253:    sqlite3_file_control(p->db, 0, SQLITE_FCNTL_TEMPFILENAME, &p->zTempFile);
        -:12254:  }
    #####:12255:  if( p->zTempFile==0 ){
        -:12256:    sqlite3_uint64 r;
    #####:12257:    sqlite3_randomness(sizeof(r), &r);
    #####:12258:    p->zTempFile = sqlite3_mprintf("temp%llx.%s", r, zSuffix);
        -:12259:  }else{
    #####:12260:    p->zTempFile = sqlite3_mprintf("%z.%s", p->zTempFile, zSuffix);
        -:12261:  }
    #####:12262:  if( p->zTempFile==0 ){
    #####:12263:    raw_printf(stderr, "out of memory\n");
    #####:12264:    exit(1);
        -:12265:  }
    #####:12266:}
        -:12267:
        -:12268:
        -:12269:/*
        -:12270:** The implementation of SQL scalar function fkey_collate_clause(), used
        -:12271:** by the ".lint fkey-indexes" command. This scalar function is always
        -:12272:** called with four arguments - the parent table name, the parent column name,
        -:12273:** the child table name and the child column name.
        -:12274:**
        -:12275:**   fkey_collate_clause('parent-tab', 'parent-col', 'child-tab', 'child-col')
        -:12276:**
        -:12277:** If either of the named tables or columns do not exist, this function
        -:12278:** returns an empty string. An empty string is also returned if both tables
        -:12279:** and columns exist but have the same default collation sequence. Or,
        -:12280:** if both exist but the default collation sequences are different, this
        -:12281:** function returns the string " COLLATE <parent-collation>", where
        -:12282:** <parent-collation> is the default collation sequence of the parent column.
        -:12283:*/
    #####:12284:static void shellFkeyCollateClause(
        -:12285:  sqlite3_context *pCtx,
        -:12286:  int nVal,
        -:12287:  sqlite3_value **apVal
        -:12288:){
    #####:12289:  sqlite3 *db = sqlite3_context_db_handle(pCtx);
        -:12290:  const char *zParent;
        -:12291:  const char *zParentCol;
        -:12292:  const char *zParentSeq;
        -:12293:  const char *zChild;
        -:12294:  const char *zChildCol;
    #####:12295:  const char *zChildSeq = 0;  /* Initialize to avoid false-positive warning */
        -:12296:  int rc;
        -:12297:
        -:12298:  assert( nVal==4 );
    #####:12299:  zParent = (const char*)sqlite3_value_text(apVal[0]);
    #####:12300:  zParentCol = (const char*)sqlite3_value_text(apVal[1]);
    #####:12301:  zChild = (const char*)sqlite3_value_text(apVal[2]);
    #####:12302:  zChildCol = (const char*)sqlite3_value_text(apVal[3]);
        -:12303:
    #####:12304:  sqlite3_result_text(pCtx, "", -1, SQLITE_STATIC);
    #####:12305:  rc = sqlite3_table_column_metadata(
        -:12306:      db, "main", zParent, zParentCol, 0, &zParentSeq, 0, 0, 0
        -:12307:  );
    #####:12308:  if( rc==SQLITE_OK ){
    #####:12309:    rc = sqlite3_table_column_metadata(
        -:12310:        db, "main", zChild, zChildCol, 0, &zChildSeq, 0, 0, 0
        -:12311:    );
        -:12312:  }
        -:12313:
    #####:12314:  if( rc==SQLITE_OK && sqlite3_stricmp(zParentSeq, zChildSeq) ){
    #####:12315:    char *z = sqlite3_mprintf(" COLLATE %s", zParentSeq);
    #####:12316:    sqlite3_result_text(pCtx, z, -1, SQLITE_TRANSIENT);
    #####:12317:    sqlite3_free(z);
        -:12318:  }
    #####:12319:}
        -:12320:
        -:12321:
        -:12322:/*
        -:12323:** The implementation of dot-command ".lint fkey-indexes".
        -:12324:*/
    #####:12325:static int lintFkeyIndexes(
        -:12326:  ShellState *pState,             /* Current shell tool state */
        -:12327:  char **azArg,                   /* Array of arguments passed to dot command */
        -:12328:  int nArg                        /* Number of entries in azArg[] */
        -:12329:){
    #####:12330:  sqlite3 *db = pState->db;       /* Database handle to query "main" db of */
    #####:12331:  FILE *out = pState->out;        /* Stream to write non-error output to */
    #####:12332:  int bVerbose = 0;               /* If -verbose is present */
    #####:12333:  int bGroupByParent = 0;         /* If -groupbyparent is present */
        -:12334:  int i;                          /* To iterate through azArg[] */
    #####:12335:  const char *zIndent = "";       /* How much to indent CREATE INDEX by */
        -:12336:  int rc;                         /* Return code */
    #####:12337:  sqlite3_stmt *pSql = 0;         /* Compiled version of SQL statement below */
        -:12338:
        -:12339:  /*
        -:12340:  ** This SELECT statement returns one row for each foreign key constraint
        -:12341:  ** in the schema of the main database. The column values are:
        -:12342:  **
        -:12343:  ** 0. The text of an SQL statement similar to:
        -:12344:  **
        -:12345:  **      "EXPLAIN QUERY PLAN SELECT 1 FROM child_table WHERE child_key=?"
        -:12346:  **
        -:12347:  **    This SELECT is similar to the one that the foreign keys implementation
        -:12348:  **    needs to run internally on child tables. If there is an index that can
        -:12349:  **    be used to optimize this query, then it can also be used by the FK
        -:12350:  **    implementation to optimize DELETE or UPDATE statements on the parent
        -:12351:  **    table.
        -:12352:  **
        -:12353:  ** 1. A GLOB pattern suitable for sqlite3_strglob(). If the plan output by
        -:12354:  **    the EXPLAIN QUERY PLAN command matches this pattern, then the schema
        -:12355:  **    contains an index that can be used to optimize the query.
        -:12356:  **
        -:12357:  ** 2. Human readable text that describes the child table and columns. e.g.
        -:12358:  **
        -:12359:  **       "child_table(child_key1, child_key2)"
        -:12360:  **
        -:12361:  ** 3. Human readable text that describes the parent table and columns. e.g.
        -:12362:  **
        -:12363:  **       "parent_table(parent_key1, parent_key2)"
        -:12364:  **
        -:12365:  ** 4. A full CREATE INDEX statement for an index that could be used to
        -:12366:  **    optimize DELETE or UPDATE statements on the parent table. e.g.
        -:12367:  **
        -:12368:  **       "CREATE INDEX child_table_child_key ON child_table(child_key)"
        -:12369:  **
        -:12370:  ** 5. The name of the parent table.
        -:12371:  **
        -:12372:  ** These six values are used by the C logic below to generate the report.
        -:12373:  */
    #####:12374:  const char *zSql =
        -:12375:  "SELECT "
        -:12376:    "     'EXPLAIN QUERY PLAN SELECT 1 FROM ' || quote(s.name) || ' WHERE '"
        -:12377:    "  || group_concat(quote(s.name) || '.' || quote(f.[from]) || '=?' "
        -:12378:    "  || fkey_collate_clause("
        -:12379:    "       f.[table], COALESCE(f.[to], p.[name]), s.name, f.[from]),' AND ')"
        -:12380:    ", "
        -:12381:    "     'SEARCH TABLE ' || s.name || ' USING COVERING INDEX*('"
        -:12382:    "  || group_concat('*=?', ' AND ') || ')'"
        -:12383:    ", "
        -:12384:    "     s.name  || '(' || group_concat(f.[from],  ', ') || ')'"
        -:12385:    ", "
        -:12386:    "     f.[table] || '(' || group_concat(COALESCE(f.[to], p.[name])) || ')'"
        -:12387:    ", "
        -:12388:    "     'CREATE INDEX ' || quote(s.name ||'_'|| group_concat(f.[from], '_'))"
        -:12389:    "  || ' ON ' || quote(s.name) || '('"
        -:12390:    "  || group_concat(quote(f.[from]) ||"
        -:12391:    "        fkey_collate_clause("
        -:12392:    "          f.[table], COALESCE(f.[to], p.[name]), s.name, f.[from]), ', ')"
        -:12393:    "  || ');'"
        -:12394:    ", "
        -:12395:    "     f.[table] "
        -:12396:    "FROM sqlite_master AS s, pragma_foreign_key_list(s.name) AS f "
        -:12397:    "LEFT JOIN pragma_table_info AS p ON (pk-1=seq AND p.arg=f.[table]) "
        -:12398:    "GROUP BY s.name, f.id "
        -:12399:    "ORDER BY (CASE WHEN ? THEN f.[table] ELSE s.name END)"
        -:12400:  ;
    #####:12401:  const char *zGlobIPK = "SEARCH TABLE * USING INTEGER PRIMARY KEY (rowid=?)";
        -:12402:
    #####:12403:  for(i=2; i<nArg; i++){
    #####:12404:    int n = strlen30(azArg[i]);
    #####:12405:    if( n>1 && sqlite3_strnicmp("-verbose", azArg[i], n)==0 ){
    #####:12406:      bVerbose = 1;
        -:12407:    }
    #####:12408:    else if( n>1 && sqlite3_strnicmp("-groupbyparent", azArg[i], n)==0 ){
    #####:12409:      bGroupByParent = 1;
    #####:12410:      zIndent = "    ";
        -:12411:    }
        -:12412:    else{
    #####:12413:      raw_printf(stderr, "Usage: %s %s ?-verbose? ?-groupbyparent?\n",
    #####:12414:          azArg[0], azArg[1]
        -:12415:      );
    #####:12416:      return SQLITE_ERROR;
        -:12417:    }
        -:12418:  }
        -:12419:
        -:12420:  /* Register the fkey_collate_clause() SQL function */
    #####:12421:  rc = sqlite3_create_function(db, "fkey_collate_clause", 4, SQLITE_UTF8,
        -:12422:      0, shellFkeyCollateClause, 0, 0
        -:12423:  );
        -:12424:
        -:12425:
    #####:12426:  if( rc==SQLITE_OK ){
    #####:12427:    rc = sqlite3_prepare_v2(db, zSql, -1, &pSql, 0);
        -:12428:  }
    #####:12429:  if( rc==SQLITE_OK ){
    #####:12430:    sqlite3_bind_int(pSql, 1, bGroupByParent);
        -:12431:  }
        -:12432:
    #####:12433:  if( rc==SQLITE_OK ){
        -:12434:    int rc2;
    #####:12435:    char *zPrev = 0;
    #####:12436:    while( SQLITE_ROW==sqlite3_step(pSql) ){
    #####:12437:      int res = -1;
    #####:12438:      sqlite3_stmt *pExplain = 0;
    #####:12439:      const char *zEQP = (const char*)sqlite3_column_text(pSql, 0);
    #####:12440:      const char *zGlob = (const char*)sqlite3_column_text(pSql, 1);
    #####:12441:      const char *zFrom = (const char*)sqlite3_column_text(pSql, 2);
    #####:12442:      const char *zTarget = (const char*)sqlite3_column_text(pSql, 3);
    #####:12443:      const char *zCI = (const char*)sqlite3_column_text(pSql, 4);
    #####:12444:      const char *zParent = (const char*)sqlite3_column_text(pSql, 5);
        -:12445:
    #####:12446:      rc = sqlite3_prepare_v2(db, zEQP, -1, &pExplain, 0);
    #####:12447:      if( rc!=SQLITE_OK ) break;
    #####:12448:      if( SQLITE_ROW==sqlite3_step(pExplain) ){
    #####:12449:        const char *zPlan = (const char*)sqlite3_column_text(pExplain, 3);
    #####:12450:        res = (
    #####:12451:              0==sqlite3_strglob(zGlob, zPlan)
    #####:12452:           || 0==sqlite3_strglob(zGlobIPK, zPlan)
        -:12453:        );
        -:12454:      }
    #####:12455:      rc = sqlite3_finalize(pExplain);
    #####:12456:      if( rc!=SQLITE_OK ) break;
        -:12457:
    #####:12458:      if( res<0 ){
    #####:12459:        raw_printf(stderr, "Error: internal error");
    #####:12460:        break;
        -:12461:      }else{
    #####:12462:        if( bGroupByParent
    #####:12463:        && (bVerbose || res==0)
    #####:12464:        && (zPrev==0 || sqlite3_stricmp(zParent, zPrev))
        -:12465:        ){
    #####:12466:          raw_printf(out, "-- Parent table %s\n", zParent);
    #####:12467:          sqlite3_free(zPrev);
    #####:12468:          zPrev = sqlite3_mprintf("%s", zParent);
        -:12469:        }
        -:12470:
    #####:12471:        if( res==0 ){
    #####:12472:          raw_printf(out, "%s%s --> %s\n", zIndent, zCI, zTarget);
    #####:12473:        }else if( bVerbose ){
    #####:12474:          raw_printf(out, "%s/* no extra indexes required for %s -> %s */\n",
        -:12475:              zIndent, zFrom, zTarget
        -:12476:          );
        -:12477:        }
        -:12478:      }
        -:12479:    }
    #####:12480:    sqlite3_free(zPrev);
        -:12481:
    #####:12482:    if( rc!=SQLITE_OK ){
    #####:12483:      raw_printf(stderr, "%s\n", sqlite3_errmsg(db));
        -:12484:    }
        -:12485:
    #####:12486:    rc2 = sqlite3_finalize(pSql);
    #####:12487:    if( rc==SQLITE_OK && rc2!=SQLITE_OK ){
    #####:12488:      rc = rc2;
    #####:12489:      raw_printf(stderr, "%s\n", sqlite3_errmsg(db));
        -:12490:    }
        -:12491:  }else{
    #####:12492:    raw_printf(stderr, "%s\n", sqlite3_errmsg(db));
        -:12493:  }
        -:12494:
    #####:12495:  return rc;
        -:12496:}
        -:12497:
        -:12498:/*
        -:12499:** Implementation of ".lint" dot command.
        -:12500:*/
    #####:12501:static int lintDotCommand(
        -:12502:  ShellState *pState,             /* Current shell tool state */
        -:12503:  char **azArg,                   /* Array of arguments passed to dot command */
        -:12504:  int nArg                        /* Number of entries in azArg[] */
        -:12505:){
        -:12506:  int n;
    #####:12507:  n = (nArg>=2 ? strlen30(azArg[1]) : 0);
    #####:12508:  if( n<1 || sqlite3_strnicmp(azArg[1], "fkey-indexes", n) ) goto usage;
    #####:12509:  return lintFkeyIndexes(pState, azArg, nArg);
        -:12510:
    #####:12511: usage:
    #####:12512:  raw_printf(stderr, "Usage %s sub-command ?switches...?\n", azArg[0]);
    #####:12513:  raw_printf(stderr, "Where sub-commands are:\n");
    #####:12514:  raw_printf(stderr, "    fkey-indexes\n");
    #####:12515:  return SQLITE_ERROR;
        -:12516:}
        -:12517:
        -:12518:#if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_HAVE_ZLIB)
        -:12519:/*********************************************************************************
        -:12520:** The ".archive" or ".ar" command.
        -:12521:*/
    #####:12522:static void shellPrepare(
        -:12523:  sqlite3 *db, 
        -:12524:  int *pRc, 
        -:12525:  const char *zSql, 
        -:12526:  sqlite3_stmt **ppStmt
        -:12527:){
    #####:12528:  *ppStmt = 0;
    #####:12529:  if( *pRc==SQLITE_OK ){
    #####:12530:    int rc = sqlite3_prepare_v2(db, zSql, -1, ppStmt, 0);
    #####:12531:    if( rc!=SQLITE_OK ){
    #####:12532:      raw_printf(stderr, "sql error: %s (%d)\n", 
        -:12533:          sqlite3_errmsg(db), sqlite3_errcode(db)
        -:12534:      );
    #####:12535:      *pRc = rc;
        -:12536:    }
        -:12537:  }
    #####:12538:}
        -:12539:
    #####:12540:static void shellPreparePrintf(
        -:12541:  sqlite3 *db, 
        -:12542:  int *pRc, 
        -:12543:  sqlite3_stmt **ppStmt,
        -:12544:  const char *zFmt, 
        -:12545:  ...
        -:12546:){
    #####:12547:  *ppStmt = 0;
    #####:12548:  if( *pRc==SQLITE_OK ){
        -:12549:    va_list ap;
        -:12550:    char *z;
    #####:12551:    va_start(ap, zFmt);
    #####:12552:    z = sqlite3_vmprintf(zFmt, ap);
    #####:12553:    va_end(ap);
    #####:12554:    if( z==0 ){
    #####:12555:      *pRc = SQLITE_NOMEM;
        -:12556:    }else{
    #####:12557:      shellPrepare(db, pRc, z, ppStmt);
    #####:12558:      sqlite3_free(z);
        -:12559:    }
        -:12560:  }
    #####:12561:}
        -:12562:
    #####:12563:static void shellFinalize(
        -:12564:  int *pRc, 
        -:12565:  sqlite3_stmt *pStmt
        -:12566:){
    #####:12567:  if( pStmt ){
    #####:12568:    sqlite3 *db = sqlite3_db_handle(pStmt);
    #####:12569:    int rc = sqlite3_finalize(pStmt);
    #####:12570:    if( *pRc==SQLITE_OK ){
    #####:12571:      if( rc!=SQLITE_OK ){
    #####:12572:        raw_printf(stderr, "SQL error: %s\n", sqlite3_errmsg(db));
        -:12573:      }
    #####:12574:      *pRc = rc;
        -:12575:    }
        -:12576:  }
    #####:12577:}
        -:12578:
    #####:12579:static void shellReset(
        -:12580:  int *pRc, 
        -:12581:  sqlite3_stmt *pStmt
        -:12582:){
    #####:12583:  int rc = sqlite3_reset(pStmt);
    #####:12584:  if( *pRc==SQLITE_OK ){
    #####:12585:    if( rc!=SQLITE_OK ){
    #####:12586:      sqlite3 *db = sqlite3_db_handle(pStmt);
    #####:12587:      raw_printf(stderr, "SQL error: %s\n", sqlite3_errmsg(db));
        -:12588:    }
    #####:12589:    *pRc = rc;
        -:12590:  }
    #####:12591:}
        -:12592:/*
        -:12593:** Structure representing a single ".ar" command.
        -:12594:*/
        -:12595:typedef struct ArCommand ArCommand;
        -:12596:struct ArCommand {
        -:12597:  u8 eCmd;                        /* An AR_CMD_* value */
        -:12598:  u8 bVerbose;                    /* True if --verbose */
        -:12599:  u8 bZip;                        /* True if the archive is a ZIP */
        -:12600:  u8 bDryRun;                     /* True if --dry-run */
        -:12601:  u8 bAppend;                     /* True if --append */
        -:12602:  u8 fromCmdLine;                 /* Run from -A instead of .archive */
        -:12603:  int nArg;                       /* Number of command arguments */
        -:12604:  char *zSrcTable;                /* "sqlar", "zipfile($file)" or "zip" */
        -:12605:  const char *zFile;              /* --file argument, or NULL */
        -:12606:  const char *zDir;               /* --directory argument, or NULL */
        -:12607:  char **azArg;                   /* Array of command arguments */
        -:12608:  ShellState *p;                  /* Shell state */
        -:12609:  sqlite3 *db;                    /* Database containing the archive */
        -:12610:};
        -:12611:
        -:12612:/*
        -:12613:** Print a usage message for the .ar command to stderr and return SQLITE_ERROR.
        -:12614:*/
    #####:12615:static int arUsage(FILE *f){
    #####:12616:  showHelp(f,"archive");
    #####:12617:  return SQLITE_ERROR;
        -:12618:}
        -:12619:
        -:12620:/*
        -:12621:** Print an error message for the .ar command to stderr and return 
        -:12622:** SQLITE_ERROR.
        -:12623:*/
    #####:12624:static int arErrorMsg(ArCommand *pAr, const char *zFmt, ...){
        -:12625:  va_list ap;
        -:12626:  char *z;
    #####:12627:  va_start(ap, zFmt);
    #####:12628:  z = sqlite3_vmprintf(zFmt, ap);
    #####:12629:  va_end(ap);
    #####:12630:  utf8_printf(stderr, "Error: %s\n", z);
    #####:12631:  if( pAr->fromCmdLine ){
    #####:12632:    utf8_printf(stderr, "Use \"-A\" for more help\n");
        -:12633:  }else{
    #####:12634:    utf8_printf(stderr, "Use \".archive --help\" for more help\n");
        -:12635:  }
    #####:12636:  sqlite3_free(z);
    #####:12637:  return SQLITE_ERROR;
        -:12638:}
        -:12639:
        -:12640:/*
        -:12641:** Values for ArCommand.eCmd.
        -:12642:*/
        -:12643:#define AR_CMD_CREATE       1
        -:12644:#define AR_CMD_EXTRACT      2
        -:12645:#define AR_CMD_LIST         3
        -:12646:#define AR_CMD_UPDATE       4
        -:12647:#define AR_CMD_HELP         5
        -:12648:
        -:12649:/*
        -:12650:** Other (non-command) switches.
        -:12651:*/
        -:12652:#define AR_SWITCH_VERBOSE     6
        -:12653:#define AR_SWITCH_FILE        7
        -:12654:#define AR_SWITCH_DIRECTORY   8
        -:12655:#define AR_SWITCH_APPEND      9
        -:12656:#define AR_SWITCH_DRYRUN     10
        -:12657:
    #####:12658:static int arProcessSwitch(ArCommand *pAr, int eSwitch, const char *zArg){
    #####:12659:  switch( eSwitch ){
    #####:12660:    case AR_CMD_CREATE:
        -:12661:    case AR_CMD_EXTRACT:
        -:12662:    case AR_CMD_LIST:
        -:12663:    case AR_CMD_UPDATE:
        -:12664:    case AR_CMD_HELP:
    #####:12665:      if( pAr->eCmd ){
    #####:12666:        return arErrorMsg(pAr, "multiple command options");
        -:12667:      }
    #####:12668:      pAr->eCmd = eSwitch;
    #####:12669:      break;
        -:12670:
    #####:12671:    case AR_SWITCH_DRYRUN:
    #####:12672:      pAr->bDryRun = 1;
    #####:12673:      break;
    #####:12674:    case AR_SWITCH_VERBOSE:
    #####:12675:      pAr->bVerbose = 1;
    #####:12676:      break;
    #####:12677:    case AR_SWITCH_APPEND:
    #####:12678:      pAr->bAppend = 1;
        -:12679:      /* Fall thru into --file */
    #####:12680:    case AR_SWITCH_FILE:
    #####:12681:      pAr->zFile = zArg;
    #####:12682:      break;
    #####:12683:    case AR_SWITCH_DIRECTORY:
    #####:12684:      pAr->zDir = zArg;
    #####:12685:      break;
        -:12686:  }
        -:12687:
    #####:12688:  return SQLITE_OK;
        -:12689:}
        -:12690:
        -:12691:/*
        -:12692:** Parse the command line for an ".ar" command. The results are written into
        -:12693:** structure (*pAr). SQLITE_OK is returned if the command line is parsed
        -:12694:** successfully, otherwise an error message is written to stderr and 
        -:12695:** SQLITE_ERROR returned.
        -:12696:*/
    #####:12697:static int arParseCommand(
        -:12698:  char **azArg,                   /* Array of arguments passed to dot command */
        -:12699:  int nArg,                       /* Number of entries in azArg[] */
        -:12700:  ArCommand *pAr                  /* Populate this object */
        -:12701:){
        -:12702:  struct ArSwitch {
        -:12703:    const char *zLong;
        -:12704:    char cShort;
        -:12705:    u8 eSwitch;
        -:12706:    u8 bArg;
    #####:12707:  } aSwitch[] = {
        -:12708:    { "create",    'c', AR_CMD_CREATE,       0 },
        -:12709:    { "extract",   'x', AR_CMD_EXTRACT,      0 },
        -:12710:    { "list",      't', AR_CMD_LIST,         0 },
        -:12711:    { "update",    'u', AR_CMD_UPDATE,       0 },
        -:12712:    { "help",      'h', AR_CMD_HELP,         0 },
        -:12713:    { "verbose",   'v', AR_SWITCH_VERBOSE,   0 },
        -:12714:    { "file",      'f', AR_SWITCH_FILE,      1 },
        -:12715:    { "append",    'a', AR_SWITCH_APPEND,    1 },
        -:12716:    { "directory", 'C', AR_SWITCH_DIRECTORY, 1 },
        -:12717:    { "dryrun",    'n', AR_SWITCH_DRYRUN,    0 },
        -:12718:  };
    #####:12719:  int nSwitch = sizeof(aSwitch) / sizeof(struct ArSwitch);
    #####:12720:  struct ArSwitch *pEnd = &aSwitch[nSwitch];
        -:12721:
    #####:12722:  if( nArg<=1 ){
    #####:12723:    utf8_printf(stderr, "Wrong number of arguments.  Usage:\n");
    #####:12724:    return arUsage(stderr);
        -:12725:  }else{
    #####:12726:    char *z = azArg[1];
    #####:12727:    if( z[0]!='-' ){
        -:12728:      /* Traditional style [tar] invocation */
        -:12729:      int i;
    #####:12730:      int iArg = 2;
    #####:12731:      for(i=0; z[i]; i++){
    #####:12732:        const char *zArg = 0;
        -:12733:        struct ArSwitch *pOpt;
    #####:12734:        for(pOpt=&aSwitch[0]; pOpt<pEnd; pOpt++){
    #####:12735:          if( z[i]==pOpt->cShort ) break;
        -:12736:        }
    #####:12737:        if( pOpt==pEnd ){
    #####:12738:          return arErrorMsg(pAr, "unrecognized option: %c", z[i]);
        -:12739:        }
    #####:12740:        if( pOpt->bArg ){
    #####:12741:          if( iArg>=nArg ){
    #####:12742:            return arErrorMsg(pAr, "option requires an argument: %c",z[i]);
        -:12743:          }
    #####:12744:          zArg = azArg[iArg++];
        -:12745:        }
    #####:12746:        if( arProcessSwitch(pAr, pOpt->eSwitch, zArg) ) return SQLITE_ERROR;
        -:12747:      }
    #####:12748:      pAr->nArg = nArg-iArg;
    #####:12749:      if( pAr->nArg>0 ){
    #####:12750:        pAr->azArg = &azArg[iArg];
        -:12751:      }
        -:12752:    }else{
        -:12753:      /* Non-traditional invocation */
        -:12754:      int iArg;
    #####:12755:      for(iArg=1; iArg<nArg; iArg++){
        -:12756:        int n;
    #####:12757:        z = azArg[iArg];
    #####:12758:        if( z[0]!='-' ){
        -:12759:          /* All remaining command line words are command arguments. */
    #####:12760:          pAr->azArg = &azArg[iArg];
    #####:12761:          pAr->nArg = nArg-iArg;
    #####:12762:          break;
        -:12763:        }
    #####:12764:        n = strlen30(z);
        -:12765:
    #####:12766:        if( z[1]!='-' ){
        -:12767:          int i;
        -:12768:          /* One or more short options */
    #####:12769:          for(i=1; i<n; i++){
    #####:12770:            const char *zArg = 0;
        -:12771:            struct ArSwitch *pOpt;
    #####:12772:            for(pOpt=&aSwitch[0]; pOpt<pEnd; pOpt++){
    #####:12773:              if( z[i]==pOpt->cShort ) break;
        -:12774:            }
    #####:12775:            if( pOpt==pEnd ){
    #####:12776:              return arErrorMsg(pAr, "unrecognized option: %c", z[i]);
        -:12777:            }
    #####:12778:            if( pOpt->bArg ){
    #####:12779:              if( i<(n-1) ){
    #####:12780:                zArg = &z[i+1];
    #####:12781:                i = n;
        -:12782:              }else{
    #####:12783:                if( iArg>=(nArg-1) ){
    #####:12784:                  return arErrorMsg(pAr, "option requires an argument: %c",z[i]);
        -:12785:                }
    #####:12786:                zArg = azArg[++iArg];
        -:12787:              }
        -:12788:            }
    #####:12789:            if( arProcessSwitch(pAr, pOpt->eSwitch, zArg) ) return SQLITE_ERROR;
        -:12790:          }
    #####:12791:        }else if( z[2]=='\0' ){
        -:12792:          /* A -- option, indicating that all remaining command line words
        -:12793:          ** are command arguments.  */
    #####:12794:          pAr->azArg = &azArg[iArg+1];
    #####:12795:          pAr->nArg = nArg-iArg-1;
    #####:12796:          break;
        -:12797:        }else{
        -:12798:          /* A long option */
    #####:12799:          const char *zArg = 0;             /* Argument for option, if any */
    #####:12800:          struct ArSwitch *pMatch = 0;      /* Matching option */
        -:12801:          struct ArSwitch *pOpt;            /* Iterator */
    #####:12802:          for(pOpt=&aSwitch[0]; pOpt<pEnd; pOpt++){
    #####:12803:            const char *zLong = pOpt->zLong;
    #####:12804:            if( (n-2)<=strlen30(zLong) && 0==memcmp(&z[2], zLong, n-2) ){
    #####:12805:              if( pMatch ){
    #####:12806:                return arErrorMsg(pAr, "ambiguous option: %s",z);
        -:12807:              }else{
    #####:12808:                pMatch = pOpt;
        -:12809:              }
        -:12810:            }
        -:12811:          }
        -:12812:
    #####:12813:          if( pMatch==0 ){
    #####:12814:            return arErrorMsg(pAr, "unrecognized option: %s", z);
        -:12815:          }
    #####:12816:          if( pMatch->bArg ){
    #####:12817:            if( iArg>=(nArg-1) ){
    #####:12818:              return arErrorMsg(pAr, "option requires an argument: %s", z);
        -:12819:            }
    #####:12820:            zArg = azArg[++iArg];
        -:12821:          }
    #####:12822:          if( arProcessSwitch(pAr, pMatch->eSwitch, zArg) ) return SQLITE_ERROR;
        -:12823:        }
        -:12824:      }
        -:12825:    }
        -:12826:  }
        -:12827:
    #####:12828:  return SQLITE_OK;
        -:12829:}
        -:12830:
        -:12831:/*
        -:12832:** This function assumes that all arguments within the ArCommand.azArg[]
        -:12833:** array refer to archive members, as for the --extract or --list commands. 
        -:12834:** It checks that each of them are present. If any specified file is not
        -:12835:** present in the archive, an error is printed to stderr and an error
        -:12836:** code returned. Otherwise, if all specified arguments are present in
        -:12837:** the archive, SQLITE_OK is returned.
        -:12838:**
        -:12839:** This function strips any trailing '/' characters from each argument.
        -:12840:** This is consistent with the way the [tar] command seems to work on
        -:12841:** Linux.
        -:12842:*/
    #####:12843:static int arCheckEntries(ArCommand *pAr){
    #####:12844:  int rc = SQLITE_OK;
    #####:12845:  if( pAr->nArg ){
        -:12846:    int i, j;
    #####:12847:    sqlite3_stmt *pTest = 0;
        -:12848:
    #####:12849:    shellPreparePrintf(pAr->db, &rc, &pTest,
        -:12850:        "SELECT name FROM %s WHERE name=$name", 
        -:12851:        pAr->zSrcTable
        -:12852:    );
    #####:12853:    j = sqlite3_bind_parameter_index(pTest, "$name");
    #####:12854:    for(i=0; i<pAr->nArg && rc==SQLITE_OK; i++){
    #####:12855:      char *z = pAr->azArg[i];
    #####:12856:      int n = strlen30(z);
    #####:12857:      int bOk = 0;
    #####:12858:      while( n>0 && z[n-1]=='/' ) n--;
    #####:12859:      z[n] = '\0';
    #####:12860:      sqlite3_bind_text(pTest, j, z, -1, SQLITE_STATIC);
    #####:12861:      if( SQLITE_ROW==sqlite3_step(pTest) ){
    #####:12862:        bOk = 1;
        -:12863:      }
    #####:12864:      shellReset(&rc, pTest);
    #####:12865:      if( rc==SQLITE_OK && bOk==0 ){
    #####:12866:        utf8_printf(stderr, "not found in archive: %s\n", z);
    #####:12867:        rc = SQLITE_ERROR;
        -:12868:      }
        -:12869:    }
    #####:12870:    shellFinalize(&rc, pTest);
        -:12871:  }
    #####:12872:  return rc;
        -:12873:}
        -:12874:
        -:12875:/*
        -:12876:** Format a WHERE clause that can be used against the "sqlar" table to
        -:12877:** identify all archive members that match the command arguments held
        -:12878:** in (*pAr). Leave this WHERE clause in (*pzWhere) before returning.
        -:12879:** The caller is responsible for eventually calling sqlite3_free() on
        -:12880:** any non-NULL (*pzWhere) value.
        -:12881:*/
    #####:12882:static void arWhereClause(
        -:12883:  int *pRc, 
        -:12884:  ArCommand *pAr, 
        -:12885:  char **pzWhere                  /* OUT: New WHERE clause */
        -:12886:){
    #####:12887:  char *zWhere = 0;
    #####:12888:  if( *pRc==SQLITE_OK ){
    #####:12889:    if( pAr->nArg==0 ){
    #####:12890:      zWhere = sqlite3_mprintf("1");
        -:12891:    }else{
        -:12892:      int i;
    #####:12893:      const char *zSep = "";
    #####:12894:      for(i=0; i<pAr->nArg; i++){
    #####:12895:        const char *z = pAr->azArg[i];
    #####:12896:        zWhere = sqlite3_mprintf(
        -:12897:          "%z%s name = '%q' OR substr(name,1,%d) = '%q/'", 
    #####:12898:          zWhere, zSep, z, strlen30(z)+1, z
        -:12899:        );
    #####:12900:        if( zWhere==0 ){
    #####:12901:          *pRc = SQLITE_NOMEM;
    #####:12902:          break;
        -:12903:        }
    #####:12904:        zSep = " OR ";
        -:12905:      }
        -:12906:    }
        -:12907:  }
    #####:12908:  *pzWhere = zWhere;
    #####:12909:}
        -:12910:
        -:12911:/*
        -:12912:** Implementation of .ar "lisT" command. 
        -:12913:*/
    #####:12914:static int arListCommand(ArCommand *pAr){
    #####:12915:  const char *zSql = "SELECT %s FROM %s WHERE %s"; 
    #####:12916:  const char *azCols[] = {
        -:12917:    "name",
        -:12918:    "lsmode(mode), sz, datetime(mtime, 'unixepoch'), name"
        -:12919:  };
        -:12920:
    #####:12921:  char *zWhere = 0;
    #####:12922:  sqlite3_stmt *pSql = 0;
        -:12923:  int rc;
        -:12924:
    #####:12925:  rc = arCheckEntries(pAr);
    #####:12926:  arWhereClause(&rc, pAr, &zWhere);
        -:12927:
    #####:12928:  shellPreparePrintf(pAr->db, &rc, &pSql, zSql, azCols[pAr->bVerbose],
        -:12929:                     pAr->zSrcTable, zWhere);
    #####:12930:  if( pAr->bDryRun ){
    #####:12931:    utf8_printf(pAr->p->out, "%s\n", sqlite3_sql(pSql));
        -:12932:  }else{
    #####:12933:    while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pSql) ){
    #####:12934:      if( pAr->bVerbose ){
    #####:12935:        utf8_printf(pAr->p->out, "%s % 10d  %s  %s\n",
        -:12936:            sqlite3_column_text(pSql, 0),
        -:12937:            sqlite3_column_int(pSql, 1), 
        -:12938:            sqlite3_column_text(pSql, 2),
        -:12939:            sqlite3_column_text(pSql, 3)
        -:12940:        );
        -:12941:      }else{
    #####:12942:        utf8_printf(pAr->p->out, "%s\n", sqlite3_column_text(pSql, 0));
        -:12943:      }
        -:12944:    }
        -:12945:  }
    #####:12946:  shellFinalize(&rc, pSql);
    #####:12947:  sqlite3_free(zWhere);
    #####:12948:  return rc;
        -:12949:}
        -:12950:
        -:12951:
        -:12952:/*
        -:12953:** Implementation of .ar "eXtract" command. 
        -:12954:*/
    #####:12955:static int arExtractCommand(ArCommand *pAr){
    #####:12956:  const char *zSql1 = 
        -:12957:    "SELECT "
        -:12958:    " ($dir || name),"
        -:12959:    " writefile(($dir || name), %s, mode, mtime) "
        -:12960:    "FROM %s WHERE (%s) AND (data IS NULL OR $dirOnly = 0)"
        -:12961:    " AND name NOT GLOB '*..[/\\]*'";
        -:12962:
    #####:12963:  const char *azExtraArg[] = { 
        -:12964:    "sqlar_uncompress(data, sz)",
        -:12965:    "data"
        -:12966:  };
        -:12967:
    #####:12968:  sqlite3_stmt *pSql = 0;
    #####:12969:  int rc = SQLITE_OK;
    #####:12970:  char *zDir = 0;
    #####:12971:  char *zWhere = 0;
        -:12972:  int i, j;
        -:12973:
        -:12974:  /* If arguments are specified, check that they actually exist within
        -:12975:  ** the archive before proceeding. And formulate a WHERE clause to
        -:12976:  ** match them.  */
    #####:12977:  rc = arCheckEntries(pAr);
    #####:12978:  arWhereClause(&rc, pAr, &zWhere);
        -:12979:
    #####:12980:  if( rc==SQLITE_OK ){
    #####:12981:    if( pAr->zDir ){
    #####:12982:      zDir = sqlite3_mprintf("%s/", pAr->zDir);
        -:12983:    }else{
    #####:12984:      zDir = sqlite3_mprintf("");
        -:12985:    }
    #####:12986:    if( zDir==0 ) rc = SQLITE_NOMEM;
        -:12987:  }
        -:12988:
    #####:12989:  shellPreparePrintf(pAr->db, &rc, &pSql, zSql1, 
    #####:12990:      azExtraArg[pAr->bZip], pAr->zSrcTable, zWhere
        -:12991:  );
        -:12992:
    #####:12993:  if( rc==SQLITE_OK ){
    #####:12994:    j = sqlite3_bind_parameter_index(pSql, "$dir");
    #####:12995:    sqlite3_bind_text(pSql, j, zDir, -1, SQLITE_STATIC);
        -:12996:
        -:12997:    /* Run the SELECT statement twice. The first time, writefile() is called
        -:12998:    ** for all archive members that should be extracted. The second time,
        -:12999:    ** only for the directories. This is because the timestamps for
        -:13000:    ** extracted directories must be reset after they are populated (as
        -:13001:    ** populating them changes the timestamp).  */
    #####:13002:    for(i=0; i<2; i++){
    #####:13003:      j = sqlite3_bind_parameter_index(pSql, "$dirOnly");
    #####:13004:      sqlite3_bind_int(pSql, j, i);
    #####:13005:      if( pAr->bDryRun ){
    #####:13006:        utf8_printf(pAr->p->out, "%s\n", sqlite3_sql(pSql));
        -:13007:      }else{
    #####:13008:        while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pSql) ){
    #####:13009:          if( i==0 && pAr->bVerbose ){
    #####:13010:            utf8_printf(pAr->p->out, "%s\n", sqlite3_column_text(pSql, 0));
        -:13011:          }
        -:13012:        }
        -:13013:      }
    #####:13014:      shellReset(&rc, pSql);
        -:13015:    }
    #####:13016:    shellFinalize(&rc, pSql);
        -:13017:  }
        -:13018:
    #####:13019:  sqlite3_free(zDir);
    #####:13020:  sqlite3_free(zWhere);
    #####:13021:  return rc;
        -:13022:}
        -:13023:
        -:13024:/*
        -:13025:** Run the SQL statement in zSql.  Or if doing a --dryrun, merely print it out.
        -:13026:*/
    #####:13027:static int arExecSql(ArCommand *pAr, const char *zSql){
        -:13028:  int rc;
    #####:13029:  if( pAr->bDryRun ){
    #####:13030:    utf8_printf(pAr->p->out, "%s\n", zSql);
    #####:13031:    rc = SQLITE_OK;
        -:13032:  }else{
    #####:13033:    char *zErr = 0;
    #####:13034:    rc = sqlite3_exec(pAr->db, zSql, 0, 0, &zErr);
    #####:13035:    if( zErr ){
    #####:13036:      utf8_printf(stdout, "ERROR: %s\n", zErr);
    #####:13037:      sqlite3_free(zErr);
        -:13038:    }
        -:13039:  }
    #####:13040:  return rc;
        -:13041:}
        -:13042:
        -:13043:
        -:13044:/*
        -:13045:** Implementation of .ar "create" and "update" commands.
        -:13046:**
        -:13047:** Create the "sqlar" table in the database if it does not already exist.
        -:13048:** Then add each file in the azFile[] array to the archive. Directories
        -:13049:** are added recursively. If argument bVerbose is non-zero, a message is
        -:13050:** printed on stdout for each file archived.
        -:13051:**
        -:13052:** The create command is the same as update, except that it drops
        -:13053:** any existing "sqlar" table before beginning.
        -:13054:*/
    #####:13055:static int arCreateOrUpdateCommand(
        -:13056:  ArCommand *pAr,                 /* Command arguments and options */
        -:13057:  int bUpdate                     /* true for a --create.  false for --update */
        -:13058:){
    #####:13059:  const char *zCreate = 
        -:13060:      "CREATE TABLE IF NOT EXISTS sqlar(\n"
        -:13061:      "  name TEXT PRIMARY KEY,  -- name of the file\n"
        -:13062:      "  mode INT,               -- access permissions\n"
        -:13063:      "  mtime INT,              -- last modification time\n"
        -:13064:      "  sz INT,                 -- original file size\n"
        -:13065:      "  data BLOB               -- compressed content\n"
        -:13066:      ")";
    #####:13067:  const char *zDrop = "DROP TABLE IF EXISTS sqlar";
    #####:13068:  const char *zInsertFmt[2] = {
        -:13069:     "REPLACE INTO %s(name,mode,mtime,sz,data)\n"
        -:13070:     "  SELECT\n"
        -:13071:     "    %s,\n"
        -:13072:     "    mode,\n"
        -:13073:     "    mtime,\n"
        -:13074:     "    CASE substr(lsmode(mode),1,1)\n"
        -:13075:     "      WHEN '-' THEN length(data)\n"
        -:13076:     "      WHEN 'd' THEN 0\n"
        -:13077:     "      ELSE -1 END,\n"
        -:13078:     "    sqlar_compress(data)\n"
        -:13079:     "  FROM fsdir(%Q,%Q)\n"
        -:13080:     "  WHERE lsmode(mode) NOT LIKE '?%%';",
        -:13081:     "REPLACE INTO %s(name,mode,mtime,data)\n"
        -:13082:     "  SELECT\n"
        -:13083:     "    %s,\n"
        -:13084:     "    mode,\n"
        -:13085:     "    mtime,\n"
        -:13086:     "    data\n"
        -:13087:     "  FROM fsdir(%Q,%Q)\n"
        -:13088:     "  WHERE lsmode(mode) NOT LIKE '?%%';"
        -:13089:  };
        -:13090:  int i;                          /* For iterating through azFile[] */
        -:13091:  int rc;                         /* Return code */
    #####:13092:  const char *zTab = 0;           /* SQL table into which to insert */
        -:13093:  char *zSql;
        -:13094:  char zTemp[50];
        -:13095:
    #####:13096:  arExecSql(pAr, "PRAGMA page_size=512");
    #####:13097:  rc = arExecSql(pAr, "SAVEPOINT ar;");
    #####:13098:  if( rc!=SQLITE_OK ) return rc;
    #####:13099:  zTemp[0] = 0; 
    #####:13100:  if( pAr->bZip ){
        -:13101:    /* Initialize the zipfile virtual table, if necessary */
    #####:13102:    if( pAr->zFile ){
        -:13103:      sqlite3_uint64 r;
    #####:13104:      sqlite3_randomness(sizeof(r),&r);
    #####:13105:      sqlite3_snprintf(sizeof(zTemp),zTemp,"zip%016llx",r);
    #####:13106:      zTab = zTemp;
    #####:13107:      zSql = sqlite3_mprintf(
        -:13108:         "CREATE VIRTUAL TABLE temp.%s USING zipfile(%Q)",
        -:13109:         zTab, pAr->zFile
        -:13110:      );
    #####:13111:      rc = arExecSql(pAr, zSql);
    #####:13112:      sqlite3_free(zSql);
        -:13113:    }else{
    #####:13114:      zTab = "zip";
        -:13115:    }
        -:13116:  }else{
        -:13117:    /* Initialize the table for an SQLAR */
    #####:13118:    zTab = "sqlar";
    #####:13119:    if( bUpdate==0 ){
    #####:13120:      rc = arExecSql(pAr, zDrop);
    #####:13121:      if( rc!=SQLITE_OK ) goto end_ar_transaction;
        -:13122:    }
    #####:13123:    rc = arExecSql(pAr, zCreate);
        -:13124:  }
    #####:13125:  for(i=0; i<pAr->nArg && rc==SQLITE_OK; i++){
    #####:13126:    char *zSql2 = sqlite3_mprintf(zInsertFmt[pAr->bZip], zTab,
    #####:13127:        pAr->bVerbose ? "shell_putsnl(name)" : "name",
    #####:13128:        pAr->azArg[i], pAr->zDir);
    #####:13129:    rc = arExecSql(pAr, zSql2);
    #####:13130:    sqlite3_free(zSql2);
        -:13131:  }
    #####:13132:end_ar_transaction:
    #####:13133:  if( rc!=SQLITE_OK ){
    #####:13134:    arExecSql(pAr, "ROLLBACK TO ar; RELEASE ar;");
        -:13135:  }else{
    #####:13136:    rc = arExecSql(pAr, "RELEASE ar;");
    #####:13137:    if( pAr->bZip && pAr->zFile ){
    #####:13138:      zSql = sqlite3_mprintf("DROP TABLE %s", zTemp);
    #####:13139:      arExecSql(pAr, zSql);
    #####:13140:      sqlite3_free(zSql);
        -:13141:    }
        -:13142:  }
    #####:13143:  return rc;
        -:13144:}
        -:13145:
        -:13146:/*
        -:13147:** Implementation of ".ar" dot command.
        -:13148:*/
    #####:13149:static int arDotCommand(
        -:13150:  ShellState *pState,             /* Current shell tool state */
        -:13151:  int fromCmdLine,                /* True if -A command-line option, not .ar cmd */
        -:13152:  char **azArg,                   /* Array of arguments passed to dot command */
        -:13153:  int nArg                        /* Number of entries in azArg[] */
        -:13154:){
        -:13155:  ArCommand cmd;
        -:13156:  int rc;
    #####:13157:  memset(&cmd, 0, sizeof(cmd));
    #####:13158:  cmd.fromCmdLine = fromCmdLine;
    #####:13159:  rc = arParseCommand(azArg, nArg, &cmd);
    #####:13160:  if( rc==SQLITE_OK ){
    #####:13161:    int eDbType = SHELL_OPEN_UNSPEC;
    #####:13162:    cmd.p = pState;
    #####:13163:    cmd.db = pState->db;
    #####:13164:    if( cmd.zFile ){
    #####:13165:      eDbType = deduceDatabaseType(cmd.zFile, 1);
        -:13166:    }else{
    #####:13167:      eDbType = pState->openMode;
        -:13168:    }
    #####:13169:    if( eDbType==SHELL_OPEN_ZIPFILE ){
    #####:13170:      if( cmd.eCmd==AR_CMD_EXTRACT || cmd.eCmd==AR_CMD_LIST ){
    #####:13171:        if( cmd.zFile==0 ){
    #####:13172:          cmd.zSrcTable = sqlite3_mprintf("zip");
        -:13173:        }else{
    #####:13174:          cmd.zSrcTable = sqlite3_mprintf("zipfile(%Q)", cmd.zFile);
        -:13175:        }
        -:13176:      }
    #####:13177:      cmd.bZip = 1;
    #####:13178:    }else if( cmd.zFile ){
        -:13179:      int flags;
    #####:13180:      if( cmd.bAppend ) eDbType = SHELL_OPEN_APPENDVFS;
    #####:13181:      if( cmd.eCmd==AR_CMD_CREATE || cmd.eCmd==AR_CMD_UPDATE ){
    #####:13182:        flags = SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE;
        -:13183:      }else{
    #####:13184:        flags = SQLITE_OPEN_READONLY;
        -:13185:      }
    #####:13186:      cmd.db = 0;
    #####:13187:      if( cmd.bDryRun ){
    #####:13188:        utf8_printf(pState->out, "-- open database '%s'%s\n", cmd.zFile,
        -:13189:             eDbType==SHELL_OPEN_APPENDVFS ? " using 'apndvfs'" : "");
        -:13190:      }
    #####:13191:      rc = sqlite3_open_v2(cmd.zFile, &cmd.db, flags, 
        -:13192:             eDbType==SHELL_OPEN_APPENDVFS ? "apndvfs" : 0);
    #####:13193:      if( rc!=SQLITE_OK ){
    #####:13194:        utf8_printf(stderr, "cannot open file: %s (%s)\n", 
        -:13195:            cmd.zFile, sqlite3_errmsg(cmd.db)
        -:13196:        );
    #####:13197:        goto end_ar_command;
        -:13198:      }
    #####:13199:      sqlite3_fileio_init(cmd.db, 0, 0);
    #####:13200:      sqlite3_sqlar_init(cmd.db, 0, 0);
    #####:13201:      sqlite3_create_function(cmd.db, "shell_putsnl", 1, SQLITE_UTF8, cmd.p,
        -:13202:                              shellPutsFunc, 0, 0);
        -:13203:
        -:13204:    }
    #####:13205:    if( cmd.zSrcTable==0 && cmd.bZip==0 && cmd.eCmd!=AR_CMD_HELP ){
    #####:13206:      if( cmd.eCmd!=AR_CMD_CREATE
    #####:13207:       && sqlite3_table_column_metadata(cmd.db,0,"sqlar","name",0,0,0,0,0)
        -:13208:      ){
    #####:13209:        utf8_printf(stderr, "database does not contain an 'sqlar' table\n");
    #####:13210:        rc = SQLITE_ERROR;
    #####:13211:        goto end_ar_command;
        -:13212:      }
    #####:13213:      cmd.zSrcTable = sqlite3_mprintf("sqlar");
        -:13214:    }
        -:13215:
    #####:13216:    switch( cmd.eCmd ){
    #####:13217:      case AR_CMD_CREATE:
    #####:13218:        rc = arCreateOrUpdateCommand(&cmd, 0);
    #####:13219:        break;
        -:13220:
    #####:13221:      case AR_CMD_EXTRACT:
    #####:13222:        rc = arExtractCommand(&cmd);
    #####:13223:        break;
        -:13224:
    #####:13225:      case AR_CMD_LIST:
    #####:13226:        rc = arListCommand(&cmd);
    #####:13227:        break;
        -:13228:
    #####:13229:      case AR_CMD_HELP:
    #####:13230:        arUsage(pState->out);
    #####:13231:        break;
        -:13232:
    #####:13233:      default:
        -:13234:        assert( cmd.eCmd==AR_CMD_UPDATE );
    #####:13235:        rc = arCreateOrUpdateCommand(&cmd, 1);
    #####:13236:        break;
        -:13237:    }
        -:13238:  }
    #####:13239:end_ar_command:
    #####:13240:  if( cmd.db!=pState->db ){
    #####:13241:    close_db(cmd.db);
        -:13242:  }
    #####:13243:  sqlite3_free(cmd.zSrcTable);
        -:13244:
    #####:13245:  return rc;
        -:13246:}
        -:13247:/* End of the ".archive" or ".ar" command logic
        -:13248:**********************************************************************************/
        -:13249:#endif /* !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_HAVE_ZLIB) */
        -:13250:
        -:13251:
        -:13252:/*
        -:13253:** If an input line begins with "." then invoke this routine to
        -:13254:** process that line.
        -:13255:**
        -:13256:** Return 1 on error, 2 to exit, and 0 otherwise.
        -:13257:*/
        2:13258:static int do_meta_command(char *zLine, ShellState *p){
        2:13259:  int h = 1;
        2:13260:  int nArg = 0;
        -:13261:  int n, c;
        2:13262:  int rc = 0;
        -:13263:  char *azArg[50];
        -:13264:
        -:13265:#ifndef SQLITE_OMIT_VIRTUALTABLE
        2:13266:  if( p->expert.pExpert ){
    #####:13267:    expertFinish(p, 1, 0);
        -:13268:  }
        -:13269:#endif
        -:13270:
        -:13271:  /* Parse the input line into tokens.
        -:13272:  */
        4:13273:  while( zLine[h] && nArg<ArraySize(azArg) ){
       2*:13274:    while( IsSpace(zLine[h]) ){ h++; }
       2*:13275:    if( zLine[h]==0 ) break;
       2*:13276:    if( zLine[h]=='\'' || zLine[h]=='"' ){
    #####:13277:      int delim = zLine[h++];
    #####:13278:      azArg[nArg++] = &zLine[h];
    #####:13279:      while( zLine[h] && zLine[h]!=delim ){
    #####:13280:        if( zLine[h]=='\\' && delim=='"' && zLine[h+1]!=0 ) h++;
    #####:13281:        h++;
        -:13282:      }
    #####:13283:      if( zLine[h]==delim ){
    #####:13284:        zLine[h++] = 0;
        -:13285:      }
    #####:13286:      if( delim=='"' ) resolve_backslashes(azArg[nArg-1]);
        -:13287:    }else{
        2:13288:      azArg[nArg++] = &zLine[h];
       10:13289:      while( zLine[h] && !IsSpace(zLine[h]) ){ h++; }
       2*:13290:      if( zLine[h] ) zLine[h++] = 0;
        2:13291:      resolve_backslashes(azArg[nArg-1]);
        -:13292:    }
        -:13293:  }
        -:13294:
        -:13295:  /* Process the input line.
        -:13296:  */
       2*:13297:  if( nArg==0 ) return 0; /* no tokens, no error */
        2:13298:  n = strlen30(azArg[0]);
        2:13299:  c = azArg[0][0];
        2:13300:  clearTempFile(p);
        -:13301:
        -:13302:#ifndef SQLITE_OMIT_AUTHORIZATION
       2*:13303:  if( c=='a' && strncmp(azArg[0], "auth", n)==0 ){
    #####:13304:    if( nArg!=2 ){
    #####:13305:      raw_printf(stderr, "Usage: .auth ON|OFF\n");
    #####:13306:      rc = 1;
    #####:13307:      goto meta_command_exit;
        -:13308:    }
    #####:13309:    open_db(p, 0);
    #####:13310:    if( booleanValue(azArg[1]) ){
    #####:13311:      sqlite3_set_authorizer(p->db, shellAuth, p);
        -:13312:    }else{
    #####:13313:      sqlite3_set_authorizer(p->db, 0, 0);
        -:13314:    }
        -:13315:  }else
        -:13316:#endif
        -:13317:
        -:13318:#if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_HAVE_ZLIB)
       2*:13319:  if( c=='a' && strncmp(azArg[0], "archive", n)==0 ){
    #####:13320:    open_db(p, 0);
    #####:13321:    rc = arDotCommand(p, 0, azArg, nArg);
        -:13322:  }else
        -:13323:#endif
        -:13324:
       2*:13325:  if( (c=='b' && n>=3 && strncmp(azArg[0], "backup", n)==0)
       2*:13326:   || (c=='s' && n>=3 && strncmp(azArg[0], "save", n)==0)
    #####:13327:  ){
    #####:13328:    const char *zDestFile = 0;
    #####:13329:    const char *zDb = 0;
        -:13330:    sqlite3 *pDest;
        -:13331:    sqlite3_backup *pBackup;
        -:13332:    int j;
    #####:13333:    const char *zVfs = 0;
    #####:13334:    for(j=1; j<nArg; j++){
    #####:13335:      const char *z = azArg[j];
    #####:13336:      if( z[0]=='-' ){
    #####:13337:        if( z[1]=='-' ) z++;
    #####:13338:        if( strcmp(z, "-append")==0 ){
    #####:13339:          zVfs = "apndvfs";
        -:13340:        }else
        -:13341:        {
    #####:13342:          utf8_printf(stderr, "unknown option: %s\n", azArg[j]);
    #####:13343:          return 1;
        -:13344:        }
    #####:13345:      }else if( zDestFile==0 ){
    #####:13346:        zDestFile = azArg[j];
    #####:13347:      }else if( zDb==0 ){
    #####:13348:        zDb = zDestFile;
    #####:13349:        zDestFile = azArg[j];
        -:13350:      }else{
    #####:13351:        raw_printf(stderr, "Usage: .backup ?DB? ?--append? FILENAME\n");
    #####:13352:        return 1;
        -:13353:      }
        -:13354:    }
    #####:13355:    if( zDestFile==0 ){
    #####:13356:      raw_printf(stderr, "missing FILENAME argument on .backup\n");
    #####:13357:      return 1;
        -:13358:    }
    #####:13359:    if( zDb==0 ) zDb = "main";
    #####:13360:    rc = sqlite3_open_v2(zDestFile, &pDest, 
        -:13361:                  SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE, zVfs);
    #####:13362:    if( rc!=SQLITE_OK ){
    #####:13363:      utf8_printf(stderr, "Error: cannot open \"%s\"\n", zDestFile);
    #####:13364:      close_db(pDest);
    #####:13365:      return 1;
        -:13366:    }
    #####:13367:    open_db(p, 0);
    #####:13368:    pBackup = sqlite3_backup_init(pDest, "main", p->db, zDb);
    #####:13369:    if( pBackup==0 ){
    #####:13370:      utf8_printf(stderr, "Error: %s\n", sqlite3_errmsg(pDest));
    #####:13371:      close_db(pDest);
    #####:13372:      return 1;
        -:13373:    }
    #####:13374:    while(  (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK ){}
    #####:13375:    sqlite3_backup_finish(pBackup);
    #####:13376:    if( rc==SQLITE_DONE ){
    #####:13377:      rc = 0;
        -:13378:    }else{
    #####:13379:      utf8_printf(stderr, "Error: %s\n", sqlite3_errmsg(pDest));
    #####:13380:      rc = 1;
        -:13381:    }
    #####:13382:    close_db(pDest);
        -:13383:  }else
        -:13384:
       2*:13385:  if( c=='b' && n>=3 && strncmp(azArg[0], "bail", n)==0 ){
    #####:13386:    if( nArg==2 ){
    #####:13387:      bail_on_error = booleanValue(azArg[1]);
        -:13388:    }else{
    #####:13389:      raw_printf(stderr, "Usage: .bail on|off\n");
    #####:13390:      rc = 1;
        -:13391:    }
        -:13392:  }else
        -:13393:
       2*:13394:  if( c=='b' && n>=3 && strncmp(azArg[0], "binary", n)==0 ){
    #####:13395:    if( nArg==2 ){
    #####:13396:      if( booleanValue(azArg[1]) ){
        -:13397:        setBinaryMode(p->out, 1);
        -:13398:      }else{
        -:13399:        setTextMode(p->out, 1);
        -:13400:      }
        -:13401:    }else{
    #####:13402:      raw_printf(stderr, "Usage: .binary on|off\n");
    #####:13403:      rc = 1;
        -:13404:    }
        -:13405:  }else
        -:13406:
       2*:13407:  if( c=='c' && strcmp(azArg[0],"cd")==0 ){
    #####:13408:    if( nArg==2 ){
        -:13409:#if defined(_WIN32) || defined(WIN32)
        -:13410:      wchar_t *z = sqlite3_win32_utf8_to_unicode(azArg[1]);
        -:13411:      rc = !SetCurrentDirectoryW(z);
        -:13412:      sqlite3_free(z);
        -:13413:#else
    #####:13414:      rc = chdir(azArg[1]);
        -:13415:#endif
    #####:13416:      if( rc ){
    #####:13417:        utf8_printf(stderr, "Cannot change to directory \"%s\"\n", azArg[1]);
    #####:13418:        rc = 1;
        -:13419:      }
        -:13420:    }else{
    #####:13421:      raw_printf(stderr, "Usage: .cd DIRECTORY\n");
    #####:13422:      rc = 1;
        -:13423:    }
        -:13424:  }else
        -:13425:
        -:13426:  /* The undocumented ".breakpoint" command causes a call to the no-op
        -:13427:  ** routine named test_breakpoint().
        -:13428:  */
       2*:13429:  if( c=='b' && n>=3 && strncmp(azArg[0], "breakpoint", n)==0 ){
    #####:13430:    test_breakpoint();
        -:13431:  }else
        -:13432:
       2*:13433:  if( c=='c' && n>=3 && strncmp(azArg[0], "changes", n)==0 ){
    #####:13434:    if( nArg==2 ){
    #####:13435:      setOrClearFlag(p, SHFLG_CountChanges, azArg[1]);
        -:13436:    }else{
    #####:13437:      raw_printf(stderr, "Usage: .changes on|off\n");
    #####:13438:      rc = 1;
        -:13439:    }
        -:13440:  }else
        -:13441:
        -:13442:  /* Cancel output redirection, if it is currently set (by .testcase)
        -:13443:  ** Then read the content of the testcase-out.txt file and compare against
        -:13444:  ** azArg[1].  If there are differences, report an error and exit.
        -:13445:  */
       2*:13446:  if( c=='c' && n>=3 && strncmp(azArg[0], "check", n)==0 ){
    #####:13447:    char *zRes = 0;
    #####:13448:    output_reset(p);
    #####:13449:    if( nArg!=2 ){
    #####:13450:      raw_printf(stderr, "Usage: .check GLOB-PATTERN\n");
    #####:13451:      rc = 2;
    #####:13452:    }else if( (zRes = readFile("testcase-out.txt", 0))==0 ){
    #####:13453:      raw_printf(stderr, "Error: cannot read 'testcase-out.txt'\n");
    #####:13454:      rc = 2;
    #####:13455:    }else if( testcase_glob(azArg[1],zRes)==0 ){
    #####:13456:      utf8_printf(stderr,
        -:13457:                 "testcase-%s FAILED\n Expected: [%s]\n      Got: [%s]\n",
    #####:13458:                 p->zTestcase, azArg[1], zRes);
    #####:13459:      rc = 1;
        -:13460:    }else{
    #####:13461:      utf8_printf(stdout, "testcase-%s ok\n", p->zTestcase);
    #####:13462:      p->nCheck++;
        -:13463:    }
    #####:13464:    sqlite3_free(zRes);
        -:13465:  }else
        -:13466:
       2*:13467:  if( c=='c' && strncmp(azArg[0], "clone", n)==0 ){
    #####:13468:    if( nArg==2 ){
    #####:13469:      tryToClone(p, azArg[1]);
        -:13470:    }else{
    #####:13471:      raw_printf(stderr, "Usage: .clone FILENAME\n");
    #####:13472:      rc = 1;
        -:13473:    }
        -:13474:  }else
        -:13475:
       2*:13476:  if( c=='d' && n>1 && strncmp(azArg[0], "databases", n)==0 ){
        -:13477:    ShellState data;
    #####:13478:    char *zErrMsg = 0;
    #####:13479:    open_db(p, 0);
    #####:13480:    memcpy(&data, p, sizeof(data));
    #####:13481:    data.showHeader = 0;
    #####:13482:    data.cMode = data.mode = MODE_List;
    #####:13483:    sqlite3_snprintf(sizeof(data.colSeparator),data.colSeparator,": ");
    #####:13484:    data.cnt = 0;
    #####:13485:    sqlite3_exec(p->db, "SELECT name, file FROM pragma_database_list",
        -:13486:                 callback, &data, &zErrMsg);
    #####:13487:    if( zErrMsg ){
    #####:13488:      utf8_printf(stderr,"Error: %s\n", zErrMsg);
    #####:13489:      sqlite3_free(zErrMsg);
    #####:13490:      rc = 1;
        -:13491:    }
        -:13492:  }else
        -:13493:
       2*:13494:  if( c=='d' && n>=3 && strncmp(azArg[0], "dbconfig", n)==0 ){
        -:13495:    static const struct DbConfigChoices {
        -:13496:      const char *zName;
        -:13497:      int op;
        -:13498:    } aDbConfig[] = {
        -:13499:        { "enable_fkey",      SQLITE_DBCONFIG_ENABLE_FKEY            },
        -:13500:        { "enable_trigger",   SQLITE_DBCONFIG_ENABLE_TRIGGER         },
        -:13501:        { "fts3_tokenizer",   SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER  },
        -:13502:        { "load_extension",   SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION  },
        -:13503:        { "no_ckpt_on_close", SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE       },
        -:13504:        { "enable_qpsg",      SQLITE_DBCONFIG_ENABLE_QPSG            },
        -:13505:        { "trigger_eqp",      SQLITE_DBCONFIG_TRIGGER_EQP            },
        -:13506:        { "reset_database",   SQLITE_DBCONFIG_RESET_DATABASE         },
        -:13507:        { "defensive",        SQLITE_DBCONFIG_DEFENSIVE              },
        -:13508:    };
        -:13509:    int ii, v;
    #####:13510:    open_db(p, 0);
    #####:13511:    for(ii=0; ii<ArraySize(aDbConfig); ii++){
    #####:13512:      if( nArg>1 && strcmp(azArg[1], aDbConfig[ii].zName)!=0 ) continue;
    #####:13513:      if( nArg>=3 ){
    #####:13514:        sqlite3_db_config(p->db, aDbConfig[ii].op, booleanValue(azArg[2]), 0);
        -:13515:      }
    #####:13516:      sqlite3_db_config(p->db, aDbConfig[ii].op, -1, &v);
    #####:13517:      utf8_printf(p->out, "%18s %s\n", aDbConfig[ii].zName, v ? "on" : "off");
    #####:13518:      if( nArg>1 ) break;
        -:13519:    }
    #####:13520:    if( nArg>1 && ii==ArraySize(aDbConfig) ){
    #####:13521:      utf8_printf(stderr, "Error: unknown dbconfig \"%s\"\n", azArg[1]);
    #####:13522:      utf8_printf(stderr, "Enter \".dbconfig\" with no arguments for a list\n");
        -:13523:    }   
        -:13524:  }else
        -:13525:
       2*:13526:  if( c=='d' && n>=3 && strncmp(azArg[0], "dbinfo", n)==0 ){
    #####:13527:    rc = shell_dbinfo_command(p, nArg, azArg);
        -:13528:  }else
        -:13529:
       2*:13530:  if( c=='d' && strncmp(azArg[0], "dump", n)==0 ){
    #####:13531:    const char *zLike = 0;
        -:13532:    int i;
    #####:13533:    int savedShowHeader = p->showHeader;
    #####:13534:    int savedShellFlags = p->shellFlgs;
    #####:13535:    ShellClearFlag(p, SHFLG_PreserveRowid|SHFLG_Newlines|SHFLG_Echo);
    #####:13536:    for(i=1; i<nArg; i++){
    #####:13537:      if( azArg[i][0]=='-' ){
    #####:13538:        const char *z = azArg[i]+1;
    #####:13539:        if( z[0]=='-' ) z++;
    #####:13540:        if( strcmp(z,"preserve-rowids")==0 ){
        -:13541:#ifdef SQLITE_OMIT_VIRTUALTABLE
        -:13542:          raw_printf(stderr, "The --preserve-rowids option is not compatible"
        -:13543:                             " with SQLITE_OMIT_VIRTUALTABLE\n");
        -:13544:          rc = 1;
        -:13545:          goto meta_command_exit;
        -:13546:#else
    #####:13547:          ShellSetFlag(p, SHFLG_PreserveRowid);
        -:13548:#endif
        -:13549:        }else
    #####:13550:        if( strcmp(z,"newlines")==0 ){
    #####:13551:          ShellSetFlag(p, SHFLG_Newlines);
        -:13552:        }else
        -:13553:        {
    #####:13554:          raw_printf(stderr, "Unknown option \"%s\" on \".dump\"\n", azArg[i]);
    #####:13555:          rc = 1;
    #####:13556:          goto meta_command_exit;
        -:13557:        }
    #####:13558:      }else if( zLike ){
    #####:13559:        raw_printf(stderr, "Usage: .dump ?--preserve-rowids? "
        -:13560:                           "?--newlines? ?LIKE-PATTERN?\n");
    #####:13561:        rc = 1;
    #####:13562:        goto meta_command_exit;
        -:13563:      }else{
    #####:13564:        zLike = azArg[i];
        -:13565:      }
        -:13566:    }
    #####:13567:    open_db(p, 0);
        -:13568:    /* When playing back a "dump", the content might appear in an order
        -:13569:    ** which causes immediate foreign key constraints to be violated.
        -:13570:    ** So disable foreign-key constraint enforcement to prevent problems. */
    #####:13571:    raw_printf(p->out, "PRAGMA foreign_keys=OFF;\n");
    #####:13572:    raw_printf(p->out, "BEGIN TRANSACTION;\n");
    #####:13573:    p->writableSchema = 0;
    #####:13574:    p->showHeader = 0;
        -:13575:    /* Set writable_schema=ON since doing so forces SQLite to initialize
        -:13576:    ** as much of the schema as it can even if the sqlite_master table is
        -:13577:    ** corrupt. */
    #####:13578:    sqlite3_exec(p->db, "SAVEPOINT dump; PRAGMA writable_schema=ON", 0, 0, 0);
    #####:13579:    p->nErr = 0;
    #####:13580:    if( zLike==0 ){
    #####:13581:      run_schema_dump_query(p,
        -:13582:        "SELECT name, type, sql FROM sqlite_master "
        -:13583:        "WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence'"
        -:13584:      );
    #####:13585:      run_schema_dump_query(p,
        -:13586:        "SELECT name, type, sql FROM sqlite_master "
        -:13587:        "WHERE name=='sqlite_sequence'"
        -:13588:      );
    #####:13589:      run_table_dump_query(p,
        -:13590:        "SELECT sql FROM sqlite_master "
        -:13591:        "WHERE sql NOT NULL AND type IN ('index','trigger','view')", 0
        -:13592:      );
        -:13593:    }else{
        -:13594:      char *zSql;
    #####:13595:      zSql = sqlite3_mprintf(
        -:13596:        "SELECT name, type, sql FROM sqlite_master "
        -:13597:        "WHERE tbl_name LIKE %Q AND type=='table'"
        -:13598:        "  AND sql NOT NULL", zLike);
    #####:13599:      run_schema_dump_query(p,zSql);
    #####:13600:      sqlite3_free(zSql);
    #####:13601:      zSql = sqlite3_mprintf(
        -:13602:        "SELECT sql FROM sqlite_master "
        -:13603:        "WHERE sql NOT NULL"
        -:13604:        "  AND type IN ('index','trigger','view')"
        -:13605:        "  AND tbl_name LIKE %Q", zLike);
    #####:13606:      run_table_dump_query(p, zSql, 0);
    #####:13607:      sqlite3_free(zSql);
        -:13608:    }
    #####:13609:    if( p->writableSchema ){
    #####:13610:      raw_printf(p->out, "PRAGMA writable_schema=OFF;\n");
    #####:13611:      p->writableSchema = 0;
        -:13612:    }
    #####:13613:    sqlite3_exec(p->db, "PRAGMA writable_schema=OFF;", 0, 0, 0);
    #####:13614:    sqlite3_exec(p->db, "RELEASE dump;", 0, 0, 0);
    #####:13615:    raw_printf(p->out, p->nErr ? "ROLLBACK; -- due to errors\n" : "COMMIT;\n");
    #####:13616:    p->showHeader = savedShowHeader;
    #####:13617:    p->shellFlgs = savedShellFlags;
        -:13618:  }else
        -:13619:
       2*:13620:  if( c=='e' && strncmp(azArg[0], "echo", n)==0 ){
    #####:13621:    if( nArg==2 ){
    #####:13622:      setOrClearFlag(p, SHFLG_Echo, azArg[1]);
        -:13623:    }else{
    #####:13624:      raw_printf(stderr, "Usage: .echo on|off\n");
    #####:13625:      rc = 1;
        -:13626:    }
        -:13627:  }else
        -:13628:
       2*:13629:  if( c=='e' && strncmp(azArg[0], "eqp", n)==0 ){
    #####:13630:    if( nArg==2 ){
    #####:13631:      p->autoEQPtest = 0;
    #####:13632:      if( strcmp(azArg[1],"full")==0 ){
    #####:13633:        p->autoEQP = AUTOEQP_full;
    #####:13634:      }else if( strcmp(azArg[1],"trigger")==0 ){
    #####:13635:        p->autoEQP = AUTOEQP_trigger;
    #####:13636:      }else if( strcmp(azArg[1],"test")==0 ){
    #####:13637:        p->autoEQP = AUTOEQP_on;
    #####:13638:        p->autoEQPtest = 1;
        -:13639:      }else{
    #####:13640:        p->autoEQP = (u8)booleanValue(azArg[1]);
        -:13641:      }
        -:13642:    }else{
    #####:13643:      raw_printf(stderr, "Usage: .eqp off|on|trigger|full\n");
    #####:13644:      rc = 1;
        -:13645:    }
        -:13646:  }else
        -:13647:
       2*:13648:  if( c=='e' && strncmp(azArg[0], "exit", n)==0 ){
    #####:13649:    if( nArg>1 && (rc = (int)integerValue(azArg[1]))!=0 ) exit(rc);
    #####:13650:    rc = 2;
        -:13651:  }else
        -:13652:
        -:13653:  /* The ".explain" command is automatic now.  It is largely pointless.  It
        -:13654:  ** retained purely for backwards compatibility */
       2*:13655:  if( c=='e' && strncmp(azArg[0], "explain", n)==0 ){
    #####:13656:    int val = 1;
    #####:13657:    if( nArg>=2 ){
    #####:13658:      if( strcmp(azArg[1],"auto")==0 ){
    #####:13659:        val = 99;
        -:13660:      }else{
    #####:13661:        val =  booleanValue(azArg[1]);
        -:13662:      }
        -:13663:    }
    #####:13664:    if( val==1 && p->mode!=MODE_Explain ){
    #####:13665:      p->normalMode = p->mode;
    #####:13666:      p->mode = MODE_Explain;
    #####:13667:      p->autoExplain = 0;
    #####:13668:    }else if( val==0 ){
    #####:13669:      if( p->mode==MODE_Explain ) p->mode = p->normalMode;
    #####:13670:      p->autoExplain = 0;
    #####:13671:    }else if( val==99 ){
    #####:13672:      if( p->mode==MODE_Explain ) p->mode = p->normalMode;
    #####:13673:      p->autoExplain = 1;
        -:13674:    }
        -:13675:  }else
        -:13676:
        -:13677:#ifndef SQLITE_OMIT_VIRTUALTABLE
       2*:13678:  if( c=='e' && strncmp(azArg[0], "expert", n)==0 ){
    #####:13679:    open_db(p, 0);
    #####:13680:    expertDotCommand(p, azArg, nArg);
        -:13681:  }else
        -:13682:#endif
        -:13683:
       2*:13684:  if( c=='f' && strncmp(azArg[0], "fullschema", n)==0 ){
        -:13685:    ShellState data;
    #####:13686:    char *zErrMsg = 0;
    #####:13687:    int doStats = 0;
    #####:13688:    memcpy(&data, p, sizeof(data));
    #####:13689:    data.showHeader = 0;
    #####:13690:    data.cMode = data.mode = MODE_Semi;
    #####:13691:    if( nArg==2 && optionMatch(azArg[1], "indent") ){
    #####:13692:      data.cMode = data.mode = MODE_Pretty;
    #####:13693:      nArg = 1;
        -:13694:    }
    #####:13695:    if( nArg!=1 ){
    #####:13696:      raw_printf(stderr, "Usage: .fullschema ?--indent?\n");
    #####:13697:      rc = 1;
    #####:13698:      goto meta_command_exit;
        -:13699:    }
    #####:13700:    open_db(p, 0);
    #####:13701:    rc = sqlite3_exec(p->db,
        -:13702:       "SELECT sql FROM"
        -:13703:       "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"
        -:13704:       "     FROM sqlite_master UNION ALL"
        -:13705:       "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "
        -:13706:       "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%' "
        -:13707:       "ORDER BY rowid",
        -:13708:       callback, &data, &zErrMsg
        -:13709:    );
    #####:13710:    if( rc==SQLITE_OK ){
        -:13711:      sqlite3_stmt *pStmt;
    #####:13712:      rc = sqlite3_prepare_v2(p->db,
        -:13713:               "SELECT rowid FROM sqlite_master"
        -:13714:               " WHERE name GLOB 'sqlite_stat[134]'",
        -:13715:               -1, &pStmt, 0);
    #####:13716:      doStats = sqlite3_step(pStmt)==SQLITE_ROW;
    #####:13717:      sqlite3_finalize(pStmt);
        -:13718:    }
    #####:13719:    if( doStats==0 ){
    #####:13720:      raw_printf(p->out, "/* No STAT tables available */\n");
        -:13721:    }else{
    #####:13722:      raw_printf(p->out, "ANALYZE sqlite_master;\n");
    #####:13723:      sqlite3_exec(p->db, "SELECT 'ANALYZE sqlite_master'",
        -:13724:                   callback, &data, &zErrMsg);
    #####:13725:      data.cMode = data.mode = MODE_Insert;
    #####:13726:      data.zDestTable = "sqlite_stat1";
    #####:13727:      shell_exec(&data, "SELECT * FROM sqlite_stat1", &zErrMsg);
    #####:13728:      data.zDestTable = "sqlite_stat3";
    #####:13729:      shell_exec(&data, "SELECT * FROM sqlite_stat3", &zErrMsg);
    #####:13730:      data.zDestTable = "sqlite_stat4";
    #####:13731:      shell_exec(&data, "SELECT * FROM sqlite_stat4", &zErrMsg);
    #####:13732:      raw_printf(p->out, "ANALYZE sqlite_master;\n");
        -:13733:    }
        -:13734:  }else
        -:13735:
       2*:13736:  if( c=='h' && strncmp(azArg[0], "headers", n)==0 ){
    #####:13737:    if( nArg==2 ){
    #####:13738:      p->showHeader = booleanValue(azArg[1]);
        -:13739:    }else{
    #####:13740:      raw_printf(stderr, "Usage: .headers on|off\n");
    #####:13741:      rc = 1;
        -:13742:    }
        -:13743:  }else
        -:13744:
       2*:13745:  if( c=='h' && strncmp(azArg[0], "help", n)==0 ){
    #####:13746:    if( nArg>=2 ){
    #####:13747:      n = showHelp(p->out, azArg[1]);
    #####:13748:      if( n==0 ){
    #####:13749:        utf8_printf(p->out, "Nothing matches '%s'\n", azArg[1]);
        -:13750:      }
        -:13751:    }else{
    #####:13752:      showHelp(p->out, 0);
        -:13753:    }
        -:13754:  }else
        -:13755:
       2*:13756:  if( c=='i' && strncmp(azArg[0], "import", n)==0 ){
        -:13757:    char *zTable;               /* Insert data into this table */
        -:13758:    char *zFile;                /* Name of file to extra content from */
    #####:13759:    sqlite3_stmt *pStmt = NULL; /* A statement */
        -:13760:    int nCol;                   /* Number of columns in the table */
        -:13761:    int nByte;                  /* Number of bytes in an SQL string */
        -:13762:    int i, j;                   /* Loop counters */
        -:13763:    int needCommit;             /* True to COMMIT or ROLLBACK at end */
        -:13764:    int nSep;                   /* Number of bytes in p->colSeparator[] */
        -:13765:    char *zSql;                 /* An SQL statement */
        -:13766:    ImportCtx sCtx;             /* Reader context */
        -:13767:    char *(SQLITE_CDECL *xRead)(ImportCtx*); /* Func to read one value */
        -:13768:    int (SQLITE_CDECL *xCloser)(FILE*);      /* Func to close file */
        -:13769:
    #####:13770:    if( nArg!=3 ){
    #####:13771:      raw_printf(stderr, "Usage: .import FILE TABLE\n");
    #####:13772:      goto meta_command_exit;
        -:13773:    }
    #####:13774:    zFile = azArg[1];
    #####:13775:    zTable = azArg[2];
    #####:13776:    seenInterrupt = 0;
    #####:13777:    memset(&sCtx, 0, sizeof(sCtx));
    #####:13778:    open_db(p, 0);
    #####:13779:    nSep = strlen30(p->colSeparator);
    #####:13780:    if( nSep==0 ){
    #####:13781:      raw_printf(stderr,
        -:13782:                 "Error: non-null column separator required for import\n");
    #####:13783:      return 1;
        -:13784:    }
    #####:13785:    if( nSep>1 ){
    #####:13786:      raw_printf(stderr, "Error: multi-character column separators not allowed"
        -:13787:                      " for import\n");
    #####:13788:      return 1;
        -:13789:    }
    #####:13790:    nSep = strlen30(p->rowSeparator);
    #####:13791:    if( nSep==0 ){
    #####:13792:      raw_printf(stderr, "Error: non-null row separator required for import\n");
    #####:13793:      return 1;
        -:13794:    }
    #####:13795:    if( nSep==2 && p->mode==MODE_Csv && strcmp(p->rowSeparator, SEP_CrLf)==0 ){
        -:13796:      /* When importing CSV (only), if the row separator is set to the
        -:13797:      ** default output row separator, change it to the default input
        -:13798:      ** row separator.  This avoids having to maintain different input
        -:13799:      ** and output row separators. */
    #####:13800:      sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator, SEP_Row);
    #####:13801:      nSep = strlen30(p->rowSeparator);
        -:13802:    }
    #####:13803:    if( nSep>1 ){
    #####:13804:      raw_printf(stderr, "Error: multi-character row separators not allowed"
        -:13805:                      " for import\n");
    #####:13806:      return 1;
        -:13807:    }
    #####:13808:    sCtx.zFile = zFile;
    #####:13809:    sCtx.nLine = 1;
    #####:13810:    if( sCtx.zFile[0]=='|' ){
        -:13811:#ifdef SQLITE_OMIT_POPEN
        -:13812:      raw_printf(stderr, "Error: pipes are not supported in this OS\n");
        -:13813:      return 1;
        -:13814:#else
    #####:13815:      sCtx.in = popen(sCtx.zFile+1, "r");
    #####:13816:      sCtx.zFile = "<pipe>";
    #####:13817:      xCloser = pclose;
        -:13818:#endif
        -:13819:    }else{
    #####:13820:      sCtx.in = fopen(sCtx.zFile, "rb");
    #####:13821:      xCloser = fclose;
        -:13822:    }
    #####:13823:    if( p->mode==MODE_Ascii ){
    #####:13824:      xRead = ascii_read_one_field;
        -:13825:    }else{
    #####:13826:      xRead = csv_read_one_field;
        -:13827:    }
    #####:13828:    if( sCtx.in==0 ){
    #####:13829:      utf8_printf(stderr, "Error: cannot open \"%s\"\n", zFile);
    #####:13830:      return 1;
        -:13831:    }
    #####:13832:    sCtx.cColSep = p->colSeparator[0];
    #####:13833:    sCtx.cRowSep = p->rowSeparator[0];
    #####:13834:    zSql = sqlite3_mprintf("SELECT * FROM %s", zTable);
    #####:13835:    if( zSql==0 ){
    #####:13836:      xCloser(sCtx.in);
    #####:13837:      shell_out_of_memory();
        -:13838:    }
    #####:13839:    nByte = strlen30(zSql);
    #####:13840:    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
    #####:13841:    import_append_char(&sCtx, 0);    /* To ensure sCtx.z is allocated */
    #####:13842:    if( rc && sqlite3_strglob("no such table: *", sqlite3_errmsg(p->db))==0 ){
    #####:13843:      char *zCreate = sqlite3_mprintf("CREATE TABLE %s", zTable);
    #####:13844:      char cSep = '(';
    #####:13845:      while( xRead(&sCtx) ){
    #####:13846:        zCreate = sqlite3_mprintf("%z%c\n  \"%w\" TEXT", zCreate, cSep, sCtx.z);
    #####:13847:        cSep = ',';
    #####:13848:        if( sCtx.cTerm!=sCtx.cColSep ) break;
        -:13849:      }
    #####:13850:      if( cSep=='(' ){
    #####:13851:        sqlite3_free(zCreate);
    #####:13852:        sqlite3_free(sCtx.z);
    #####:13853:        xCloser(sCtx.in);
    #####:13854:        utf8_printf(stderr,"%s: empty file\n", sCtx.zFile);
    #####:13855:        return 1;
        -:13856:      }
    #####:13857:      zCreate = sqlite3_mprintf("%z\n)", zCreate);
    #####:13858:      rc = sqlite3_exec(p->db, zCreate, 0, 0, 0);
    #####:13859:      sqlite3_free(zCreate);
    #####:13860:      if( rc ){
    #####:13861:        utf8_printf(stderr, "CREATE TABLE %s(...) failed: %s\n", zTable,
        -:13862:                sqlite3_errmsg(p->db));
    #####:13863:        sqlite3_free(sCtx.z);
    #####:13864:        xCloser(sCtx.in);
    #####:13865:        return 1;
        -:13866:      }
    #####:13867:      rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
        -:13868:    }
    #####:13869:    sqlite3_free(zSql);
    #####:13870:    if( rc ){
    #####:13871:      if (pStmt) sqlite3_finalize(pStmt);
    #####:13872:      utf8_printf(stderr,"Error: %s\n", sqlite3_errmsg(p->db));
    #####:13873:      xCloser(sCtx.in);
    #####:13874:      return 1;
        -:13875:    }
    #####:13876:    nCol = sqlite3_column_count(pStmt);
    #####:13877:    sqlite3_finalize(pStmt);
    #####:13878:    pStmt = 0;
    #####:13879:    if( nCol==0 ) return 0; /* no columns, no error */
    #####:13880:    zSql = sqlite3_malloc64( nByte*2 + 20 + nCol*2 );
    #####:13881:    if( zSql==0 ){
    #####:13882:      xCloser(sCtx.in);
    #####:13883:      shell_out_of_memory();
        -:13884:    }
    #####:13885:    sqlite3_snprintf(nByte+20, zSql, "INSERT INTO \"%w\" VALUES(?", zTable);
    #####:13886:    j = strlen30(zSql);
    #####:13887:    for(i=1; i<nCol; i++){
    #####:13888:      zSql[j++] = ',';
    #####:13889:      zSql[j++] = '?';
        -:13890:    }
    #####:13891:    zSql[j++] = ')';
    #####:13892:    zSql[j] = 0;
    #####:13893:    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
    #####:13894:    sqlite3_free(zSql);
    #####:13895:    if( rc ){
    #####:13896:      utf8_printf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));
    #####:13897:      if (pStmt) sqlite3_finalize(pStmt);
    #####:13898:      xCloser(sCtx.in);
    #####:13899:      return 1;
        -:13900:    }
    #####:13901:    needCommit = sqlite3_get_autocommit(p->db);
    #####:13902:    if( needCommit ) sqlite3_exec(p->db, "BEGIN", 0, 0, 0);
        -:13903:    do{
    #####:13904:      int startLine = sCtx.nLine;
    #####:13905:      for(i=0; i<nCol; i++){
    #####:13906:        char *z = xRead(&sCtx);
        -:13907:        /*
        -:13908:        ** Did we reach end-of-file before finding any columns?
        -:13909:        ** If so, stop instead of NULL filling the remaining columns.
        -:13910:        */
    #####:13911:        if( z==0 && i==0 ) break;
        -:13912:        /*
        -:13913:        ** Did we reach end-of-file OR end-of-line before finding any
        -:13914:        ** columns in ASCII mode?  If so, stop instead of NULL filling
        -:13915:        ** the remaining columns.
        -:13916:        */
    #####:13917:        if( p->mode==MODE_Ascii && (z==0 || z[0]==0) && i==0 ) break;
    #####:13918:        sqlite3_bind_text(pStmt, i+1, z, -1, SQLITE_TRANSIENT);
    #####:13919:        if( i<nCol-1 && sCtx.cTerm!=sCtx.cColSep ){
    #####:13920:          utf8_printf(stderr, "%s:%d: expected %d columns but found %d - "
        -:13921:                          "filling the rest with NULL\n",
        -:13922:                          sCtx.zFile, startLine, nCol, i+1);
    #####:13923:          i += 2;
    #####:13924:          while( i<=nCol ){ sqlite3_bind_null(pStmt, i); i++; }
        -:13925:        }
        -:13926:      }
    #####:13927:      if( sCtx.cTerm==sCtx.cColSep ){
        -:13928:        do{
    #####:13929:          xRead(&sCtx);
    #####:13930:          i++;
    #####:13931:        }while( sCtx.cTerm==sCtx.cColSep );
    #####:13932:        utf8_printf(stderr, "%s:%d: expected %d columns but found %d - "
        -:13933:                        "extras ignored\n",
        -:13934:                        sCtx.zFile, startLine, nCol, i);
        -:13935:      }
    #####:13936:      if( i>=nCol ){
    #####:13937:        sqlite3_step(pStmt);
    #####:13938:        rc = sqlite3_reset(pStmt);
    #####:13939:        if( rc!=SQLITE_OK ){
    #####:13940:          utf8_printf(stderr, "%s:%d: INSERT failed: %s\n", sCtx.zFile,
        -:13941:                      startLine, sqlite3_errmsg(p->db));
        -:13942:        }
        -:13943:      }
    #####:13944:    }while( sCtx.cTerm!=EOF );
        -:13945:
    #####:13946:    xCloser(sCtx.in);
    #####:13947:    sqlite3_free(sCtx.z);
    #####:13948:    sqlite3_finalize(pStmt);
    #####:13949:    if( needCommit ) sqlite3_exec(p->db, "COMMIT", 0, 0, 0);
        -:13950:  }else
        -:13951:
        -:13952:#ifndef SQLITE_UNTESTABLE
       2*:13953:  if( c=='i' && strncmp(azArg[0], "imposter", n)==0 ){
        -:13954:    char *zSql;
    #####:13955:    char *zCollist = 0;
        -:13956:    sqlite3_stmt *pStmt;
    #####:13957:    int tnum = 0;
        -:13958:    int i;
    #####:13959:    if( !(nArg==3 || (nArg==2 && sqlite3_stricmp(azArg[1],"off")==0)) ){
    #####:13960:      utf8_printf(stderr, "Usage: .imposter INDEX IMPOSTER\n"
        -:13961:                          "       .imposter off\n");
    #####:13962:      rc = 1;
    #####:13963:      goto meta_command_exit;
        -:13964:    }
    #####:13965:    open_db(p, 0);
    #####:13966:    if( nArg==2 ){
    #####:13967:      sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, p->db, "main", 0, 1);
    #####:13968:      goto meta_command_exit;
        -:13969:    }
    #####:13970:    zSql = sqlite3_mprintf("SELECT rootpage FROM sqlite_master"
        -:13971:                           " WHERE name='%q' AND type='index'", azArg[1]);
    #####:13972:    sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
    #####:13973:    sqlite3_free(zSql);
    #####:13974:    if( sqlite3_step(pStmt)==SQLITE_ROW ){
    #####:13975:      tnum = sqlite3_column_int(pStmt, 0);
        -:13976:    }
    #####:13977:    sqlite3_finalize(pStmt);
    #####:13978:    if( tnum==0 ){
    #####:13979:      utf8_printf(stderr, "no such index: \"%s\"\n", azArg[1]);
    #####:13980:      rc = 1;
    #####:13981:      goto meta_command_exit;
        -:13982:    }
    #####:13983:    zSql = sqlite3_mprintf("PRAGMA index_xinfo='%q'", azArg[1]);
    #####:13984:    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
    #####:13985:    sqlite3_free(zSql);
    #####:13986:    i = 0;
    #####:13987:    while( sqlite3_step(pStmt)==SQLITE_ROW ){
        -:13988:      char zLabel[20];
    #####:13989:      const char *zCol = (const char*)sqlite3_column_text(pStmt,2);
    #####:13990:      i++;
    #####:13991:      if( zCol==0 ){
    #####:13992:        if( sqlite3_column_int(pStmt,1)==-1 ){
    #####:13993:          zCol = "_ROWID_";
        -:13994:        }else{
    #####:13995:          sqlite3_snprintf(sizeof(zLabel),zLabel,"expr%d",i);
    #####:13996:          zCol = zLabel;
        -:13997:        }
        -:13998:      }
    #####:13999:      if( zCollist==0 ){
    #####:14000:        zCollist = sqlite3_mprintf("\"%w\"", zCol);
        -:14001:      }else{
    #####:14002:        zCollist = sqlite3_mprintf("%z,\"%w\"", zCollist, zCol);
        -:14003:      }
        -:14004:    }
    #####:14005:    sqlite3_finalize(pStmt);
    #####:14006:    zSql = sqlite3_mprintf(
        -:14007:          "CREATE TABLE \"%w\"(%s,PRIMARY KEY(%s))WITHOUT ROWID",
        -:14008:          azArg[2], zCollist, zCollist);
    #####:14009:    sqlite3_free(zCollist);
    #####:14010:    rc = sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, p->db, "main", 1, tnum);
    #####:14011:    if( rc==SQLITE_OK ){
    #####:14012:      rc = sqlite3_exec(p->db, zSql, 0, 0, 0);
    #####:14013:      sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, p->db, "main", 0, 0);
    #####:14014:      if( rc ){
    #####:14015:        utf8_printf(stderr, "Error in [%s]: %s\n", zSql, sqlite3_errmsg(p->db));
        -:14016:      }else{
    #####:14017:        utf8_printf(stdout, "%s;\n", zSql);
    #####:14018:        raw_printf(stdout,
        -:14019:           "WARNING: writing to an imposter table will corrupt the index!\n"
        -:14020:        );
        -:14021:      }
        -:14022:    }else{
    #####:14023:      raw_printf(stderr, "SQLITE_TESTCTRL_IMPOSTER returns %d\n", rc);
    #####:14024:      rc = 1;
        -:14025:    }
    #####:14026:    sqlite3_free(zSql);
        -:14027:  }else
        -:14028:#endif /* !defined(SQLITE_OMIT_TEST_CONTROL) */
        -:14029:
        -:14030:#ifdef SQLITE_ENABLE_IOTRACE
        -:14031:  if( c=='i' && strncmp(azArg[0], "iotrace", n)==0 ){
        -:14032:    SQLITE_API extern void (SQLITE_CDECL *sqlite3IoTrace)(const char*, ...);
        -:14033:    if( iotrace && iotrace!=stdout ) fclose(iotrace);
        -:14034:    iotrace = 0;
        -:14035:    if( nArg<2 ){
        -:14036:      sqlite3IoTrace = 0;
        -:14037:    }else if( strcmp(azArg[1], "-")==0 ){
        -:14038:      sqlite3IoTrace = iotracePrintf;
        -:14039:      iotrace = stdout;
        -:14040:    }else{
        -:14041:      iotrace = fopen(azArg[1], "w");
        -:14042:      if( iotrace==0 ){
        -:14043:        utf8_printf(stderr, "Error: cannot open \"%s\"\n", azArg[1]);
        -:14044:        sqlite3IoTrace = 0;
        -:14045:        rc = 1;
        -:14046:      }else{
        -:14047:        sqlite3IoTrace = iotracePrintf;
        -:14048:      }
        -:14049:    }
        -:14050:  }else
        -:14051:#endif
        -:14052:
       2*:14053:  if( c=='l' && n>=5 && strncmp(azArg[0], "limits", n)==0 ){
        -:14054:    static const struct {
        -:14055:       const char *zLimitName;   /* Name of a limit */
        -:14056:       int limitCode;            /* Integer code for that limit */
        -:14057:    } aLimit[] = {
        -:14058:      { "length",                SQLITE_LIMIT_LENGTH                    },
        -:14059:      { "sql_length",            SQLITE_LIMIT_SQL_LENGTH                },
        -:14060:      { "column",                SQLITE_LIMIT_COLUMN                    },
        -:14061:      { "expr_depth",            SQLITE_LIMIT_EXPR_DEPTH                },
        -:14062:      { "compound_select",       SQLITE_LIMIT_COMPOUND_SELECT           },
        -:14063:      { "vdbe_op",               SQLITE_LIMIT_VDBE_OP                   },
        -:14064:      { "function_arg",          SQLITE_LIMIT_FUNCTION_ARG              },
        -:14065:      { "attached",              SQLITE_LIMIT_ATTACHED                  },
        -:14066:      { "like_pattern_length",   SQLITE_LIMIT_LIKE_PATTERN_LENGTH       },
        -:14067:      { "variable_number",       SQLITE_LIMIT_VARIABLE_NUMBER           },
        -:14068:      { "trigger_depth",         SQLITE_LIMIT_TRIGGER_DEPTH             },
        -:14069:      { "worker_threads",        SQLITE_LIMIT_WORKER_THREADS            },
        -:14070:    };
        -:14071:    int i, n2;
    #####:14072:    open_db(p, 0);
    #####:14073:    if( nArg==1 ){
    #####:14074:      for(i=0; i<ArraySize(aLimit); i++){
    #####:14075:        printf("%20s %d\n", aLimit[i].zLimitName,
    #####:14076:               sqlite3_limit(p->db, aLimit[i].limitCode, -1));
        -:14077:      }
    #####:14078:    }else if( nArg>3 ){
    #####:14079:      raw_printf(stderr, "Usage: .limit NAME ?NEW-VALUE?\n");
    #####:14080:      rc = 1;
    #####:14081:      goto meta_command_exit;
        -:14082:    }else{
    #####:14083:      int iLimit = -1;
    #####:14084:      n2 = strlen30(azArg[1]);
    #####:14085:      for(i=0; i<ArraySize(aLimit); i++){
    #####:14086:        if( sqlite3_strnicmp(aLimit[i].zLimitName, azArg[1], n2)==0 ){
    #####:14087:          if( iLimit<0 ){
    #####:14088:            iLimit = i;
        -:14089:          }else{
    #####:14090:            utf8_printf(stderr, "ambiguous limit: \"%s\"\n", azArg[1]);
    #####:14091:            rc = 1;
    #####:14092:            goto meta_command_exit;
        -:14093:          }
        -:14094:        }
        -:14095:      }
    #####:14096:      if( iLimit<0 ){
    #####:14097:        utf8_printf(stderr, "unknown limit: \"%s\"\n"
        -:14098:                        "enter \".limits\" with no arguments for a list.\n",
        -:14099:                         azArg[1]);
    #####:14100:        rc = 1;
    #####:14101:        goto meta_command_exit;
        -:14102:      }
    #####:14103:      if( nArg==3 ){
    #####:14104:        sqlite3_limit(p->db, aLimit[iLimit].limitCode,
    #####:14105:                      (int)integerValue(azArg[2]));
        -:14106:      }
    #####:14107:      printf("%20s %d\n", aLimit[iLimit].zLimitName,
    #####:14108:             sqlite3_limit(p->db, aLimit[iLimit].limitCode, -1));
        -:14109:    }
        -:14110:  }else
        -:14111:
       2*:14112:  if( c=='l' && n>2 && strncmp(azArg[0], "lint", n)==0 ){
    #####:14113:    open_db(p, 0);
    #####:14114:    lintDotCommand(p, azArg, nArg);
        -:14115:  }else
        -:14116:
        -:14117:#ifndef SQLITE_OMIT_LOAD_EXTENSION
       2*:14118:  if( c=='l' && strncmp(azArg[0], "load", n)==0 ){
        -:14119:    const char *zFile, *zProc;
    #####:14120:    char *zErrMsg = 0;
    #####:14121:    if( nArg<2 ){
    #####:14122:      raw_printf(stderr, "Usage: .load FILE ?ENTRYPOINT?\n");
    #####:14123:      rc = 1;
    #####:14124:      goto meta_command_exit;
        -:14125:    }
    #####:14126:    zFile = azArg[1];
    #####:14127:    zProc = nArg>=3 ? azArg[2] : 0;
    #####:14128:    open_db(p, 0);
    #####:14129:    rc = sqlite3_load_extension(p->db, zFile, zProc, &zErrMsg);
    #####:14130:    if( rc!=SQLITE_OK ){
    #####:14131:      utf8_printf(stderr, "Error: %s\n", zErrMsg);
    #####:14132:      sqlite3_free(zErrMsg);
    #####:14133:      rc = 1;
        -:14134:    }
        -:14135:  }else
        -:14136:#endif
        -:14137:
       2*:14138:  if( c=='l' && strncmp(azArg[0], "log", n)==0 ){
    #####:14139:    if( nArg!=2 ){
    #####:14140:      raw_printf(stderr, "Usage: .log FILENAME\n");
    #####:14141:      rc = 1;
        -:14142:    }else{
    #####:14143:      const char *zFile = azArg[1];
    #####:14144:      output_file_close(p->pLog);
    #####:14145:      p->pLog = output_file_open(zFile, 0);
        -:14146:    }
        -:14147:  }else
        -:14148:
       2*:14149:  if( c=='m' && strncmp(azArg[0], "mode", n)==0 ){
    #####:14150:    const char *zMode = nArg>=2 ? azArg[1] : "";
    #####:14151:    int n2 = strlen30(zMode);
    #####:14152:    int c2 = zMode[0];
    #####:14153:    if( c2=='l' && n2>2 && strncmp(azArg[1],"lines",n2)==0 ){
    #####:14154:      p->mode = MODE_Line;
    #####:14155:      sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator, SEP_Row);
    #####:14156:    }else if( c2=='c' && strncmp(azArg[1],"columns",n2)==0 ){
    #####:14157:      p->mode = MODE_Column;
    #####:14158:      sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator, SEP_Row);
    #####:14159:    }else if( c2=='l' && n2>2 && strncmp(azArg[1],"list",n2)==0 ){
    #####:14160:      p->mode = MODE_List;
    #####:14161:      sqlite3_snprintf(sizeof(p->colSeparator), p->colSeparator, SEP_Column);
    #####:14162:      sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator, SEP_Row);
    #####:14163:    }else if( c2=='h' && strncmp(azArg[1],"html",n2)==0 ){
    #####:14164:      p->mode = MODE_Html;
    #####:14165:    }else if( c2=='t' && strncmp(azArg[1],"tcl",n2)==0 ){
    #####:14166:      p->mode = MODE_Tcl;
    #####:14167:      sqlite3_snprintf(sizeof(p->colSeparator), p->colSeparator, SEP_Space);
    #####:14168:      sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator, SEP_Row);
    #####:14169:    }else if( c2=='c' && strncmp(azArg[1],"csv",n2)==0 ){
    #####:14170:      p->mode = MODE_Csv;
    #####:14171:      sqlite3_snprintf(sizeof(p->colSeparator), p->colSeparator, SEP_Comma);
    #####:14172:      sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator, SEP_CrLf);
    #####:14173:    }else if( c2=='t' && strncmp(azArg[1],"tabs",n2)==0 ){
    #####:14174:      p->mode = MODE_List;
    #####:14175:      sqlite3_snprintf(sizeof(p->colSeparator), p->colSeparator, SEP_Tab);
    #####:14176:    }else if( c2=='i' && strncmp(azArg[1],"insert",n2)==0 ){
    #####:14177:      p->mode = MODE_Insert;
    #####:14178:      set_table_name(p, nArg>=3 ? azArg[2] : "table");
    #####:14179:    }else if( c2=='q' && strncmp(azArg[1],"quote",n2)==0 ){
    #####:14180:      p->mode = MODE_Quote;
    #####:14181:    }else if( c2=='a' && strncmp(azArg[1],"ascii",n2)==0 ){
    #####:14182:      p->mode = MODE_Ascii;
    #####:14183:      sqlite3_snprintf(sizeof(p->colSeparator), p->colSeparator, SEP_Unit);
    #####:14184:      sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator, SEP_Record);
    #####:14185:    }else if( nArg==1 ){
    #####:14186:      raw_printf(p->out, "current output mode: %s\n", modeDescr[p->mode]);
        -:14187:    }else{
    #####:14188:      raw_printf(stderr, "Error: mode should be one of: "
        -:14189:         "ascii column csv html insert line list quote tabs tcl\n");
    #####:14190:      rc = 1;
        -:14191:    }
    #####:14192:    p->cMode = p->mode;
        -:14193:  }else
        -:14194:
       2*:14195:  if( c=='n' && strncmp(azArg[0], "nullvalue", n)==0 ){
    #####:14196:    if( nArg==2 ){
    #####:14197:      sqlite3_snprintf(sizeof(p->nullValue), p->nullValue,
        -:14198:                       "%.*s", (int)ArraySize(p->nullValue)-1, azArg[1]);
        -:14199:    }else{
    #####:14200:      raw_printf(stderr, "Usage: .nullvalue STRING\n");
    #####:14201:      rc = 1;
        -:14202:    }
        -:14203:  }else
        -:14204:
       2*:14205:  if( c=='o' && strncmp(azArg[0], "open", n)==0 && n>=2 ){
        -:14206:    char *zNewFilename;  /* Name of the database file to open */
    #####:14207:    int iName = 1;       /* Index in azArg[] of the filename */
    #####:14208:    int newFlag = 0;     /* True to delete file before opening */
        -:14209:    /* Close the existing database */
        -:14210:    session_close_all(p);
    #####:14211:    close_db(p->db);
    #####:14212:    p->db = 0;
    #####:14213:    p->zDbFilename = 0;
    #####:14214:    sqlite3_free(p->zFreeOnClose);
    #####:14215:    p->zFreeOnClose = 0;
    #####:14216:    p->openMode = SHELL_OPEN_UNSPEC;
        -:14217:    /* Check for command-line arguments */
    #####:14218:    for(iName=1; iName<nArg && azArg[iName][0]=='-'; iName++){
    #####:14219:      const char *z = azArg[iName];
    #####:14220:      if( optionMatch(z,"new") ){
    #####:14221:        newFlag = 1;
        -:14222:#ifdef SQLITE_HAVE_ZLIB
    #####:14223:      }else if( optionMatch(z, "zip") ){
    #####:14224:        p->openMode = SHELL_OPEN_ZIPFILE;
        -:14225:#endif
    #####:14226:      }else if( optionMatch(z, "append") ){
    #####:14227:        p->openMode = SHELL_OPEN_APPENDVFS;
    #####:14228:      }else if( optionMatch(z, "readonly") ){
    #####:14229:        p->openMode = SHELL_OPEN_READONLY;
        -:14230:#ifdef SQLITE_ENABLE_DESERIALIZE
    #####:14231:      }else if( optionMatch(z, "deserialize") ){
    #####:14232:        p->openMode = SHELL_OPEN_DESERIALIZE;
        -:14233:#endif
    #####:14234:      }else if( z[0]=='-' ){
    #####:14235:        utf8_printf(stderr, "unknown option: %s\n", z);
    #####:14236:        rc = 1;
    #####:14237:        goto meta_command_exit;
        -:14238:      }
        -:14239:    }
        -:14240:    /* If a filename is specified, try to open it first */
    #####:14241:    zNewFilename = nArg>iName ? sqlite3_mprintf("%s", azArg[iName]) : 0;
    #####:14242:    if( zNewFilename ){
    #####:14243:      if( newFlag ) shellDeleteFile(zNewFilename);
    #####:14244:      p->zDbFilename = zNewFilename;
    #####:14245:      open_db(p, OPEN_DB_KEEPALIVE);
    #####:14246:      if( p->db==0 ){
    #####:14247:        utf8_printf(stderr, "Error: cannot open '%s'\n", zNewFilename);
    #####:14248:        sqlite3_free(zNewFilename);
        -:14249:      }else{
    #####:14250:        p->zFreeOnClose = zNewFilename;
        -:14251:      }
        -:14252:    }
    #####:14253:    if( p->db==0 ){
        -:14254:      /* As a fall-back open a TEMP database */
    #####:14255:      p->zDbFilename = 0;
    #####:14256:      open_db(p, 0);
        -:14257:    }
        -:14258:  }else
        -:14259:
        2:14260:  if( (c=='o'
    #####:14261:        && (strncmp(azArg[0], "output", n)==0||strncmp(azArg[0], "once", n)==0))
       2*:14262:   || (c=='e' && n==5 && strcmp(azArg[0],"excel")==0)
    #####:14263:  ){
    #####:14264:    const char *zFile = nArg>=2 ? azArg[1] : "stdout";
    #####:14265:    int bTxtMode = 0;
    #####:14266:    if( azArg[0][0]=='e' ){
        -:14267:      /* Transform the ".excel" command into ".once -x" */
    #####:14268:      nArg = 2;
    #####:14269:      azArg[0] = "once";
    #####:14270:      zFile = azArg[1] = "-x";
    #####:14271:      n = 4;
        -:14272:    }
    #####:14273:    if( nArg>2 ){
    #####:14274:      utf8_printf(stderr, "Usage: .%s [-e|-x|FILE]\n", azArg[0]);
    #####:14275:      rc = 1;
    #####:14276:      goto meta_command_exit;
        -:14277:    }
    #####:14278:    if( n>1 && strncmp(azArg[0], "once", n)==0 ){
    #####:14279:      if( nArg<2 ){
    #####:14280:        raw_printf(stderr, "Usage: .once (-e|-x|FILE)\n");
    #####:14281:        rc = 1;
    #####:14282:        goto meta_command_exit;
        -:14283:      }
    #####:14284:      p->outCount = 2;
        -:14285:    }else{
    #####:14286:      p->outCount = 0;
        -:14287:    }
    #####:14288:    output_reset(p);
    #####:14289:    if( zFile[0]=='-' && zFile[1]=='-' ) zFile++;
        -:14290:#ifndef SQLITE_NOHAVE_SYSTEM
    #####:14291:    if( strcmp(zFile, "-e")==0 || strcmp(zFile, "-x")==0 ){
    #####:14292:      p->doXdgOpen = 1;
    #####:14293:      outputModePush(p);
    #####:14294:      if( zFile[1]=='x' ){
    #####:14295:        newTempFile(p, "csv");
    #####:14296:        p->mode = MODE_Csv;
    #####:14297:        sqlite3_snprintf(sizeof(p->colSeparator), p->colSeparator, SEP_Comma);
    #####:14298:        sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator, SEP_CrLf);
        -:14299:      }else{
    #####:14300:        newTempFile(p, "txt");
    #####:14301:        bTxtMode = 1;
        -:14302:      }
    #####:14303:      zFile = p->zTempFile;
        -:14304:    }
        -:14305:#endif /* SQLITE_NOHAVE_SYSTEM */
    #####:14306:    if( zFile[0]=='|' ){
        -:14307:#ifdef SQLITE_OMIT_POPEN
        -:14308:      raw_printf(stderr, "Error: pipes are not supported in this OS\n");
        -:14309:      rc = 1;
        -:14310:      p->out = stdout;
        -:14311:#else
    #####:14312:      p->out = popen(zFile + 1, "w");
    #####:14313:      if( p->out==0 ){
    #####:14314:        utf8_printf(stderr,"Error: cannot open pipe \"%s\"\n", zFile + 1);
    #####:14315:        p->out = stdout;
    #####:14316:        rc = 1;
        -:14317:      }else{
    #####:14318:        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", zFile);
        -:14319:      }
        -:14320:#endif
        -:14321:    }else{
    #####:14322:      p->out = output_file_open(zFile, bTxtMode);
    #####:14323:      if( p->out==0 ){
    #####:14324:        if( strcmp(zFile,"off")!=0 ){
    #####:14325:          utf8_printf(stderr,"Error: cannot write to \"%s\"\n", zFile);
        -:14326:        }
    #####:14327:        p->out = stdout;
    #####:14328:        rc = 1;
        -:14329:      } else {
    #####:14330:        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", zFile);
        -:14331:      }
        -:14332:    }
        -:14333:  }else
        -:14334:
       2*:14335:  if( c=='p' && n>=3 && strncmp(azArg[0], "print", n)==0 ){
        -:14336:    int i;
    #####:14337:    for(i=1; i<nArg; i++){
    #####:14338:      if( i>1 ) raw_printf(p->out, " ");
    #####:14339:      utf8_printf(p->out, "%s", azArg[i]);
        -:14340:    }
    #####:14341:    raw_printf(p->out, "\n");
        -:14342:  }else
        -:14343:
       2*:14344:  if( c=='p' && strncmp(azArg[0], "prompt", n)==0 ){
    #####:14345:    if( nArg >= 2) {
    #####:14346:      strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);
        -:14347:    }
    #####:14348:    if( nArg >= 3) {
    #####:14349:      strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);
        -:14350:    }
        -:14351:  }else
        -:14352:
        2:14353:  if( c=='q' && strncmp(azArg[0], "quit", n)==0 ){
        2:14354:    rc = 2;
        -:14355:  }else
        -:14356:
    #####:14357:  if( c=='r' && n>=3 && strncmp(azArg[0], "read", n)==0 ){
        -:14358:    FILE *alt;
    #####:14359:    if( nArg!=2 ){
    #####:14360:      raw_printf(stderr, "Usage: .read FILE\n");
    #####:14361:      rc = 1;
    #####:14362:      goto meta_command_exit;
        -:14363:    }
    #####:14364:    alt = fopen(azArg[1], "rb");
    #####:14365:    if( alt==0 ){
    #####:14366:      utf8_printf(stderr,"Error: cannot open \"%s\"\n", azArg[1]);
    #####:14367:      rc = 1;
        -:14368:    }else{
    #####:14369:      rc = process_input(p, alt);
    #####:14370:      fclose(alt);
        -:14371:    }
        -:14372:  }else
        -:14373:
    #####:14374:  if( c=='r' && n>=3 && strncmp(azArg[0], "restore", n)==0 ){
        -:14375:    const char *zSrcFile;
        -:14376:    const char *zDb;
        -:14377:    sqlite3 *pSrc;
        -:14378:    sqlite3_backup *pBackup;
    #####:14379:    int nTimeout = 0;
        -:14380:
    #####:14381:    if( nArg==2 ){
    #####:14382:      zSrcFile = azArg[1];
    #####:14383:      zDb = "main";
    #####:14384:    }else if( nArg==3 ){
    #####:14385:      zSrcFile = azArg[2];
    #####:14386:      zDb = azArg[1];
        -:14387:    }else{
    #####:14388:      raw_printf(stderr, "Usage: .restore ?DB? FILE\n");
    #####:14389:      rc = 1;
    #####:14390:      goto meta_command_exit;
        -:14391:    }
    #####:14392:    rc = sqlite3_open(zSrcFile, &pSrc);
    #####:14393:    if( rc!=SQLITE_OK ){
    #####:14394:      utf8_printf(stderr, "Error: cannot open \"%s\"\n", zSrcFile);
    #####:14395:      close_db(pSrc);
    #####:14396:      return 1;
        -:14397:    }
    #####:14398:    open_db(p, 0);
    #####:14399:    pBackup = sqlite3_backup_init(p->db, zDb, pSrc, "main");
    #####:14400:    if( pBackup==0 ){
    #####:14401:      utf8_printf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));
    #####:14402:      close_db(pSrc);
    #####:14403:      return 1;
        -:14404:    }
    #####:14405:    while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK
    #####:14406:          || rc==SQLITE_BUSY  ){
    #####:14407:      if( rc==SQLITE_BUSY ){
    #####:14408:        if( nTimeout++ >= 3 ) break;
    #####:14409:        sqlite3_sleep(100);
        -:14410:      }
        -:14411:    }
    #####:14412:    sqlite3_backup_finish(pBackup);
    #####:14413:    if( rc==SQLITE_DONE ){
    #####:14414:      rc = 0;
    #####:14415:    }else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){
    #####:14416:      raw_printf(stderr, "Error: source database is busy\n");
    #####:14417:      rc = 1;
        -:14418:    }else{
    #####:14419:      utf8_printf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));
    #####:14420:      rc = 1;
        -:14421:    }
    #####:14422:    close_db(pSrc);
        -:14423:  }else
        -:14424:
    #####:14425:  if( c=='s' && strncmp(azArg[0], "scanstats", n)==0 ){
    #####:14426:    if( nArg==2 ){
    #####:14427:      p->scanstatsOn = (u8)booleanValue(azArg[1]);
        -:14428:#ifndef SQLITE_ENABLE_STMT_SCANSTATUS
    #####:14429:      raw_printf(stderr, "Warning: .scanstats not available in this build.\n");
        -:14430:#endif
        -:14431:    }else{
    #####:14432:      raw_printf(stderr, "Usage: .scanstats on|off\n");
    #####:14433:      rc = 1;
        -:14434:    }
        -:14435:  }else
        -:14436:
    #####:14437:  if( c=='s' && strncmp(azArg[0], "schema", n)==0 ){
        -:14438:    ShellText sSelect;
        -:14439:    ShellState data;
    #####:14440:    char *zErrMsg = 0;
    #####:14441:    const char *zDiv = "(";
    #####:14442:    const char *zName = 0;
    #####:14443:    int iSchema = 0;
    #####:14444:    int bDebug = 0;
        -:14445:    int ii;
        -:14446:
    #####:14447:    open_db(p, 0);
    #####:14448:    memcpy(&data, p, sizeof(data));
    #####:14449:    data.showHeader = 0;
    #####:14450:    data.cMode = data.mode = MODE_Semi;
    #####:14451:    initText(&sSelect);
    #####:14452:    for(ii=1; ii<nArg; ii++){
    #####:14453:      if( optionMatch(azArg[ii],"indent") ){
    #####:14454:        data.cMode = data.mode = MODE_Pretty;
    #####:14455:      }else if( optionMatch(azArg[ii],"debug") ){
    #####:14456:        bDebug = 1;
    #####:14457:      }else if( zName==0 ){
    #####:14458:        zName = azArg[ii];
        -:14459:      }else{
    #####:14460:        raw_printf(stderr, "Usage: .schema ?--indent? ?LIKE-PATTERN?\n");
    #####:14461:        rc = 1;
    #####:14462:        goto meta_command_exit;
        -:14463:      }
        -:14464:    }
    #####:14465:    if( zName!=0 ){
    #####:14466:      int isMaster = sqlite3_strlike(zName, "sqlite_master", '\\')==0;
    #####:14467:      if( isMaster || sqlite3_strlike(zName,"sqlite_temp_master", '\\')==0 ){
        -:14468:        char *new_argv[2], *new_colv[2];
    #####:14469:        new_argv[0] = sqlite3_mprintf(
        -:14470:                      "CREATE TABLE %s (\n"
        -:14471:                      "  type text,\n"
        -:14472:                      "  name text,\n"
        -:14473:                      "  tbl_name text,\n"
        -:14474:                      "  rootpage integer,\n"
        -:14475:                      "  sql text\n"
        -:14476:                      ")", isMaster ? "sqlite_master" : "sqlite_temp_master");
    #####:14477:        new_argv[1] = 0;
    #####:14478:        new_colv[0] = "sql";
    #####:14479:        new_colv[1] = 0;
    #####:14480:        callback(&data, 1, new_argv, new_colv);
    #####:14481:        sqlite3_free(new_argv[0]);
        -:14482:      }
        -:14483:    }
    #####:14484:    if( zDiv ){
    #####:14485:      sqlite3_stmt *pStmt = 0;
    #####:14486:      rc = sqlite3_prepare_v2(p->db, "SELECT name FROM pragma_database_list",
        -:14487:                              -1, &pStmt, 0);
    #####:14488:      if( rc ){
    #####:14489:        utf8_printf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));
    #####:14490:        sqlite3_finalize(pStmt);
    #####:14491:        rc = 1;
    #####:14492:        goto meta_command_exit;
        -:14493:      }
    #####:14494:      appendText(&sSelect, "SELECT sql FROM", 0);
    #####:14495:      iSchema = 0;
    #####:14496:      while( sqlite3_step(pStmt)==SQLITE_ROW ){
    #####:14497:        const char *zDb = (const char*)sqlite3_column_text(pStmt, 0);
        -:14498:        char zScNum[30];
    #####:14499:        sqlite3_snprintf(sizeof(zScNum), zScNum, "%d", ++iSchema);
    #####:14500:        appendText(&sSelect, zDiv, 0);
    #####:14501:        zDiv = " UNION ALL ";
    #####:14502:        appendText(&sSelect, "SELECT shell_add_schema(sql,", 0);
    #####:14503:        if( sqlite3_stricmp(zDb, "main")!=0 ){
    #####:14504:          appendText(&sSelect, zDb, '"');
        -:14505:        }else{
    #####:14506:          appendText(&sSelect, "NULL", 0);
        -:14507:        }
    #####:14508:        appendText(&sSelect, ",name) AS sql, type, tbl_name, name, rowid,", 0);
    #####:14509:        appendText(&sSelect, zScNum, 0);
    #####:14510:        appendText(&sSelect, " AS snum, ", 0);
    #####:14511:        appendText(&sSelect, zDb, '\'');
    #####:14512:        appendText(&sSelect, " AS sname FROM ", 0);
    #####:14513:        appendText(&sSelect, zDb, '"');
    #####:14514:        appendText(&sSelect, ".sqlite_master", 0);
        -:14515:      }
    #####:14516:      sqlite3_finalize(pStmt);
        -:14517:#ifdef SQLITE_INTROSPECTION_PRAGMAS
    #####:14518:      if( zName ){
    #####:14519:        appendText(&sSelect,
        -:14520:           " UNION ALL SELECT shell_module_schema(name),"
        -:14521:           " 'table', name, name, name, 9e+99, 'main' FROM pragma_module_list", 0);
        -:14522:      }
        -:14523:#endif
    #####:14524:      appendText(&sSelect, ") WHERE ", 0);
    #####:14525:      if( zName ){
    #####:14526:        char *zQarg = sqlite3_mprintf("%Q", zName);
    #####:14527:        int bGlob = strchr(zName, '*') != 0 || strchr(zName, '?') != 0 ||
    #####:14528:                    strchr(zName, '[') != 0;
    #####:14529:        if( strchr(zName, '.') ){
    #####:14530:          appendText(&sSelect, "lower(printf('%s.%s',sname,tbl_name))", 0);
        -:14531:        }else{
    #####:14532:          appendText(&sSelect, "lower(tbl_name)", 0);
        -:14533:        }
    #####:14534:        appendText(&sSelect, bGlob ? " GLOB " : " LIKE ", 0);
    #####:14535:        appendText(&sSelect, zQarg, 0);
    #####:14536:        if( !bGlob ){
    #####:14537:          appendText(&sSelect, " ESCAPE '\\' ", 0);
        -:14538:        }
    #####:14539:        appendText(&sSelect, " AND ", 0);
    #####:14540:        sqlite3_free(zQarg);
        -:14541:      }
    #####:14542:      appendText(&sSelect, "type!='meta' AND sql IS NOT NULL"
        -:14543:                           " ORDER BY snum, rowid", 0);
    #####:14544:      if( bDebug ){
    #####:14545:        utf8_printf(p->out, "SQL: %s;\n", sSelect.z);
        -:14546:      }else{
    #####:14547:        rc = sqlite3_exec(p->db, sSelect.z, callback, &data, &zErrMsg);
        -:14548:      }
    #####:14549:      freeText(&sSelect);
        -:14550:    }
    #####:14551:    if( zErrMsg ){
    #####:14552:      utf8_printf(stderr,"Error: %s\n", zErrMsg);
    #####:14553:      sqlite3_free(zErrMsg);
    #####:14554:      rc = 1;
    #####:14555:    }else if( rc != SQLITE_OK ){
    #####:14556:      raw_printf(stderr,"Error: querying schema information\n");
    #####:14557:      rc = 1;
        -:14558:    }else{
    #####:14559:      rc = 0;
        -:14560:    }
        -:14561:  }else
        -:14562:
        -:14563:#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_SELECTTRACE)
        -:14564:  if( c=='s' && n==11 && strncmp(azArg[0], "selecttrace", n)==0 ){
        -:14565:    sqlite3SelectTrace = (int)integerValue(azArg[1]);
        -:14566:  }else
        -:14567:#endif
        -:14568:
        -:14569:#if defined(SQLITE_ENABLE_SESSION)
        -:14570:  if( c=='s' && strncmp(azArg[0],"session",n)==0 && n>=3 ){
        -:14571:    OpenSession *pSession = &p->aSession[0];
        -:14572:    char **azCmd = &azArg[1];
        -:14573:    int iSes = 0;
        -:14574:    int nCmd = nArg - 1;
        -:14575:    int i;
        -:14576:    if( nArg<=1 ) goto session_syntax_error;
        -:14577:    open_db(p, 0);
        -:14578:    if( nArg>=3 ){
        -:14579:      for(iSes=0; iSes<p->nSession; iSes++){
        -:14580:        if( strcmp(p->aSession[iSes].zName, azArg[1])==0 ) break;
        -:14581:      }
        -:14582:      if( iSes<p->nSession ){
        -:14583:        pSession = &p->aSession[iSes];
        -:14584:        azCmd++;
        -:14585:        nCmd--;
        -:14586:      }else{
        -:14587:        pSession = &p->aSession[0];
        -:14588:        iSes = 0;
        -:14589:      }
        -:14590:    }
        -:14591:
        -:14592:    /* .session attach TABLE
        -:14593:    ** Invoke the sqlite3session_attach() interface to attach a particular
        -:14594:    ** table so that it is never filtered.
        -:14595:    */
        -:14596:    if( strcmp(azCmd[0],"attach")==0 ){
        -:14597:      if( nCmd!=2 ) goto session_syntax_error;
        -:14598:      if( pSession->p==0 ){
        -:14599:        session_not_open:
        -:14600:        raw_printf(stderr, "ERROR: No sessions are open\n");
        -:14601:      }else{
        -:14602:        rc = sqlite3session_attach(pSession->p, azCmd[1]);
        -:14603:        if( rc ){
        -:14604:          raw_printf(stderr, "ERROR: sqlite3session_attach() returns %d\n", rc);
        -:14605:          rc = 0;
        -:14606:        }
        -:14607:      }
        -:14608:    }else
        -:14609:
        -:14610:    /* .session changeset FILE
        -:14611:    ** .session patchset FILE
        -:14612:    ** Write a changeset or patchset into a file.  The file is overwritten.
        -:14613:    */
        -:14614:    if( strcmp(azCmd[0],"changeset")==0 || strcmp(azCmd[0],"patchset")==0 ){
        -:14615:      FILE *out = 0;
        -:14616:      if( nCmd!=2 ) goto session_syntax_error;
        -:14617:      if( pSession->p==0 ) goto session_not_open;
        -:14618:      out = fopen(azCmd[1], "wb");
        -:14619:      if( out==0 ){
        -:14620:        utf8_printf(stderr, "ERROR: cannot open \"%s\" for writing\n", azCmd[1]);
        -:14621:      }else{
        -:14622:        int szChng;
        -:14623:        void *pChng;
        -:14624:        if( azCmd[0][0]=='c' ){
        -:14625:          rc = sqlite3session_changeset(pSession->p, &szChng, &pChng);
        -:14626:        }else{
        -:14627:          rc = sqlite3session_patchset(pSession->p, &szChng, &pChng);
        -:14628:        }
        -:14629:        if( rc ){
        -:14630:          printf("Error: error code %d\n", rc);
        -:14631:          rc = 0;
        -:14632:        }
        -:14633:        if( pChng
        -:14634:          && fwrite(pChng, szChng, 1, out)!=1 ){
        -:14635:          raw_printf(stderr, "ERROR: Failed to write entire %d-byte output\n",
        -:14636:                  szChng);
        -:14637:        }
        -:14638:        sqlite3_free(pChng);
        -:14639:        fclose(out);
        -:14640:      }
        -:14641:    }else
        -:14642:
        -:14643:    /* .session close
        -:14644:    ** Close the identified session
        -:14645:    */
        -:14646:    if( strcmp(azCmd[0], "close")==0 ){
        -:14647:      if( nCmd!=1 ) goto session_syntax_error;
        -:14648:      if( p->nSession ){
        -:14649:        session_close(pSession);
        -:14650:        p->aSession[iSes] = p->aSession[--p->nSession];
        -:14651:      }
        -:14652:    }else
        -:14653:
        -:14654:    /* .session enable ?BOOLEAN?
        -:14655:    ** Query or set the enable flag
        -:14656:    */
        -:14657:    if( strcmp(azCmd[0], "enable")==0 ){
        -:14658:      int ii;
        -:14659:      if( nCmd>2 ) goto session_syntax_error;
        -:14660:      ii = nCmd==1 ? -1 : booleanValue(azCmd[1]);
        -:14661:      if( p->nSession ){
        -:14662:        ii = sqlite3session_enable(pSession->p, ii);
        -:14663:        utf8_printf(p->out, "session %s enable flag = %d\n",
        -:14664:                    pSession->zName, ii);
        -:14665:      }
        -:14666:    }else
        -:14667:
        -:14668:    /* .session filter GLOB ....
        -:14669:    ** Set a list of GLOB patterns of table names to be excluded.
        -:14670:    */
        -:14671:    if( strcmp(azCmd[0], "filter")==0 ){
        -:14672:      int ii, nByte;
        -:14673:      if( nCmd<2 ) goto session_syntax_error;
        -:14674:      if( p->nSession ){
        -:14675:        for(ii=0; ii<pSession->nFilter; ii++){
        -:14676:          sqlite3_free(pSession->azFilter[ii]);
        -:14677:        }
        -:14678:        sqlite3_free(pSession->azFilter);
        -:14679:        nByte = sizeof(pSession->azFilter[0])*(nCmd-1);
        -:14680:        pSession->azFilter = sqlite3_malloc( nByte );
        -:14681:        if( pSession->azFilter==0 ){
        -:14682:          raw_printf(stderr, "Error: out or memory\n");
        -:14683:          exit(1);
        -:14684:        }
        -:14685:        for(ii=1; ii<nCmd; ii++){
        -:14686:          pSession->azFilter[ii-1] = sqlite3_mprintf("%s", azCmd[ii]);
        -:14687:        }
        -:14688:        pSession->nFilter = ii-1;
        -:14689:      }
        -:14690:    }else
        -:14691:
        -:14692:    /* .session indirect ?BOOLEAN?
        -:14693:    ** Query or set the indirect flag
        -:14694:    */
        -:14695:    if( strcmp(azCmd[0], "indirect")==0 ){
        -:14696:      int ii;
        -:14697:      if( nCmd>2 ) goto session_syntax_error;
        -:14698:      ii = nCmd==1 ? -1 : booleanValue(azCmd[1]);
        -:14699:      if( p->nSession ){
        -:14700:        ii = sqlite3session_indirect(pSession->p, ii);
        -:14701:        utf8_printf(p->out, "session %s indirect flag = %d\n",
        -:14702:                    pSession->zName, ii);
        -:14703:      }
        -:14704:    }else
        -:14705:
        -:14706:    /* .session isempty
        -:14707:    ** Determine if the session is empty
        -:14708:    */
        -:14709:    if( strcmp(azCmd[0], "isempty")==0 ){
        -:14710:      int ii;
        -:14711:      if( nCmd!=1 ) goto session_syntax_error;
        -:14712:      if( p->nSession ){
        -:14713:        ii = sqlite3session_isempty(pSession->p);
        -:14714:        utf8_printf(p->out, "session %s isempty flag = %d\n",
        -:14715:                    pSession->zName, ii);
        -:14716:      }
        -:14717:    }else
        -:14718:
        -:14719:    /* .session list
        -:14720:    ** List all currently open sessions
        -:14721:    */
        -:14722:    if( strcmp(azCmd[0],"list")==0 ){
        -:14723:      for(i=0; i<p->nSession; i++){
        -:14724:        utf8_printf(p->out, "%d %s\n", i, p->aSession[i].zName);
        -:14725:      }
        -:14726:    }else
        -:14727:
        -:14728:    /* .session open DB NAME
        -:14729:    ** Open a new session called NAME on the attached database DB.
        -:14730:    ** DB is normally "main".
        -:14731:    */
        -:14732:    if( strcmp(azCmd[0],"open")==0 ){
        -:14733:      char *zName;
        -:14734:      if( nCmd!=3 ) goto session_syntax_error;
        -:14735:      zName = azCmd[2];
        -:14736:      if( zName[0]==0 ) goto session_syntax_error;
        -:14737:      for(i=0; i<p->nSession; i++){
        -:14738:        if( strcmp(p->aSession[i].zName,zName)==0 ){
        -:14739:          utf8_printf(stderr, "Session \"%s\" already exists\n", zName);
        -:14740:          goto meta_command_exit;
        -:14741:        }
        -:14742:      }
        -:14743:      if( p->nSession>=ArraySize(p->aSession) ){
        -:14744:        raw_printf(stderr, "Maximum of %d sessions\n", ArraySize(p->aSession));
        -:14745:        goto meta_command_exit;
        -:14746:      }
        -:14747:      pSession = &p->aSession[p->nSession];
        -:14748:      rc = sqlite3session_create(p->db, azCmd[1], &pSession->p);
        -:14749:      if( rc ){
        -:14750:        raw_printf(stderr, "Cannot open session: error code=%d\n", rc);
        -:14751:        rc = 0;
        -:14752:        goto meta_command_exit;
        -:14753:      }
        -:14754:      pSession->nFilter = 0;
        -:14755:      sqlite3session_table_filter(pSession->p, session_filter, pSession);
        -:14756:      p->nSession++;
        -:14757:      pSession->zName = sqlite3_mprintf("%s", zName);
        -:14758:    }else
        -:14759:    /* If no command name matches, show a syntax error */
        -:14760:    session_syntax_error:
        -:14761:    showHelp(p->out, "session");
        -:14762:  }else
        -:14763:#endif
        -:14764:
        -:14765:#ifdef SQLITE_DEBUG
        -:14766:  /* Undocumented commands for internal testing.  Subject to change
        -:14767:  ** without notice. */
        -:14768:  if( c=='s' && n>=10 && strncmp(azArg[0], "selftest-", 9)==0 ){
        -:14769:    if( strncmp(azArg[0]+9, "boolean", n-9)==0 ){
        -:14770:      int i, v;
        -:14771:      for(i=1; i<nArg; i++){
        -:14772:        v = booleanValue(azArg[i]);
        -:14773:        utf8_printf(p->out, "%s: %d 0x%x\n", azArg[i], v, v);
        -:14774:      }
        -:14775:    }
        -:14776:    if( strncmp(azArg[0]+9, "integer", n-9)==0 ){
        -:14777:      int i; sqlite3_int64 v;
        -:14778:      for(i=1; i<nArg; i++){
        -:14779:        char zBuf[200];
        -:14780:        v = integerValue(azArg[i]);
        -:14781:        sqlite3_snprintf(sizeof(zBuf),zBuf,"%s: %lld 0x%llx\n", azArg[i],v,v);
        -:14782:        utf8_printf(p->out, "%s", zBuf);
        -:14783:      }
        -:14784:    }
        -:14785:  }else
        -:14786:#endif
        -:14787:
    #####:14788:  if( c=='s' && n>=4 && strncmp(azArg[0],"selftest",n)==0 ){
    #####:14789:    int bIsInit = 0;         /* True to initialize the SELFTEST table */
    #####:14790:    int bVerbose = 0;        /* Verbose output */
        -:14791:    int bSelftestExists;     /* True if SELFTEST already exists */
        -:14792:    int i, k;                /* Loop counters */
    #####:14793:    int nTest = 0;           /* Number of tests runs */
    #####:14794:    int nErr = 0;            /* Number of errors seen */
        -:14795:    ShellText str;           /* Answer for a query */
    #####:14796:    sqlite3_stmt *pStmt = 0; /* Query against the SELFTEST table */
        -:14797:
    #####:14798:    open_db(p,0);
    #####:14799:    for(i=1; i<nArg; i++){
    #####:14800:      const char *z = azArg[i];
    #####:14801:      if( z[0]=='-' && z[1]=='-' ) z++;
    #####:14802:      if( strcmp(z,"-init")==0 ){
    #####:14803:        bIsInit = 1;
        -:14804:      }else
    #####:14805:      if( strcmp(z,"-v")==0 ){
    #####:14806:        bVerbose++;
        -:14807:      }else
        -:14808:      {
    #####:14809:        utf8_printf(stderr, "Unknown option \"%s\" on \"%s\"\n",
        -:14810:                    azArg[i], azArg[0]);
    #####:14811:        raw_printf(stderr, "Should be one of: --init -v\n");
    #####:14812:        rc = 1;
    #####:14813:        goto meta_command_exit;
        -:14814:      }
        -:14815:    }
    #####:14816:    if( sqlite3_table_column_metadata(p->db,"main","selftest",0,0,0,0,0,0)
        -:14817:           != SQLITE_OK ){
    #####:14818:      bSelftestExists = 0;
        -:14819:    }else{
    #####:14820:      bSelftestExists = 1;
        -:14821:    }
    #####:14822:    if( bIsInit ){
    #####:14823:      createSelftestTable(p);
    #####:14824:      bSelftestExists = 1;
        -:14825:    }
    #####:14826:    initText(&str);
    #####:14827:    appendText(&str, "x", 0);
    #####:14828:    for(k=bSelftestExists; k>=0; k--){
    #####:14829:      if( k==1 ){
    #####:14830:        rc = sqlite3_prepare_v2(p->db,
        -:14831:            "SELECT tno,op,cmd,ans FROM selftest ORDER BY tno",
        -:14832:            -1, &pStmt, 0);
        -:14833:      }else{
    #####:14834:        rc = sqlite3_prepare_v2(p->db,
        -:14835:          "VALUES(0,'memo','Missing SELFTEST table - default checks only',''),"
        -:14836:          "      (1,'run','PRAGMA integrity_check','ok')",
        -:14837:          -1, &pStmt, 0);
        -:14838:      }
    #####:14839:      if( rc ){
    #####:14840:        raw_printf(stderr, "Error querying the selftest table\n");
    #####:14841:        rc = 1;
    #####:14842:        sqlite3_finalize(pStmt);
    #####:14843:        goto meta_command_exit;
        -:14844:      }
    #####:14845:      for(i=1; sqlite3_step(pStmt)==SQLITE_ROW; i++){
    #####:14846:        int tno = sqlite3_column_int(pStmt, 0);
    #####:14847:        const char *zOp = (const char*)sqlite3_column_text(pStmt, 1);
    #####:14848:        const char *zSql = (const char*)sqlite3_column_text(pStmt, 2);
    #####:14849:        const char *zAns = (const char*)sqlite3_column_text(pStmt, 3);
        -:14850:
    #####:14851:        k = 0;
    #####:14852:        if( bVerbose>0 ){
    #####:14853:          char *zQuote = sqlite3_mprintf("%q", zSql);
    #####:14854:          printf("%d: %s %s\n", tno, zOp, zSql);
    #####:14855:          sqlite3_free(zQuote);
        -:14856:        }
    #####:14857:        if( strcmp(zOp,"memo")==0 ){
    #####:14858:          utf8_printf(p->out, "%s\n", zSql);
        -:14859:        }else
    #####:14860:        if( strcmp(zOp,"run")==0 ){
    #####:14861:          char *zErrMsg = 0;
    #####:14862:          str.n = 0;
    #####:14863:          str.z[0] = 0;
    #####:14864:          rc = sqlite3_exec(p->db, zSql, captureOutputCallback, &str, &zErrMsg);
    #####:14865:          nTest++;
    #####:14866:          if( bVerbose ){
    #####:14867:            utf8_printf(p->out, "Result: %s\n", str.z);
        -:14868:          }
    #####:14869:          if( rc || zErrMsg ){
    #####:14870:            nErr++;
    #####:14871:            rc = 1;
    #####:14872:            utf8_printf(p->out, "%d: error-code-%d: %s\n", tno, rc, zErrMsg);
    #####:14873:            sqlite3_free(zErrMsg);
    #####:14874:          }else if( strcmp(zAns,str.z)!=0 ){
    #####:14875:            nErr++;
    #####:14876:            rc = 1;
    #####:14877:            utf8_printf(p->out, "%d: Expected: [%s]\n", tno, zAns);
    #####:14878:            utf8_printf(p->out, "%d:      Got: [%s]\n", tno, str.z);
        -:14879:          }
        -:14880:        }else
        -:14881:        {
    #####:14882:          utf8_printf(stderr,
        -:14883:            "Unknown operation \"%s\" on selftest line %d\n", zOp, tno);
    #####:14884:          rc = 1;
    #####:14885:          break;
        -:14886:        }
        -:14887:      } /* End loop over rows of content from SELFTEST */
    #####:14888:      sqlite3_finalize(pStmt);
        -:14889:    } /* End loop over k */
    #####:14890:    freeText(&str);
    #####:14891:    utf8_printf(p->out, "%d errors out of %d tests\n", nErr, nTest);
        -:14892:  }else
        -:14893:
    #####:14894:  if( c=='s' && strncmp(azArg[0], "separator", n)==0 ){
    #####:14895:    if( nArg<2 || nArg>3 ){
    #####:14896:      raw_printf(stderr, "Usage: .separator COL ?ROW?\n");
    #####:14897:      rc = 1;
        -:14898:    }
    #####:14899:    if( nArg>=2 ){
    #####:14900:      sqlite3_snprintf(sizeof(p->colSeparator), p->colSeparator,
        -:14901:                       "%.*s", (int)ArraySize(p->colSeparator)-1, azArg[1]);
        -:14902:    }
    #####:14903:    if( nArg>=3 ){
    #####:14904:      sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator,
        -:14905:                       "%.*s", (int)ArraySize(p->rowSeparator)-1, azArg[2]);
        -:14906:    }
        -:14907:  }else
        -:14908:
    #####:14909:  if( c=='s' && n>=4 && strncmp(azArg[0],"sha3sum",n)==0 ){
    #####:14910:    const char *zLike = 0;   /* Which table to checksum. 0 means everything */
        -:14911:    int i;                   /* Loop counter */
    #####:14912:    int bSchema = 0;         /* Also hash the schema */
    #####:14913:    int bSeparate = 0;       /* Hash each table separately */
    #####:14914:    int iSize = 224;         /* Hash algorithm to use */
    #####:14915:    int bDebug = 0;          /* Only show the query that would have run */
        -:14916:    sqlite3_stmt *pStmt;     /* For querying tables names */
        -:14917:    char *zSql;              /* SQL to be run */
        -:14918:    char *zSep;              /* Separator */
        -:14919:    ShellText sSql;          /* Complete SQL for the query to run the hash */
        -:14920:    ShellText sQuery;        /* Set of queries used to read all content */
    #####:14921:    open_db(p, 0);
    #####:14922:    for(i=1; i<nArg; i++){
    #####:14923:      const char *z = azArg[i];
    #####:14924:      if( z[0]=='-' ){
    #####:14925:        z++;
    #####:14926:        if( z[0]=='-' ) z++;
    #####:14927:        if( strcmp(z,"schema")==0 ){
    #####:14928:          bSchema = 1;
        -:14929:        }else
    #####:14930:        if( strcmp(z,"sha3-224")==0 || strcmp(z,"sha3-256")==0
    #####:14931:         || strcmp(z,"sha3-384")==0 || strcmp(z,"sha3-512")==0
        -:14932:        ){
    #####:14933:          iSize = atoi(&z[5]);
        -:14934:        }else
    #####:14935:        if( strcmp(z,"debug")==0 ){
    #####:14936:          bDebug = 1;
        -:14937:        }else
        -:14938:        {
    #####:14939:          utf8_printf(stderr, "Unknown option \"%s\" on \"%s\"\n",
        -:14940:                      azArg[i], azArg[0]);
    #####:14941:          raw_printf(stderr, "Should be one of: --schema"
        -:14942:                             " --sha3-224 --sha3-256 --sha3-384 --sha3-512\n");
    #####:14943:          rc = 1;
    #####:14944:          goto meta_command_exit;
        -:14945:        }
    #####:14946:      }else if( zLike ){
    #####:14947:        raw_printf(stderr, "Usage: .sha3sum ?OPTIONS? ?LIKE-PATTERN?\n");
    #####:14948:        rc = 1;
    #####:14949:        goto meta_command_exit;
        -:14950:      }else{
    #####:14951:        zLike = z;
    #####:14952:        bSeparate = 1;
    #####:14953:        if( sqlite3_strlike("sqlite\\_%", zLike, '\\')==0 ) bSchema = 1;
        -:14954:      }
        -:14955:    }
    #####:14956:    if( bSchema ){
    #####:14957:      zSql = "SELECT lower(name) FROM sqlite_master"
        -:14958:             " WHERE type='table' AND coalesce(rootpage,0)>1"
        -:14959:             " UNION ALL SELECT 'sqlite_master'"
        -:14960:             " ORDER BY 1 collate nocase";
        -:14961:    }else{
    #####:14962:      zSql = "SELECT lower(name) FROM sqlite_master"
        -:14963:             " WHERE type='table' AND coalesce(rootpage,0)>1"
        -:14964:             " AND name NOT LIKE 'sqlite_%'"
        -:14965:             " ORDER BY 1 collate nocase";
        -:14966:    }
    #####:14967:    sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
    #####:14968:    initText(&sQuery);
    #####:14969:    initText(&sSql);
    #####:14970:    appendText(&sSql, "WITH [sha3sum$query](a,b) AS(",0);
    #####:14971:    zSep = "VALUES(";
    #####:14972:    while( SQLITE_ROW==sqlite3_step(pStmt) ){
    #####:14973:      const char *zTab = (const char*)sqlite3_column_text(pStmt,0);
    #####:14974:      if( zLike && sqlite3_strlike(zLike, zTab, 0)!=0 ) continue;
    #####:14975:      if( strncmp(zTab, "sqlite_",7)!=0 ){
    #####:14976:        appendText(&sQuery,"SELECT * FROM ", 0);
    #####:14977:        appendText(&sQuery,zTab,'"');
    #####:14978:        appendText(&sQuery," NOT INDEXED;", 0);
    #####:14979:      }else if( strcmp(zTab, "sqlite_master")==0 ){
    #####:14980:        appendText(&sQuery,"SELECT type,name,tbl_name,sql FROM sqlite_master"
        -:14981:                           " ORDER BY name;", 0);
    #####:14982:      }else if( strcmp(zTab, "sqlite_sequence")==0 ){
    #####:14983:        appendText(&sQuery,"SELECT name,seq FROM sqlite_sequence"
        -:14984:                           " ORDER BY name;", 0);
    #####:14985:      }else if( strcmp(zTab, "sqlite_stat1")==0 ){
    #####:14986:        appendText(&sQuery,"SELECT tbl,idx,stat FROM sqlite_stat1"
        -:14987:                           " ORDER BY tbl,idx;", 0);
    #####:14988:      }else if( strcmp(zTab, "sqlite_stat3")==0
    #####:14989:             || strcmp(zTab, "sqlite_stat4")==0 ){
    #####:14990:        appendText(&sQuery, "SELECT * FROM ", 0);
    #####:14991:        appendText(&sQuery, zTab, 0);
    #####:14992:        appendText(&sQuery, " ORDER BY tbl, idx, rowid;\n", 0);
        -:14993:      }
    #####:14994:      appendText(&sSql, zSep, 0);
    #####:14995:      appendText(&sSql, sQuery.z, '\'');
    #####:14996:      sQuery.n = 0;
    #####:14997:      appendText(&sSql, ",", 0);
    #####:14998:      appendText(&sSql, zTab, '\'');
    #####:14999:      zSep = "),(";
        -:15000:    }
    #####:15001:    sqlite3_finalize(pStmt);
    #####:15002:    if( bSeparate ){
    #####:15003:      zSql = sqlite3_mprintf(
        -:15004:          "%s))"
        -:15005:          " SELECT lower(hex(sha3_query(a,%d))) AS hash, b AS label"
        -:15006:          "   FROM [sha3sum$query]",
        -:15007:          sSql.z, iSize);
        -:15008:    }else{
    #####:15009:      zSql = sqlite3_mprintf(
        -:15010:          "%s))"
        -:15011:          " SELECT lower(hex(sha3_query(group_concat(a,''),%d))) AS hash"
        -:15012:          "   FROM [sha3sum$query]",
        -:15013:          sSql.z, iSize);
        -:15014:    }
    #####:15015:    freeText(&sQuery);
    #####:15016:    freeText(&sSql);
    #####:15017:    if( bDebug ){
    #####:15018:      utf8_printf(p->out, "%s\n", zSql);
        -:15019:    }else{
    #####:15020:      shell_exec(p, zSql, 0);
        -:15021:    }
    #####:15022:    sqlite3_free(zSql);
        -:15023:  }else
        -:15024:
        -:15025:#ifndef SQLITE_NOHAVE_SYSTEM
    #####:15026:  if( c=='s'
    #####:15027:   && (strncmp(azArg[0], "shell", n)==0 || strncmp(azArg[0],"system",n)==0)
    #####:15028:  ){
        -:15029:    char *zCmd;
        -:15030:    int i, x;
    #####:15031:    if( nArg<2 ){
    #####:15032:      raw_printf(stderr, "Usage: .system COMMAND\n");
    #####:15033:      rc = 1;
    #####:15034:      goto meta_command_exit;
        -:15035:    }
    #####:15036:    zCmd = sqlite3_mprintf(strchr(azArg[1],' ')==0?"%s":"\"%s\"", azArg[1]);
    #####:15037:    for(i=2; i<nArg; i++){
    #####:15038:      zCmd = sqlite3_mprintf(strchr(azArg[i],' ')==0?"%z %s":"%z \"%s\"",
        -:15039:                             zCmd, azArg[i]);
        -:15040:    }
    #####:15041:    x = system(zCmd);
    #####:15042:    sqlite3_free(zCmd);
    #####:15043:    if( x ) raw_printf(stderr, "System command returns %d\n", x);
        -:15044:  }else
        -:15045:#endif /* !defined(SQLITE_NOHAVE_SYSTEM) */
        -:15046:
    #####:15047:  if( c=='s' && strncmp(azArg[0], "show", n)==0 ){
        -:15048:    static const char *azBool[] = { "off", "on", "trigger", "full"};
        -:15049:    int i;
    #####:15050:    if( nArg!=1 ){
    #####:15051:      raw_printf(stderr, "Usage: .show\n");
    #####:15052:      rc = 1;
    #####:15053:      goto meta_command_exit;
        -:15054:    }
    #####:15055:    utf8_printf(p->out, "%12.12s: %s\n","echo",
    #####:15056:                                  azBool[ShellHasFlag(p, SHFLG_Echo)]);
    #####:15057:    utf8_printf(p->out, "%12.12s: %s\n","eqp", azBool[p->autoEQP&3]);
    #####:15058:    utf8_printf(p->out, "%12.12s: %s\n","explain",
    #####:15059:         p->mode==MODE_Explain ? "on" : p->autoExplain ? "auto" : "off");
    #####:15060:    utf8_printf(p->out,"%12.12s: %s\n","headers", azBool[p->showHeader!=0]);
    #####:15061:    utf8_printf(p->out, "%12.12s: %s\n","mode", modeDescr[p->mode]);
    #####:15062:    utf8_printf(p->out, "%12.12s: ", "nullvalue");
    #####:15063:      output_c_string(p->out, p->nullValue);
    #####:15064:      raw_printf(p->out, "\n");
    #####:15065:    utf8_printf(p->out,"%12.12s: %s\n","output",
    #####:15066:            strlen30(p->outfile) ? p->outfile : "stdout");
    #####:15067:    utf8_printf(p->out,"%12.12s: ", "colseparator");
    #####:15068:      output_c_string(p->out, p->colSeparator);
    #####:15069:      raw_printf(p->out, "\n");
    #####:15070:    utf8_printf(p->out,"%12.12s: ", "rowseparator");
    #####:15071:      output_c_string(p->out, p->rowSeparator);
    #####:15072:      raw_printf(p->out, "\n");
    #####:15073:    utf8_printf(p->out, "%12.12s: %s\n","stats", azBool[p->statsOn!=0]);
    #####:15074:    utf8_printf(p->out, "%12.12s: ", "width");
    #####:15075:    for (i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++) {
    #####:15076:      raw_printf(p->out, "%d ", p->colWidth[i]);
        -:15077:    }
    #####:15078:    raw_printf(p->out, "\n");
    #####:15079:    utf8_printf(p->out, "%12.12s: %s\n", "filename",
    #####:15080:                p->zDbFilename ? p->zDbFilename : "");
        -:15081:  }else
        -:15082:
    #####:15083:  if( c=='s' && strncmp(azArg[0], "stats", n)==0 ){
    #####:15084:    if( nArg==2 ){
    #####:15085:      p->statsOn = (u8)booleanValue(azArg[1]);
    #####:15086:    }else if( nArg==1 ){
    #####:15087:      display_stats(p->db, p, 0);
        -:15088:    }else{
    #####:15089:      raw_printf(stderr, "Usage: .stats ?on|off?\n");
    #####:15090:      rc = 1;
        -:15091:    }
        -:15092:  }else
        -:15093:
    #####:15094:  if( (c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0)
    #####:15095:   || (c=='i' && (strncmp(azArg[0], "indices", n)==0
    #####:15096:                 || strncmp(azArg[0], "indexes", n)==0) )
    #####:15097:  ){
        -:15098:    sqlite3_stmt *pStmt;
        -:15099:    char **azResult;
        -:15100:    int nRow, nAlloc;
        -:15101:    int ii;
        -:15102:    ShellText s;
    #####:15103:    initText(&s);
    #####:15104:    open_db(p, 0);
    #####:15105:    rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);
    #####:15106:    if( rc ){
    #####:15107:      sqlite3_finalize(pStmt);
    #####:15108:      return shellDatabaseError(p->db);
        -:15109:    }
        -:15110:
    #####:15111:    if( nArg>2 && c=='i' ){
        -:15112:      /* It is an historical accident that the .indexes command shows an error
        -:15113:      ** when called with the wrong number of arguments whereas the .tables
        -:15114:      ** command does not. */
    #####:15115:      raw_printf(stderr, "Usage: .indexes ?LIKE-PATTERN?\n");
    #####:15116:      rc = 1;
    #####:15117:      sqlite3_finalize(pStmt);
    #####:15118:      goto meta_command_exit;
        -:15119:    }
    #####:15120:    for(ii=0; sqlite3_step(pStmt)==SQLITE_ROW; ii++){
    #####:15121:      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);
    #####:15122:      if( zDbName==0 ) continue;
    #####:15123:      if( s.z && s.z[0] ) appendText(&s, " UNION ALL ", 0);
    #####:15124:      if( sqlite3_stricmp(zDbName, "main")==0 ){
    #####:15125:        appendText(&s, "SELECT name FROM ", 0);
        -:15126:      }else{
    #####:15127:        appendText(&s, "SELECT ", 0);
    #####:15128:        appendText(&s, zDbName, '\'');
    #####:15129:        appendText(&s, "||'.'||name FROM ", 0);
        -:15130:      }
    #####:15131:      appendText(&s, zDbName, '"');
    #####:15132:      appendText(&s, ".sqlite_master ", 0);
    #####:15133:      if( c=='t' ){
    #####:15134:        appendText(&s," WHERE type IN ('table','view')"
        -:15135:                      "   AND name NOT LIKE 'sqlite_%'"
        -:15136:                      "   AND name LIKE ?1", 0);
        -:15137:      }else{
    #####:15138:        appendText(&s," WHERE type='index'"
        -:15139:                      "   AND tbl_name LIKE ?1", 0);
        -:15140:      }
        -:15141:    }
    #####:15142:    rc = sqlite3_finalize(pStmt);
    #####:15143:    appendText(&s, " ORDER BY 1", 0);
    #####:15144:    rc = sqlite3_prepare_v2(p->db, s.z, -1, &pStmt, 0);
    #####:15145:    freeText(&s);
    #####:15146:    if( rc ) return shellDatabaseError(p->db);
        -:15147:
        -:15148:    /* Run the SQL statement prepared by the above block. Store the results
        -:15149:    ** as an array of nul-terminated strings in azResult[].  */
    #####:15150:    nRow = nAlloc = 0;
    #####:15151:    azResult = 0;
    #####:15152:    if( nArg>1 ){
    #####:15153:      sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);
        -:15154:    }else{
    #####:15155:      sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);
        -:15156:    }
    #####:15157:    while( sqlite3_step(pStmt)==SQLITE_ROW ){
    #####:15158:      if( nRow>=nAlloc ){
        -:15159:        char **azNew;
    #####:15160:        int n2 = nAlloc*2 + 10;
    #####:15161:        azNew = sqlite3_realloc64(azResult, sizeof(azResult[0])*n2);
    #####:15162:        if( azNew==0 ) shell_out_of_memory();
    #####:15163:        nAlloc = n2;
    #####:15164:        azResult = azNew;
        -:15165:      }
    #####:15166:      azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));
    #####:15167:      if( 0==azResult[nRow] ) shell_out_of_memory();
    #####:15168:      nRow++;
        -:15169:    }
    #####:15170:    if( sqlite3_finalize(pStmt)!=SQLITE_OK ){
    #####:15171:      rc = shellDatabaseError(p->db);
        -:15172:    }
        -:15173:
        -:15174:    /* Pretty-print the contents of array azResult[] to the output */
    #####:15175:    if( rc==0 && nRow>0 ){
    #####:15176:      int len, maxlen = 0;
        -:15177:      int i, j;
        -:15178:      int nPrintCol, nPrintRow;
    #####:15179:      for(i=0; i<nRow; i++){
    #####:15180:        len = strlen30(azResult[i]);
    #####:15181:        if( len>maxlen ) maxlen = len;
        -:15182:      }
    #####:15183:      nPrintCol = 80/(maxlen+2);
    #####:15184:      if( nPrintCol<1 ) nPrintCol = 1;
    #####:15185:      nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;
    #####:15186:      for(i=0; i<nPrintRow; i++){
    #####:15187:        for(j=i; j<nRow; j+=nPrintRow){
    #####:15188:          char *zSp = j<nPrintRow ? "" : "  ";
    #####:15189:          utf8_printf(p->out, "%s%-*s", zSp, maxlen,
    #####:15190:                      azResult[j] ? azResult[j]:"");
        -:15191:        }
    #####:15192:        raw_printf(p->out, "\n");
        -:15193:      }
        -:15194:    }
        -:15195:
    #####:15196:    for(ii=0; ii<nRow; ii++) sqlite3_free(azResult[ii]);
    #####:15197:    sqlite3_free(azResult);
        -:15198:  }else
        -:15199:
        -:15200:  /* Begin redirecting output to the file "testcase-out.txt" */
    #####:15201:  if( c=='t' && strcmp(azArg[0],"testcase")==0 ){
    #####:15202:    output_reset(p);
    #####:15203:    p->out = output_file_open("testcase-out.txt", 0);
    #####:15204:    if( p->out==0 ){
    #####:15205:      raw_printf(stderr, "Error: cannot open 'testcase-out.txt'\n");
        -:15206:    }
    #####:15207:    if( nArg>=2 ){
    #####:15208:      sqlite3_snprintf(sizeof(p->zTestcase), p->zTestcase, "%s", azArg[1]);
        -:15209:    }else{
    #####:15210:      sqlite3_snprintf(sizeof(p->zTestcase), p->zTestcase, "?");
        -:15211:    }
        -:15212:  }else
        -:15213:
        -:15214:#ifndef SQLITE_UNTESTABLE
    #####:15215:  if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 ){
        -:15216:    static const struct {
        -:15217:       const char *zCtrlName;   /* Name of a test-control option */
        -:15218:       int ctrlCode;            /* Integer code for that option */
        -:15219:       const char *zUsage;      /* Usage notes */
        -:15220:    } aCtrl[] = {
        -:15221:      { "always",             SQLITE_TESTCTRL_ALWAYS,        "BOOLEAN"            },
        -:15222:      { "assert",             SQLITE_TESTCTRL_ASSERT,        "BOOLEAN"            },
        -:15223:    /*{ "benign_malloc_hooks",SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS, ""          },*/
        -:15224:    /*{ "bitvec_test",        SQLITE_TESTCTRL_BITVEC_TEST,   ""                },*/
        -:15225:      { "byteorder",          SQLITE_TESTCTRL_BYTEORDER,     ""                   },
        -:15226:    /*{ "fault_install",      SQLITE_TESTCTRL_FAULT_INSTALL, ""                }, */
        -:15227:      { "imposter",           SQLITE_TESTCTRL_IMPOSTER,   "SCHEMA ON/OFF ROOTPAGE"},
        -:15228:      { "internal_functions", SQLITE_TESTCTRL_INTERNAL_FUNCTIONS, "BOOLEAN"       },
        -:15229:      { "localtime_fault",    SQLITE_TESTCTRL_LOCALTIME_FAULT,"BOOLEAN"           },
        -:15230:      { "never_corrupt",      SQLITE_TESTCTRL_NEVER_CORRUPT, "BOOLEAN"            },
        -:15231:      { "optimizations",      SQLITE_TESTCTRL_OPTIMIZATIONS, "DISABLE-MASK"       },
        -:15232:#ifdef YYCOVERAGE
        -:15233:      { "parser_coverage",    SQLITE_TESTCTRL_PARSER_COVERAGE, ""                 },
        -:15234:#endif
        -:15235:      { "pending_byte",       SQLITE_TESTCTRL_PENDING_BYTE,  "OFFSET  "           },
        -:15236:      { "prng_reset",         SQLITE_TESTCTRL_PRNG_RESET,    ""                   },
        -:15237:      { "prng_restore",       SQLITE_TESTCTRL_PRNG_RESTORE,  ""                   },
        -:15238:      { "prng_save",          SQLITE_TESTCTRL_PRNG_SAVE,     ""                   },
        -:15239:      { "reserve",            SQLITE_TESTCTRL_RESERVE,       "BYTES-OF-RESERVE"   },
        -:15240:    };
    #####:15241:    int testctrl = -1;
    #####:15242:    int iCtrl = -1;
    #####:15243:    int rc2 = 0;    /* 0: usage.  1: %d  2: %x  3: no-output */
    #####:15244:    int isOk = 0;
        -:15245:    int i, n2;
    #####:15246:    const char *zCmd = 0;
        -:15247:
    #####:15248:    open_db(p, 0);
    #####:15249:    zCmd = nArg>=2 ? azArg[1] : "help";
        -:15250:
        -:15251:    /* The argument can optionally begin with "-" or "--" */
    #####:15252:    if( zCmd[0]=='-' && zCmd[1] ){
    #####:15253:      zCmd++;
    #####:15254:      if( zCmd[0]=='-' && zCmd[1] ) zCmd++;
        -:15255:    }
        -:15256:
        -:15257:    /* --help lists all test-controls */
    #####:15258:    if( strcmp(zCmd,"help")==0 ){
    #####:15259:      utf8_printf(p->out, "Available test-controls:\n");
    #####:15260:      for(i=0; i<ArraySize(aCtrl); i++){
    #####:15261:        utf8_printf(p->out, "  .testctrl %s %s\n",
    #####:15262:                    aCtrl[i].zCtrlName, aCtrl[i].zUsage);
        -:15263:      }
    #####:15264:      rc = 1;
    #####:15265:      goto meta_command_exit;
        -:15266:    }
        -:15267:
        -:15268:    /* convert testctrl text option to value. allow any unique prefix
        -:15269:    ** of the option name, or a numerical value. */
    #####:15270:    n2 = strlen30(zCmd);
    #####:15271:    for(i=0; i<ArraySize(aCtrl); i++){
    #####:15272:      if( strncmp(zCmd, aCtrl[i].zCtrlName, n2)==0 ){
    #####:15273:        if( testctrl<0 ){
    #####:15274:          testctrl = aCtrl[i].ctrlCode;
    #####:15275:          iCtrl = i;
        -:15276:        }else{
    #####:15277:          utf8_printf(stderr, "Error: ambiguous test-control: \"%s\"\n"
        -:15278:                              "Use \".testctrl --help\" for help\n", zCmd);
    #####:15279:          rc = 1;
    #####:15280:          goto meta_command_exit;
        -:15281:        }
        -:15282:      }
        -:15283:    }
    #####:15284:    if( testctrl<0 ){
    #####:15285:      utf8_printf(stderr,"Error: unknown test-control: %s\n"
        -:15286:                         "Use \".testctrl --help\" for help\n", zCmd);
        -:15287:    }else{
    #####:15288:      switch(testctrl){
        -:15289:
        -:15290:        /* sqlite3_test_control(int, db, int) */
    #####:15291:        case SQLITE_TESTCTRL_OPTIMIZATIONS:
        -:15292:        case SQLITE_TESTCTRL_RESERVE:
    #####:15293:          if( nArg==3 ){
    #####:15294:            int opt = (int)strtol(azArg[2], 0, 0);
    #####:15295:            rc2 = sqlite3_test_control(testctrl, p->db, opt);
    #####:15296:            isOk = 3;
        -:15297:          }
    #####:15298:          break;
        -:15299:
        -:15300:        /* sqlite3_test_control(int) */
    #####:15301:        case SQLITE_TESTCTRL_PRNG_SAVE:
        -:15302:        case SQLITE_TESTCTRL_PRNG_RESTORE:
        -:15303:        case SQLITE_TESTCTRL_PRNG_RESET:
        -:15304:        case SQLITE_TESTCTRL_BYTEORDER:
    #####:15305:          if( nArg==2 ){
    #####:15306:            rc2 = sqlite3_test_control(testctrl);
    #####:15307:            isOk = testctrl==SQLITE_TESTCTRL_BYTEORDER ? 1 : 3;
        -:15308:          }
    #####:15309:          break;
        -:15310:
        -:15311:        /* sqlite3_test_control(int, uint) */
    #####:15312:        case SQLITE_TESTCTRL_PENDING_BYTE:
    #####:15313:          if( nArg==3 ){
    #####:15314:            unsigned int opt = (unsigned int)integerValue(azArg[2]);
    #####:15315:            rc2 = sqlite3_test_control(testctrl, opt);
    #####:15316:            isOk = 3;
        -:15317:          }
    #####:15318:          break;
        -:15319:
        -:15320:        /* sqlite3_test_control(int, int) */
    #####:15321:        case SQLITE_TESTCTRL_ASSERT:
        -:15322:        case SQLITE_TESTCTRL_ALWAYS:
        -:15323:        case SQLITE_TESTCTRL_INTERNAL_FUNCTIONS:
    #####:15324:          if( nArg==3 ){
    #####:15325:            int opt = booleanValue(azArg[2]);
    #####:15326:            rc2 = sqlite3_test_control(testctrl, opt);
    #####:15327:            isOk = 1;
        -:15328:          }
    #####:15329:          break;
        -:15330:
        -:15331:        /* sqlite3_test_control(int, int) */
    #####:15332:        case SQLITE_TESTCTRL_LOCALTIME_FAULT:
        -:15333:        case SQLITE_TESTCTRL_NEVER_CORRUPT:
    #####:15334:          if( nArg==3 ){
    #####:15335:            int opt = booleanValue(azArg[2]);
    #####:15336:            rc2 = sqlite3_test_control(testctrl, opt);
    #####:15337:            isOk = 3;
        -:15338:          }
    #####:15339:          break;
        -:15340:
    #####:15341:        case SQLITE_TESTCTRL_IMPOSTER:
    #####:15342:          if( nArg==5 ){
    #####:15343:            rc2 = sqlite3_test_control(testctrl, p->db,
        -:15344:                          azArg[2],
    #####:15345:                          integerValue(azArg[3]),
    #####:15346:                          integerValue(azArg[4]));
    #####:15347:            isOk = 3;
        -:15348:          }
    #####:15349:          break;
        -:15350:
        -:15351:#ifdef YYCOVERAGE
        -:15352:        case SQLITE_TESTCTRL_PARSER_COVERAGE:
        -:15353:          if( nArg==2 ){
        -:15354:            sqlite3_test_control(testctrl, p->out);
        -:15355:            isOk = 3;
        -:15356:          }
        -:15357:#endif
        -:15358:      }
        -:15359:    }
    #####:15360:    if( isOk==0 && iCtrl>=0 ){
    #####:15361:      utf8_printf(p->out, "Usage: .testctrl %s %s\n", zCmd, aCtrl[iCtrl].zUsage);
    #####:15362:      rc = 1;
    #####:15363:    }else if( isOk==1 ){
    #####:15364:      raw_printf(p->out, "%d\n", rc2);
    #####:15365:    }else if( isOk==2 ){
    #####:15366:      raw_printf(p->out, "0x%08x\n", rc2);
        -:15367:    }
        -:15368:  }else
        -:15369:#endif /* !defined(SQLITE_UNTESTABLE) */
        -:15370:
    #####:15371:  if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 ){
    #####:15372:    open_db(p, 0);
    #####:15373:    sqlite3_busy_timeout(p->db, nArg>=2 ? (int)integerValue(azArg[1]) : 0);
        -:15374:  }else
        -:15375:
    #####:15376:  if( c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0 ){
    #####:15377:    if( nArg==2 ){
    #####:15378:      enableTimer = booleanValue(azArg[1]);
        -:15379:      if( enableTimer && !HAS_TIMER ){
        -:15380:        raw_printf(stderr, "Error: timer not available on this system.\n");
        -:15381:        enableTimer = 0;
        -:15382:      }
        -:15383:    }else{
    #####:15384:      raw_printf(stderr, "Usage: .timer on|off\n");
    #####:15385:      rc = 1;
        -:15386:    }
        -:15387:  }else
        -:15388:
    #####:15389:  if( c=='t' && strncmp(azArg[0], "trace", n)==0 ){
    #####:15390:    open_db(p, 0);
    #####:15391:    if( nArg!=2 ){
    #####:15392:      raw_printf(stderr, "Usage: .trace FILE|off\n");
    #####:15393:      rc = 1;
    #####:15394:      goto meta_command_exit;
        -:15395:    }
    #####:15396:    output_file_close(p->traceOut);
    #####:15397:    p->traceOut = output_file_open(azArg[1], 0);
        -:15398:#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)
    #####:15399:    if( p->traceOut==0 ){
    #####:15400:      sqlite3_trace_v2(p->db, 0, 0, 0);
        -:15401:    }else{
    #####:15402:      sqlite3_trace_v2(p->db, SQLITE_TRACE_STMT, sql_trace_callback,p->traceOut);
        -:15403:    }
        -:15404:#endif
        -:15405:  }else
        -:15406:
        -:15407:#if SQLITE_USER_AUTHENTICATION
        -:15408:  if( c=='u' && strncmp(azArg[0], "user", n)==0 ){
        -:15409:    if( nArg<2 ){
        -:15410:      raw_printf(stderr, "Usage: .user SUBCOMMAND ...\n");
        -:15411:      rc = 1;
        -:15412:      goto meta_command_exit;
        -:15413:    }
        -:15414:    open_db(p, 0);
        -:15415:    if( strcmp(azArg[1],"login")==0 ){
        -:15416:      if( nArg!=4 ){
        -:15417:        raw_printf(stderr, "Usage: .user login USER PASSWORD\n");
        -:15418:        rc = 1;
        -:15419:        goto meta_command_exit;
        -:15420:      }
        -:15421:      rc = sqlite3_user_authenticate(p->db, azArg[2], azArg[3], strlen30(azArg[3]));
        -:15422:      if( rc ){
        -:15423:        utf8_printf(stderr, "Authentication failed for user %s\n", azArg[2]);
        -:15424:        rc = 1;
        -:15425:      }
        -:15426:    }else if( strcmp(azArg[1],"add")==0 ){
        -:15427:      if( nArg!=5 ){
        -:15428:        raw_printf(stderr, "Usage: .user add USER PASSWORD ISADMIN\n");
        -:15429:        rc = 1;
        -:15430:        goto meta_command_exit;
        -:15431:      }
        -:15432:      rc = sqlite3_user_add(p->db, azArg[2], azArg[3], strlen30(azArg[3]),
        -:15433:                            booleanValue(azArg[4]));
        -:15434:      if( rc ){
        -:15435:        raw_printf(stderr, "User-Add failed: %d\n", rc);
        -:15436:        rc = 1;
        -:15437:      }
        -:15438:    }else if( strcmp(azArg[1],"edit")==0 ){
        -:15439:      if( nArg!=5 ){
        -:15440:        raw_printf(stderr, "Usage: .user edit USER PASSWORD ISADMIN\n");
        -:15441:        rc = 1;
        -:15442:        goto meta_command_exit;
        -:15443:      }
        -:15444:      rc = sqlite3_user_change(p->db, azArg[2], azArg[3], strlen30(azArg[3]),
        -:15445:                              booleanValue(azArg[4]));
        -:15446:      if( rc ){
        -:15447:        raw_printf(stderr, "User-Edit failed: %d\n", rc);
        -:15448:        rc = 1;
        -:15449:      }
        -:15450:    }else if( strcmp(azArg[1],"delete")==0 ){
        -:15451:      if( nArg!=3 ){
        -:15452:        raw_printf(stderr, "Usage: .user delete USER\n");
        -:15453:        rc = 1;
        -:15454:        goto meta_command_exit;
        -:15455:      }
        -:15456:      rc = sqlite3_user_delete(p->db, azArg[2]);
        -:15457:      if( rc ){
        -:15458:        raw_printf(stderr, "User-Delete failed: %d\n", rc);
        -:15459:        rc = 1;
        -:15460:      }
        -:15461:    }else{
        -:15462:      raw_printf(stderr, "Usage: .user login|add|edit|delete ...\n");
        -:15463:      rc = 1;
        -:15464:      goto meta_command_exit;
        -:15465:    }
        -:15466:  }else
        -:15467:#endif /* SQLITE_USER_AUTHENTICATION */
        -:15468:
    #####:15469:  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){
    #####:15470:    utf8_printf(p->out, "SQLite %s %s\n" /*extra-version-info*/,
        -:15471:        sqlite3_libversion(), sqlite3_sourceid());
        -:15472:#if SQLITE_HAVE_ZLIB
    #####:15473:    utf8_printf(p->out, "zlib version %s\n", zlibVersion());
        -:15474:#endif
        -:15475:#define CTIMEOPT_VAL_(opt) #opt
        -:15476:#define CTIMEOPT_VAL(opt) CTIMEOPT_VAL_(opt)
        -:15477:#if defined(__clang__) && defined(__clang_major__)
        -:15478:    utf8_printf(p->out, "clang-" CTIMEOPT_VAL(__clang_major__) "."
        -:15479:                    CTIMEOPT_VAL(__clang_minor__) "."
        -:15480:                    CTIMEOPT_VAL(__clang_patchlevel__) "\n");
        -:15481:#elif defined(_MSC_VER)
        -:15482:    utf8_printf(p->out, "msvc-" CTIMEOPT_VAL(_MSC_VER) "\n");
        -:15483:#elif defined(__GNUC__) && defined(__VERSION__)
    #####:15484:    utf8_printf(p->out, "gcc-" __VERSION__ "\n");
        -:15485:#endif
        -:15486:  }else
        -:15487:
    #####:15488:  if( c=='v' && strncmp(azArg[0], "vfsinfo", n)==0 ){
    #####:15489:    const char *zDbName = nArg==2 ? azArg[1] : "main";
    #####:15490:    sqlite3_vfs *pVfs = 0;
    #####:15491:    if( p->db ){
    #####:15492:      sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFS_POINTER, &pVfs);
    #####:15493:      if( pVfs ){
    #####:15494:        utf8_printf(p->out, "vfs.zName      = \"%s\"\n", pVfs->zName);
    #####:15495:        raw_printf(p->out, "vfs.iVersion   = %d\n", pVfs->iVersion);
    #####:15496:        raw_printf(p->out, "vfs.szOsFile   = %d\n", pVfs->szOsFile);
    #####:15497:        raw_printf(p->out, "vfs.mxPathname = %d\n", pVfs->mxPathname);
        -:15498:      }
        -:15499:    }
        -:15500:  }else
        -:15501:
    #####:15502:  if( c=='v' && strncmp(azArg[0], "vfslist", n)==0 ){
        -:15503:    sqlite3_vfs *pVfs;
    #####:15504:    sqlite3_vfs *pCurrent = 0;
    #####:15505:    if( p->db ){
    #####:15506:      sqlite3_file_control(p->db, "main", SQLITE_FCNTL_VFS_POINTER, &pCurrent);
        -:15507:    }
    #####:15508:    for(pVfs=sqlite3_vfs_find(0); pVfs; pVfs=pVfs->pNext){
    #####:15509:      utf8_printf(p->out, "vfs.zName      = \"%s\"%s\n", pVfs->zName,
    #####:15510:           pVfs==pCurrent ? "  <--- CURRENT" : "");
    #####:15511:      raw_printf(p->out, "vfs.iVersion   = %d\n", pVfs->iVersion);
    #####:15512:      raw_printf(p->out, "vfs.szOsFile   = %d\n", pVfs->szOsFile);
    #####:15513:      raw_printf(p->out, "vfs.mxPathname = %d\n", pVfs->mxPathname);
    #####:15514:      if( pVfs->pNext ){
    #####:15515:        raw_printf(p->out, "-----------------------------------\n");
        -:15516:      }
        -:15517:    }
        -:15518:  }else
        -:15519:
    #####:15520:  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){
    #####:15521:    const char *zDbName = nArg==2 ? azArg[1] : "main";
    #####:15522:    char *zVfsName = 0;
    #####:15523:    if( p->db ){
    #####:15524:      sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);
    #####:15525:      if( zVfsName ){
    #####:15526:        utf8_printf(p->out, "%s\n", zVfsName);
    #####:15527:        sqlite3_free(zVfsName);
        -:15528:      }
        -:15529:    }
        -:15530:  }else
        -:15531:
        -:15532:#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)
        -:15533:  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){
        -:15534:    sqlite3WhereTrace = nArg>=2 ? booleanValue(azArg[1]) : 0xff;
        -:15535:  }else
        -:15536:#endif
        -:15537:
    #####:15538:  if( c=='w' && strncmp(azArg[0], "width", n)==0 ){
        -:15539:    int j;
        -:15540:    assert( nArg<=ArraySize(azArg) );
    #####:15541:    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){
    #####:15542:      p->colWidth[j-1] = (int)integerValue(azArg[j]);
        -:15543:    }
        -:15544:  }else
        -:15545:
        -:15546:  {
    #####:15547:    utf8_printf(stderr, "Error: unknown command or invalid arguments: "
        -:15548:      " \"%s\". Enter \".help\" for help\n", azArg[0]);
    #####:15549:    rc = 1;
        -:15550:  }
        -:15551:
        2:15552:meta_command_exit:
        2:15553:  if( p->outCount ){
    #####:15554:    p->outCount--;
    #####:15555:    if( p->outCount==0 ) output_reset(p);
        -:15556:  }
        2:15557:  return rc;
        -:15558:}
        -:15559:
        -:15560:/*
        -:15561:** Return TRUE if a semicolon occurs anywhere in the first N characters
        -:15562:** of string z[].
        -:15563:*/
        2:15564:static int line_contains_semicolon(const char *z, int N){
        -:15565:  int i;
       34:15566:  for(i=0; i<N; i++){  if( z[i]==';' ) return 1; }
    #####:15567:  return 0;
        -:15568:}
        -:15569:
        -:15570:/*
        -:15571:** Test to see if a line consists entirely of whitespace.
        -:15572:*/
        4:15573:static int _all_whitespace(const char *z){
       4*:15574:  for(; *z; z++){
       4*:15575:    if( IsSpace(z[0]) ) continue;
       4*:15576:    if( *z=='/' && z[1]=='*' ){
    #####:15577:      z += 2;
    #####:15578:      while( *z && (*z!='*' || z[1]!='/') ){ z++; }
    #####:15579:      if( *z==0 ) return 0;
    #####:15580:      z++;
    #####:15581:      continue;
        -:15582:    }
       4*:15583:    if( *z=='-' && z[1]=='-' ){
    #####:15584:      z += 2;
    #####:15585:      while( *z && *z!='\n' ){ z++; }
    #####:15586:      if( *z==0 ) return 1;
    #####:15587:      continue;
        -:15588:    }
        4:15589:    return 0;
        -:15590:  }
    #####:15591:  return 1;
        -:15592:}
        -:15593:
        -:15594:/*
        -:15595:** Return TRUE if the line typed in is an SQL command terminator other
        -:15596:** than a semi-colon.  The SQL Server style "go" command is understood
        -:15597:** as is the Oracle "/".
        -:15598:*/
        2:15599:static int line_is_command_terminator(const char *zLine){
       2*:15600:  while( IsSpace(zLine[0]) ){ zLine++; };
       2*:15601:  if( zLine[0]=='/' && _all_whitespace(&zLine[1]) ){
    #####:15602:    return 1;  /* Oracle */
        -:15603:  }
       2*:15604:  if( ToLower(zLine[0])=='g' && ToLower(zLine[1])=='o'
    #####:15605:         && _all_whitespace(&zLine[2]) ){
    #####:15606:    return 1;  /* SQL Server */
        -:15607:  }
        2:15608:  return 0;
        -:15609:}
        -:15610:
        -:15611:/*
        -:15612:** We need a default sqlite3_complete() implementation to use in case
        -:15613:** the shell is compiled with SQLITE_OMIT_COMPLETE.  The default assumes
        -:15614:** any arbitrary text is a complete SQL statement.  This is not very
        -:15615:** user-friendly, but it does seem to work.
        -:15616:*/
        -:15617:#ifdef SQLITE_OMIT_COMPLETE
        -:15618:#define sqlite3_complete(x) 1
        -:15619:#endif
        -:15620:
        -:15621:/*
        -:15622:** Return true if zSql is a complete SQL statement.  Return false if it
        -:15623:** ends in the middle of a string literal or C-style comment.
        -:15624:*/
    #####:15625:static int line_is_complete(char *zSql, int nSql){
        -:15626:  int rc;
    #####:15627:  if( zSql==0 ) return 1;
    #####:15628:  zSql[nSql] = ';';
    #####:15629:  zSql[nSql+1] = 0;
    #####:15630:  rc = sqlite3_complete(zSql);
    #####:15631:  zSql[nSql] = 0;
    #####:15632:  return rc;
        -:15633:}
        -:15634:
        -:15635:/*
        -:15636:** Run a single line of SQL.  Return the number of errors.
        -:15637:*/
        2:15638:static int runOneSqlLine(ShellState *p, char *zSql, FILE *in, int startline){
        -:15639:  int rc;
        2:15640:  char *zErrMsg = 0;
        -:15641:
        2:15642:  open_db(p, 0);
       2*:15643:  if( ShellHasFlag(p,SHFLG_Backslash) ) resolve_backslashes(zSql);
        2:15644:  BEGIN_TIMER;
        2:15645:  rc = shell_exec(p, zSql, &zErrMsg);
        2:15646:  END_TIMER;
       2*:15647:  if( rc || zErrMsg ){
        -:15648:    char zPrefix[100];
        2:15649:    if( in!=0 || !stdin_is_interactive ){
    #####:15650:      sqlite3_snprintf(sizeof(zPrefix), zPrefix,
        -:15651:                       "Error: near line %d:", startline);
        -:15652:    }else{
        2:15653:      sqlite3_snprintf(sizeof(zPrefix), zPrefix, "Error:");
        -:15654:    }
        2:15655:    if( zErrMsg!=0 ){
        2:15656:      utf8_printf(stderr, "%s %s\n", zPrefix, zErrMsg);
        2:15657:      sqlite3_free(zErrMsg);
        2:15658:      zErrMsg = 0;
        -:15659:    }else{
    #####:15660:      utf8_printf(stderr, "%s %s\n", zPrefix, sqlite3_errmsg(p->db));
        -:15661:    }
        2:15662:    return 1;
    #####:15663:  }else if( ShellHasFlag(p, SHFLG_CountChanges) ){
    #####:15664:    raw_printf(p->out, "changes: %3d   total_changes: %d\n",
        -:15665:            sqlite3_changes(p->db), sqlite3_total_changes(p->db));
        -:15666:  }
    #####:15667:  return 0;
        -:15668:}
        -:15669:
        -:15670:
        -:15671:/*
        -:15672:** Read input from *in and process it.  If *in==0 then input
        -:15673:** is interactive - the user is typing it it.  Otherwise, input
        -:15674:** is coming from a file or device.  A prompt is issued and history
        -:15675:** is saved only if input is interactive.  An interrupt signal will
        -:15676:** cause this routine to exit immediately, unless input is interactive.
        -:15677:**
        -:15678:** Return the number of errors.
        -:15679:*/
        2:15680:static int process_input(ShellState *p, FILE *in){
        2:15681:  char *zLine = 0;          /* A single input line */
        2:15682:  char *zSql = 0;           /* Accumulated SQL text */
        -:15683:  int nLine;                /* Length of current line */
        2:15684:  int nSql = 0;             /* Bytes of zSql[] used */
        2:15685:  int nAlloc = 0;           /* Allocated zSql[] space */
        2:15686:  int nSqlPrior = 0;        /* Bytes of zSql[] used by prior line */
        -:15687:  int rc;                   /* Error code */
        2:15688:  int errCnt = 0;           /* Number of errors seen */
        2:15689:  int lineno = 0;           /* Current line number */
        2:15690:  int startline = 0;        /* Line number for start of current input */
        -:15691:
       4*:15692:  while( errCnt==0 || !bail_on_error || (in==0 && stdin_is_interactive) ){
        4:15693:    fflush(p->out);
        4:15694:    zLine = one_input_line(in, zLine, nSql>0);
        4:15695:    if( zLine==0 ){
        -:15696:      /* End of input */
    #####:15697:      if( in==0 && stdin_is_interactive ) printf("\n");
    #####:15698:      break;
        -:15699:    }
        4:15700:    if( seenInterrupt ){
    #####:15701:      if( in!=0 ) break;
    #####:15702:      seenInterrupt = 0;
        -:15703:    }
        4:15704:    lineno++;
       4*:15705:    if( nSql==0 && _all_whitespace(zLine) ){
    #####:15706:      if( ShellHasFlag(p, SHFLG_Echo) ) printf("%s\n", zLine);
    #####:15707:      continue;
        -:15708:    }
       4*:15709:    if( zLine && (zLine[0]=='.' || zLine[0]=='#') && nSql==0 ){
       2*:15710:      if( ShellHasFlag(p, SHFLG_Echo) ) printf("%s\n", zLine);
        2:15711:      if( zLine[0]=='.' ){
        2:15712:        rc = do_meta_command(zLine, p);
        2:15713:        if( rc==2 ){ /* exit requested */
        2:15714:          break;
    #####:15715:        }else if( rc ){
    #####:15716:          errCnt++;
        -:15717:        }
        -:15718:      }
    #####:15719:      continue;
        -:15720:    }
       2*:15721:    if( line_is_command_terminator(zLine) && line_is_complete(zSql, nSql) ){
    #####:15722:      memcpy(zLine,";",2);
        -:15723:    }
        2:15724:    nLine = strlen30(zLine);
        2:15725:    if( nSql+nLine+2>=nAlloc ){
        2:15726:      nAlloc = nSql+nLine+100;
        2:15727:      zSql = realloc(zSql, nAlloc);
       2*:15728:      if( zSql==0 ) shell_out_of_memory();
        -:15729:    }
        2:15730:    nSqlPrior = nSql;
        2:15731:    if( nSql==0 ){
        -:15732:      int i;
       2*:15733:      for(i=0; zLine[i] && IsSpace(zLine[i]); i++){}
        -:15734:      assert( nAlloc>0 && zSql!=0 );
        2:15735:      memcpy(zSql, zLine+i, nLine+1-i);
        2:15736:      startline = lineno;
        2:15737:      nSql = nLine-i;
        -:15738:    }else{
    #####:15739:      zSql[nSql++] = '\n';
    #####:15740:      memcpy(zSql+nSql, zLine, nLine+1);
    #####:15741:      nSql += nLine;
        -:15742:    }
        2:15743:    if( nSql && line_contains_semicolon(&zSql[nSqlPrior], nSql-nSqlPrior)
        2:15744:                && sqlite3_complete(zSql) ){
        2:15745:      errCnt += runOneSqlLine(p, zSql, in, startline);
        2:15746:      nSql = 0;
        2:15747:      if( p->outCount ){
    #####:15748:        output_reset(p);
    #####:15749:        p->outCount = 0;
        -:15750:      }else{
        2:15751:        clearTempFile(p);
        -:15752:      }
    #####:15753:    }else if( nSql && _all_whitespace(zSql) ){
    #####:15754:      if( ShellHasFlag(p, SHFLG_Echo) ) printf("%s\n", zSql);
    #####:15755:      nSql = 0;
        -:15756:    }
        -:15757:  }
       2*:15758:  if( nSql && !_all_whitespace(zSql) ){
    #####:15759:    errCnt += runOneSqlLine(p, zSql, in, startline);
        -:15760:  }
        2:15761:  free(zSql);
        2:15762:  free(zLine);
        2:15763:  return errCnt>0;
        -:15764:}
        -:15765:
        -:15766:/*
        -:15767:** Return a pathname which is the user's home directory.  A
        -:15768:** 0 return indicates an error of some kind.
        -:15769:*/
        6:15770:static char *find_home_dir(int clearFlag){
        -:15771:  static char *home_dir = NULL;
        6:15772:  if( clearFlag ){
        2:15773:    free(home_dir);
        2:15774:    home_dir = 0;
        2:15775:    return 0;
        -:15776:  }
        4:15777:  if( home_dir ) return home_dir;
        -:15778:
        -:15779:#if !defined(_WIN32) && !defined(WIN32) && !defined(_WIN32_WCE) \
        -:15780:     && !defined(__RTP__) && !defined(_WRS_KERNEL)
        -:15781:  {
        -:15782:    struct passwd *pwent;
        2:15783:    uid_t uid = getuid();
        2:15784:    if( (pwent=getpwuid(uid)) != NULL) {
        2:15785:      home_dir = pwent->pw_dir;
        -:15786:    }
        -:15787:  }
        -:15788:#endif
        -:15789:
        -:15790:#if defined(_WIN32_WCE)
        -:15791:  /* Windows CE (arm-wince-mingw32ce-gcc) does not provide getenv()
        -:15792:   */
        -:15793:  home_dir = "/";
        -:15794:#else
        -:15795:
        -:15796:#if defined(_WIN32) || defined(WIN32)
        -:15797:  if (!home_dir) {
        -:15798:    home_dir = getenv("USERPROFILE");
        -:15799:  }
        -:15800:#endif
        -:15801:
        2:15802:  if (!home_dir) {
    #####:15803:    home_dir = getenv("HOME");
        -:15804:  }
        -:15805:
        -:15806:#if defined(_WIN32) || defined(WIN32)
        -:15807:  if (!home_dir) {
        -:15808:    char *zDrive, *zPath;
        -:15809:    int n;
        -:15810:    zDrive = getenv("HOMEDRIVE");
        -:15811:    zPath = getenv("HOMEPATH");
        -:15812:    if( zDrive && zPath ){
        -:15813:      n = strlen30(zDrive) + strlen30(zPath) + 1;
        -:15814:      home_dir = malloc( n );
        -:15815:      if( home_dir==0 ) return 0;
        -:15816:      sqlite3_snprintf(n, home_dir, "%s%s", zDrive, zPath);
        -:15817:      return home_dir;
        -:15818:    }
        -:15819:    home_dir = "c:\\";
        -:15820:  }
        -:15821:#endif
        -:15822:
        -:15823:#endif /* !_WIN32_WCE */
        -:15824:
        2:15825:  if( home_dir ){
        2:15826:    int n = strlen30(home_dir) + 1;
        2:15827:    char *z = malloc( n );
        2:15828:    if( z ) memcpy(z, home_dir, n);
        2:15829:    home_dir = z;
        -:15830:  }
        -:15831:
        2:15832:  return home_dir;
        -:15833:}
        -:15834:
        -:15835:/*
        -:15836:** Read input from the file given by sqliterc_override.  Or if that
        -:15837:** parameter is NULL, take input from ~/.sqliterc
        -:15838:**
        -:15839:** Returns the number of errors.
        -:15840:*/
        2:15841:static void process_sqliterc(
        -:15842:  ShellState *p,                  /* Configuration data */
        -:15843:  const char *sqliterc_override   /* Name of config file. NULL to use default */
        -:15844:){
        2:15845:  char *home_dir = NULL;
        2:15846:  const char *sqliterc = sqliterc_override;
        2:15847:  char *zBuf = 0;
        2:15848:  FILE *in = NULL;
        -:15849:
        2:15850:  if (sqliterc == NULL) {
        2:15851:    home_dir = find_home_dir(0);
        2:15852:    if( home_dir==0 ){
    #####:15853:      raw_printf(stderr, "-- warning: cannot find home directory;"
        -:15854:                      " cannot read ~/.sqliterc\n");
    #####:15855:      return;
        -:15856:    }
        2:15857:    zBuf = sqlite3_mprintf("%s/.sqliterc",home_dir);
        2:15858:    sqliterc = zBuf;
        -:15859:  }
        2:15860:  in = fopen(sqliterc,"rb");
        2:15861:  if( in ){
    #####:15862:    if( stdin_is_interactive ){
    #####:15863:      utf8_printf(stderr,"-- Loading resources from %s\n",sqliterc);
        -:15864:    }
    #####:15865:    process_input(p,in);
    #####:15866:    fclose(in);
        -:15867:  }
        2:15868:  sqlite3_free(zBuf);
        -:15869:}
        -:15870:
        -:15871:/*
        -:15872:** Show available command line options
        -:15873:*/
        -:15874:static const char zOptions[] =
        -:15875:#if defined(SQLITE_HAVE_ZLIB) && !defined(SQLITE_OMIT_VIRTUALTABLE)
        -:15876:  "   -A ARGS...           run \".archive ARGS\" and exit\n"
        -:15877:#endif
        -:15878:  "   -append              append the database to the end of the file\n"
        -:15879:  "   -ascii               set output mode to 'ascii'\n"
        -:15880:  "   -bail                stop after hitting an error\n"
        -:15881:  "   -batch               force batch I/O\n"
        -:15882:  "   -column              set output mode to 'column'\n"
        -:15883:  "   -cmd COMMAND         run \"COMMAND\" before reading stdin\n"
        -:15884:  "   -csv                 set output mode to 'csv'\n"
        -:15885:  "   -echo                print commands before execution\n"
        -:15886:  "   -init FILENAME       read/process named file\n"
        -:15887:  "   -[no]header          turn headers on or off\n"
        -:15888:#if defined(SQLITE_ENABLE_MEMSYS3) || defined(SQLITE_ENABLE_MEMSYS5)
        -:15889:  "   -heap SIZE           Size of heap for memsys3 or memsys5\n"
        -:15890:#endif
        -:15891:  "   -help                show this message\n"
        -:15892:  "   -html                set output mode to HTML\n"
        -:15893:  "   -interactive         force interactive I/O\n"
        -:15894:  "   -line                set output mode to 'line'\n"
        -:15895:  "   -list                set output mode to 'list'\n"
        -:15896:  "   -lookaside SIZE N    use N entries of SZ bytes for lookaside memory\n"
        -:15897:  "   -mmap N              default mmap size set to N\n"
        -:15898:#ifdef SQLITE_ENABLE_MULTIPLEX
        -:15899:  "   -multiplex           enable the multiplexor VFS\n"
        -:15900:#endif
        -:15901:  "   -newline SEP         set output row separator. Default: '\\n'\n"
        -:15902:  "   -nullvalue TEXT      set text string for NULL values. Default ''\n"
        -:15903:  "   -pagecache SIZE N    use N slots of SZ bytes each for page cache memory\n"
        -:15904:  "   -quote               set output mode to 'quote'\n"
        -:15905:  "   -readonly            open the database read-only\n"
        -:15906:  "   -separator SEP       set output column separator. Default: '|'\n"
        -:15907:#ifdef SQLITE_ENABLE_SORTER_REFERENCES
        -:15908:  "   -sorterref SIZE      sorter references threshold size\n"
        -:15909:#endif
        -:15910:  "   -stats               print memory stats before each finalize\n"
        -:15911:  "   -version             show SQLite version\n"
        -:15912:  "   -vfs NAME            use NAME as the default VFS\n"
        -:15913:#ifdef SQLITE_ENABLE_VFSTRACE
        -:15914:  "   -vfstrace            enable tracing of all VFS calls\n"
        -:15915:#endif
        -:15916:#ifdef SQLITE_HAVE_ZLIB
        -:15917:  "   -zip                 open the file as a ZIP Archive\n"
        -:15918:#endif
        -:15919:;
    #####:15920:static void usage(int showDetail){
    #####:15921:  utf8_printf(stderr,
        -:15922:      "Usage: %s [OPTIONS] FILENAME [SQL]\n"
        -:15923:      "FILENAME is the name of an SQLite database. A new database is created\n"
        -:15924:      "if the file does not previously exist.\n", Argv0);
    #####:15925:  if( showDetail ){
    #####:15926:    utf8_printf(stderr, "OPTIONS include:\n%s", zOptions);
        -:15927:  }else{
    #####:15928:    raw_printf(stderr, "Use the -help option for additional information\n");
        -:15929:  }
    #####:15930:  exit(1);
        -:15931:}
        -:15932:
        -:15933:/*
        -:15934:** Internal check:  Verify that the SQLite is uninitialized.  Print a
        -:15935:** error message if it is initialized.
        -:15936:*/
        6:15937:static void verify_uninitialized(void){
        6:15938:  if( sqlite3_config(-1)==SQLITE_MISUSE ){
    #####:15939:    utf8_printf(stdout, "WARNING: attempt to configure SQLite after"
        -:15940:                        " initialization.\n");
        -:15941:  }
        6:15942:}
        -:15943:
        -:15944:/*
        -:15945:** Initialize the state information in data
        -:15946:*/
        2:15947:static void main_init(ShellState *data) {
        2:15948:  memset(data, 0, sizeof(*data));
        2:15949:  data->normalMode = data->cMode = data->mode = MODE_List;
        2:15950:  data->autoExplain = 1;
        2:15951:  memcpy(data->colSeparator,SEP_Column, 2);
        2:15952:  memcpy(data->rowSeparator,SEP_Row, 2);
        2:15953:  data->showHeader = 0;
        2:15954:  data->shellFlgs = SHFLG_Lookaside;
        2:15955:  verify_uninitialized();
        2:15956:  sqlite3_config(SQLITE_CONFIG_URI, 1);
        2:15957:  sqlite3_config(SQLITE_CONFIG_LOG, shellLog, data);
        2:15958:  sqlite3_config(SQLITE_CONFIG_MULTITHREAD);
        2:15959:  sqlite3_snprintf(sizeof(mainPrompt), mainPrompt,"sqlite> ");
        2:15960:  sqlite3_snprintf(sizeof(continuePrompt), continuePrompt,"   ...> ");
        2:15961:}
        -:15962:
        -:15963:/*
        -:15964:** Output text to the console in a font that attracts extra attention.
        -:15965:*/
        -:15966:#ifdef _WIN32
        -:15967:static void printBold(const char *zText){
        -:15968:  HANDLE out = GetStdHandle(STD_OUTPUT_HANDLE);
        -:15969:  CONSOLE_SCREEN_BUFFER_INFO defaultScreenInfo;
        -:15970:  GetConsoleScreenBufferInfo(out, &defaultScreenInfo);
        -:15971:  SetConsoleTextAttribute(out,
        -:15972:         FOREGROUND_RED|FOREGROUND_INTENSITY
        -:15973:  );
        -:15974:  printf("%s", zText);
        -:15975:  SetConsoleTextAttribute(out, defaultScreenInfo.wAttributes);
        -:15976:}
        -:15977:#else
        2:15978:static void printBold(const char *zText){
        2:15979:  printf("\033[1m%s\033[0m", zText);
        2:15980:}
        -:15981:#endif
        -:15982:
        -:15983:/*
        -:15984:** Get the argument to an --option.  Throw an error and die if no argument
        -:15985:** is available.
        -:15986:*/
    #####:15987:static char *cmdline_option_value(int argc, char **argv, int i){
    #####:15988:  if( i==argc ){
    #####:15989:    utf8_printf(stderr, "%s: Error: missing argument to %s\n",
    #####:15990:            argv[0], argv[argc-1]);
    #####:15991:    exit(1);
        -:15992:  }
    #####:15993:  return argv[i];
        -:15994:}
        -:15995:
        -:15996:#ifndef SQLITE_SHELL_IS_UTF8
        -:15997:#  if (defined(_WIN32) || defined(WIN32)) && defined(_MSC_VER)
        -:15998:#    define SQLITE_SHELL_IS_UTF8          (0)
        -:15999:#  else
        -:16000:#    define SQLITE_SHELL_IS_UTF8          (1)
        -:16001:#  endif
        -:16002:#endif
        -:16003:
        -:16004:#if SQLITE_SHELL_IS_UTF8
        2:16005:int SQLITE_CDECL main(int argc, char **argv){
        -:16006:#else
        -:16007:int SQLITE_CDECL wmain(int argc, wchar_t **wargv){
        -:16008:  char **argv;
        -:16009:#endif
        2:16010:  char *zErrMsg = 0;
        -:16011:  ShellState data;
        2:16012:  const char *zInitFile = 0;
        -:16013:  int i;
        2:16014:  int rc = 0;
        2:16015:  int warnInmemoryDb = 0;
        2:16016:  int readStdin = 1;
        2:16017:  int nCmd = 0;
        2:16018:  char **azCmd = 0;
        2:16019:  const char *zVfs = 0;           /* Value of -vfs command-line option */
        -:16020:#if !SQLITE_SHELL_IS_UTF8
        -:16021:  char **argvToFree = 0;
        -:16022:  int argcToFree = 0;
        -:16023:#endif
        -:16024:
        -:16025:  setBinaryMode(stdin, 0);
        2:16026:  setvbuf(stderr, 0, _IONBF, 0); /* Make sure stderr is unbuffered */
        2:16027:  stdin_is_interactive = isatty(0);
        2:16028:  stdout_is_console = isatty(1);
        -:16029:
        -:16030:#if !defined(_WIN32_WCE)
        2:16031:  if( getenv("SQLITE_DEBUG_BREAK") ){
    #####:16032:    if( isatty(0) && isatty(2) ){
    #####:16033:      fprintf(stderr,
        -:16034:          "attach debugger to process %d and press any key to continue.\n",
        -:16035:          GETPID());
    #####:16036:      fgetc(stdin);
        -:16037:    }else{
        -:16038:#if defined(_WIN32) || defined(WIN32)
        -:16039:      DebugBreak();
        -:16040:#elif defined(SIGTRAP)
    #####:16041:      raise(SIGTRAP);
        -:16042:#endif
        -:16043:    }
        -:16044:  }
        -:16045:#endif
        -:16046:
        -:16047:#if USE_SYSTEM_SQLITE+0!=1
        2:16048:  if( strncmp(sqlite3_sourceid(),SQLITE_SOURCE_ID,60)!=0 ){
    #####:16049:    utf8_printf(stderr, "SQLite header and source version mismatch\n%s\n%s\n",
        -:16050:            sqlite3_sourceid(), SQLITE_SOURCE_ID);
    #####:16051:    exit(1);
        -:16052:  }
        -:16053:#endif
        2:16054:  main_init(&data);
        -:16055:
        -:16056:  /* On Windows, we must translate command-line arguments into UTF-8.
        -:16057:  ** The SQLite memory allocator subsystem has to be enabled in order to
        -:16058:  ** do this.  But we want to run an sqlite3_shutdown() afterwards so that
        -:16059:  ** subsequent sqlite3_config() calls will work.  So copy all results into
        -:16060:  ** memory that does not come from the SQLite memory allocator.
        -:16061:  */
        -:16062:#if !SQLITE_SHELL_IS_UTF8
        -:16063:  sqlite3_initialize();
        -:16064:  argvToFree = malloc(sizeof(argv[0])*argc*2);
        -:16065:  argcToFree = argc;
        -:16066:  argv = argvToFree + argc;
        -:16067:  if( argv==0 ) shell_out_of_memory();
        -:16068:  for(i=0; i<argc; i++){
        -:16069:    char *z = sqlite3_win32_unicode_to_utf8(wargv[i]);
        -:16070:    int n;
        -:16071:    if( z==0 ) shell_out_of_memory();
        -:16072:    n = (int)strlen(z);
        -:16073:    argv[i] = malloc( n+1 );
        -:16074:    if( argv[i]==0 ) shell_out_of_memory();
        -:16075:    memcpy(argv[i], z, n+1);
        -:16076:    argvToFree[i] = argv[i];
        -:16077:    sqlite3_free(z);
        -:16078:  }
        -:16079:  sqlite3_shutdown();
        -:16080:#endif
        -:16081:
        -:16082:  assert( argc>=1 && argv && argv[0] );
        2:16083:  Argv0 = argv[0];
        -:16084:
        -:16085:  /* Make sure we have a valid signal handler early, before anything
        -:16086:  ** else is done.
        -:16087:  */
        -:16088:#ifdef SIGINT
        2:16089:  signal(SIGINT, interrupt_handler);
        -:16090:#elif (defined(_WIN32) || defined(WIN32)) && !defined(_WIN32_WCE)
        -:16091:  SetConsoleCtrlHandler(ConsoleCtrlHandler, TRUE);
        -:16092:#endif
        -:16093:
        -:16094:#ifdef SQLITE_SHELL_DBNAME_PROC
        -:16095:  {
        -:16096:    /* If the SQLITE_SHELL_DBNAME_PROC macro is defined, then it is the name
        -:16097:    ** of a C-function that will provide the name of the database file.  Use
        -:16098:    ** this compile-time option to embed this shell program in larger
        -:16099:    ** applications. */
        -:16100:    extern void SQLITE_SHELL_DBNAME_PROC(const char**);
        -:16101:    SQLITE_SHELL_DBNAME_PROC(&data.zDbFilename);
        -:16102:    warnInmemoryDb = 0;
        -:16103:  }
        -:16104:#endif
        -:16105:
        -:16106:  /* Do an initial pass through the command-line argument to locate
        -:16107:  ** the name of the database file, the name of the initialization file,
        -:16108:  ** the size of the alternative malloc heap,
        -:16109:  ** and the first command to execute.
        -:16110:  */
        2:16111:  verify_uninitialized();
       2*:16112:  for(i=1; i<argc; i++){
        -:16113:    char *z;
    #####:16114:    z = argv[i];
    #####:16115:    if( z[0]!='-' ){
    #####:16116:      if( data.zDbFilename==0 ){
    #####:16117:        data.zDbFilename = z;
        -:16118:      }else{
        -:16119:        /* Excesss arguments are interpreted as SQL (or dot-commands) and
        -:16120:        ** mean that nothing is read from stdin */
    #####:16121:        readStdin = 0;
    #####:16122:        nCmd++;
    #####:16123:        azCmd = realloc(azCmd, sizeof(azCmd[0])*nCmd);
    #####:16124:        if( azCmd==0 ) shell_out_of_memory();
    #####:16125:        azCmd[nCmd-1] = z;
        -:16126:      }
        -:16127:    }
    #####:16128:    if( z[1]=='-' ) z++;
    #####:16129:    if( strcmp(z,"-separator")==0
    #####:16130:     || strcmp(z,"-nullvalue")==0
    #####:16131:     || strcmp(z,"-newline")==0
    #####:16132:     || strcmp(z,"-cmd")==0
        -:16133:    ){
    #####:16134:      (void)cmdline_option_value(argc, argv, ++i);
    #####:16135:    }else if( strcmp(z,"-init")==0 ){
    #####:16136:      zInitFile = cmdline_option_value(argc, argv, ++i);
    #####:16137:    }else if( strcmp(z,"-batch")==0 ){
        -:16138:      /* Need to check for batch mode here to so we can avoid printing
        -:16139:      ** informational messages (like from process_sqliterc) before
        -:16140:      ** we do the actual processing of arguments later in a second pass.
        -:16141:      */
    #####:16142:      stdin_is_interactive = 0;
    #####:16143:    }else if( strcmp(z,"-heap")==0 ){
        -:16144:#if defined(SQLITE_ENABLE_MEMSYS3) || defined(SQLITE_ENABLE_MEMSYS5)
        -:16145:      const char *zSize;
        -:16146:      sqlite3_int64 szHeap;
        -:16147:
        -:16148:      zSize = cmdline_option_value(argc, argv, ++i);
        -:16149:      szHeap = integerValue(zSize);
        -:16150:      if( szHeap>0x7fff0000 ) szHeap = 0x7fff0000;
        -:16151:      sqlite3_config(SQLITE_CONFIG_HEAP, malloc((int)szHeap), (int)szHeap, 64);
        -:16152:#else
    #####:16153:      (void)cmdline_option_value(argc, argv, ++i);
        -:16154:#endif
    #####:16155:    }else if( strcmp(z,"-pagecache")==0 ){
        -:16156:      int n, sz;
    #####:16157:      sz = (int)integerValue(cmdline_option_value(argc,argv,++i));
    #####:16158:      if( sz>70000 ) sz = 70000;
    #####:16159:      if( sz<0 ) sz = 0;
    #####:16160:      n = (int)integerValue(cmdline_option_value(argc,argv,++i));
    #####:16161:      sqlite3_config(SQLITE_CONFIG_PAGECACHE,
    #####:16162:                    (n>0 && sz>0) ? malloc(n*sz) : 0, sz, n);
    #####:16163:      data.shellFlgs |= SHFLG_Pagecache;
    #####:16164:    }else if( strcmp(z,"-lookaside")==0 ){
        -:16165:      int n, sz;
    #####:16166:      sz = (int)integerValue(cmdline_option_value(argc,argv,++i));
    #####:16167:      if( sz<0 ) sz = 0;
    #####:16168:      n = (int)integerValue(cmdline_option_value(argc,argv,++i));
    #####:16169:      if( n<0 ) n = 0;
    #####:16170:      sqlite3_config(SQLITE_CONFIG_LOOKASIDE, sz, n);
    #####:16171:      if( sz*n==0 ) data.shellFlgs &= ~SHFLG_Lookaside;
        -:16172:#ifdef SQLITE_ENABLE_VFSTRACE
        -:16173:    }else if( strcmp(z,"-vfstrace")==0 ){
        -:16174:      extern int vfstrace_register(
        -:16175:         const char *zTraceName,
        -:16176:         const char *zOldVfsName,
        -:16177:         int (*xOut)(const char*,void*),
        -:16178:         void *pOutArg,
        -:16179:         int makeDefault
        -:16180:      );
        -:16181:      vfstrace_register("trace",0,(int(*)(const char*,void*))fputs,stderr,1);
        -:16182:#endif
        -:16183:#ifdef SQLITE_ENABLE_MULTIPLEX
        -:16184:    }else if( strcmp(z,"-multiplex")==0 ){
        -:16185:      extern int sqlite3_multiple_initialize(const char*,int);
        -:16186:      sqlite3_multiplex_initialize(0, 1);
        -:16187:#endif
    #####:16188:    }else if( strcmp(z,"-mmap")==0 ){
    #####:16189:      sqlite3_int64 sz = integerValue(cmdline_option_value(argc,argv,++i));
    #####:16190:      sqlite3_config(SQLITE_CONFIG_MMAP_SIZE, sz, sz);
        -:16191:#ifdef SQLITE_ENABLE_SORTER_REFERENCES
        -:16192:    }else if( strcmp(z,"-sorterref")==0 ){
        -:16193:      sqlite3_int64 sz = integerValue(cmdline_option_value(argc,argv,++i));
        -:16194:      sqlite3_config(SQLITE_CONFIG_SORTERREF_SIZE, (int)sz);
        -:16195:#endif
    #####:16196:    }else if( strcmp(z,"-vfs")==0 ){
    #####:16197:      zVfs = cmdline_option_value(argc, argv, ++i);
        -:16198:#ifdef SQLITE_HAVE_ZLIB
    #####:16199:    }else if( strcmp(z,"-zip")==0 ){
    #####:16200:      data.openMode = SHELL_OPEN_ZIPFILE;
        -:16201:#endif
    #####:16202:    }else if( strcmp(z,"-append")==0 ){
    #####:16203:      data.openMode = SHELL_OPEN_APPENDVFS;
        -:16204:#ifdef SQLITE_ENABLE_DESERIALIZE
    #####:16205:    }else if( strcmp(z,"-deserialize")==0 ){
    #####:16206:      data.openMode = SHELL_OPEN_DESERIALIZE;
        -:16207:#endif
    #####:16208:    }else if( strcmp(z,"-readonly")==0 ){
    #####:16209:      data.openMode = SHELL_OPEN_READONLY;
        -:16210:#if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_HAVE_ZLIB)
    #####:16211:    }else if( strncmp(z, "-A",2)==0 ){
        -:16212:      /* All remaining command-line arguments are passed to the ".archive"
        -:16213:      ** command, so ignore them */
    #####:16214:      break;
        -:16215:#endif
        -:16216:    }
        -:16217:  }
        2:16218:  verify_uninitialized();
        -:16219:
        -:16220:
        -:16221:#ifdef SQLITE_SHELL_INIT_PROC
        -:16222:  {
        -:16223:    /* If the SQLITE_SHELL_INIT_PROC macro is defined, then it is the name
        -:16224:    ** of a C-function that will perform initialization actions on SQLite that
        -:16225:    ** occur just before or after sqlite3_initialize(). Use this compile-time
        -:16226:    ** option to embed this shell program in larger applications. */
        -:16227:    extern void SQLITE_SHELL_INIT_PROC(void);
        -:16228:    SQLITE_SHELL_INIT_PROC();
        -:16229:  }
        -:16230:#else
        -:16231:  /* All the sqlite3_config() calls have now been made. So it is safe
        -:16232:  ** to call sqlite3_initialize() and process any command line -vfs option. */
        2:16233:  sqlite3_initialize();
        -:16234:#endif
        -:16235:
        2:16236:  if( zVfs ){
    #####:16237:    sqlite3_vfs *pVfs = sqlite3_vfs_find(zVfs);
    #####:16238:    if( pVfs ){
    #####:16239:      sqlite3_vfs_register(pVfs, 1);
        -:16240:    }else{
    #####:16241:      utf8_printf(stderr, "no such VFS: \"%s\"\n", argv[i]);
    #####:16242:      exit(1);
        -:16243:    }
        -:16244:  }
        -:16245:
        2:16246:  if( data.zDbFilename==0 ){
        -:16247:#ifndef SQLITE_OMIT_MEMORYDB
        2:16248:    data.zDbFilename = ":memory:";
        2:16249:    warnInmemoryDb = argc==1;
        -:16250:#else
        -:16251:    utf8_printf(stderr,"%s: Error: no database filename specified\n", Argv0);
        -:16252:    return 1;
        -:16253:#endif
        -:16254:  }
        2:16255:  data.out = stdout;
        2:16256:  sqlite3_appendvfs_init(0,0,0);
        -:16257:
        -:16258:  /* Go ahead and open the database file if it already exists.  If the
        -:16259:  ** file does not exist, delay opening it.  This prevents empty database
        -:16260:  ** files from being created if a user mistypes the database name argument
        -:16261:  ** to the sqlite command-line tool.
        -:16262:  */
        2:16263:  if( access(data.zDbFilename, 0)==0 ){
    #####:16264:    open_db(&data, 0);
        -:16265:  }
        -:16266:
        -:16267:  /* Process the initialization file if there is one.  If no -init option
        -:16268:  ** is given on the command line, look for a file named ~/.sqliterc and
        -:16269:  ** try to process it.
        -:16270:  */
        2:16271:  process_sqliterc(&data,zInitFile);
        -:16272:
        -:16273:  /* Make a second pass through the command-line argument and set
        -:16274:  ** options.  This second pass is delayed until after the initialization
        -:16275:  ** file is processed so that the command-line arguments will override
        -:16276:  ** settings in the initialization file.
        -:16277:  */
       2*:16278:  for(i=1; i<argc; i++){
    #####:16279:    char *z = argv[i];
    #####:16280:    if( z[0]!='-' ) continue;
    #####:16281:    if( z[1]=='-' ){ z++; }
    #####:16282:    if( strcmp(z,"-init")==0 ){
    #####:16283:      i++;
    #####:16284:    }else if( strcmp(z,"-html")==0 ){
    #####:16285:      data.mode = MODE_Html;
    #####:16286:    }else if( strcmp(z,"-list")==0 ){
    #####:16287:      data.mode = MODE_List;
    #####:16288:    }else if( strcmp(z,"-quote")==0 ){
    #####:16289:      data.mode = MODE_Quote;
    #####:16290:    }else if( strcmp(z,"-line")==0 ){
    #####:16291:      data.mode = MODE_Line;
    #####:16292:    }else if( strcmp(z,"-column")==0 ){
    #####:16293:      data.mode = MODE_Column;
    #####:16294:    }else if( strcmp(z,"-csv")==0 ){
    #####:16295:      data.mode = MODE_Csv;
    #####:16296:      memcpy(data.colSeparator,",",2);
        -:16297:#ifdef SQLITE_HAVE_ZLIB
    #####:16298:    }else if( strcmp(z,"-zip")==0 ){
    #####:16299:      data.openMode = SHELL_OPEN_ZIPFILE;
        -:16300:#endif
    #####:16301:    }else if( strcmp(z,"-append")==0 ){
    #####:16302:      data.openMode = SHELL_OPEN_APPENDVFS;
        -:16303:#ifdef SQLITE_ENABLE_DESERIALIZE
    #####:16304:    }else if( strcmp(z,"-deserialize")==0 ){
    #####:16305:      data.openMode = SHELL_OPEN_DESERIALIZE;
        -:16306:#endif
    #####:16307:    }else if( strcmp(z,"-readonly")==0 ){
    #####:16308:      data.openMode = SHELL_OPEN_READONLY;
    #####:16309:    }else if( strcmp(z,"-ascii")==0 ){
    #####:16310:      data.mode = MODE_Ascii;
    #####:16311:      sqlite3_snprintf(sizeof(data.colSeparator), data.colSeparator,
        -:16312:                       SEP_Unit);
    #####:16313:      sqlite3_snprintf(sizeof(data.rowSeparator), data.rowSeparator,
        -:16314:                       SEP_Record);
    #####:16315:    }else if( strcmp(z,"-separator")==0 ){
    #####:16316:      sqlite3_snprintf(sizeof(data.colSeparator), data.colSeparator,
        -:16317:                       "%s",cmdline_option_value(argc,argv,++i));
    #####:16318:    }else if( strcmp(z,"-newline")==0 ){
    #####:16319:      sqlite3_snprintf(sizeof(data.rowSeparator), data.rowSeparator,
        -:16320:                       "%s",cmdline_option_value(argc,argv,++i));
    #####:16321:    }else if( strcmp(z,"-nullvalue")==0 ){
    #####:16322:      sqlite3_snprintf(sizeof(data.nullValue), data.nullValue,
        -:16323:                       "%s",cmdline_option_value(argc,argv,++i));
    #####:16324:    }else if( strcmp(z,"-header")==0 ){
    #####:16325:      data.showHeader = 1;
    #####:16326:    }else if( strcmp(z,"-noheader")==0 ){
    #####:16327:      data.showHeader = 0;
    #####:16328:    }else if( strcmp(z,"-echo")==0 ){
    #####:16329:      ShellSetFlag(&data, SHFLG_Echo);
    #####:16330:    }else if( strcmp(z,"-eqp")==0 ){
    #####:16331:      data.autoEQP = AUTOEQP_on;
    #####:16332:    }else if( strcmp(z,"-eqpfull")==0 ){
    #####:16333:      data.autoEQP = AUTOEQP_full;
    #####:16334:    }else if( strcmp(z,"-stats")==0 ){
    #####:16335:      data.statsOn = 1;
    #####:16336:    }else if( strcmp(z,"-scanstats")==0 ){
    #####:16337:      data.scanstatsOn = 1;
    #####:16338:    }else if( strcmp(z,"-backslash")==0 ){
        -:16339:      /* Undocumented command-line option: -backslash
        -:16340:      ** Causes C-style backslash escapes to be evaluated in SQL statements
        -:16341:      ** prior to sending the SQL into SQLite.  Useful for injecting
        -:16342:      ** crazy bytes in the middle of SQL statements for testing and debugging.
        -:16343:      */
    #####:16344:      ShellSetFlag(&data, SHFLG_Backslash);
    #####:16345:    }else if( strcmp(z,"-bail")==0 ){
    #####:16346:      bail_on_error = 1;
    #####:16347:    }else if( strcmp(z,"-version")==0 ){
    #####:16348:      printf("%s %s\n", sqlite3_libversion(), sqlite3_sourceid());
    #####:16349:      return 0;
    #####:16350:    }else if( strcmp(z,"-interactive")==0 ){
    #####:16351:      stdin_is_interactive = 1;
    #####:16352:    }else if( strcmp(z,"-batch")==0 ){
    #####:16353:      stdin_is_interactive = 0;
    #####:16354:    }else if( strcmp(z,"-heap")==0 ){
    #####:16355:      i++;
    #####:16356:    }else if( strcmp(z,"-pagecache")==0 ){
    #####:16357:      i+=2;
    #####:16358:    }else if( strcmp(z,"-lookaside")==0 ){
    #####:16359:      i+=2;
    #####:16360:    }else if( strcmp(z,"-mmap")==0 ){
    #####:16361:      i++;
        -:16362:#ifdef SQLITE_ENABLE_SORTER_REFERENCES
        -:16363:    }else if( strcmp(z,"-sorterref")==0 ){
        -:16364:      i++;
        -:16365:#endif
    #####:16366:    }else if( strcmp(z,"-vfs")==0 ){
    #####:16367:      i++;
        -:16368:#ifdef SQLITE_ENABLE_VFSTRACE
        -:16369:    }else if( strcmp(z,"-vfstrace")==0 ){
        -:16370:      i++;
        -:16371:#endif
        -:16372:#ifdef SQLITE_ENABLE_MULTIPLEX
        -:16373:    }else if( strcmp(z,"-multiplex")==0 ){
        -:16374:      i++;
        -:16375:#endif
    #####:16376:    }else if( strcmp(z,"-help")==0 ){
    #####:16377:      usage(1);
    #####:16378:    }else if( strcmp(z,"-cmd")==0 ){
        -:16379:      /* Run commands that follow -cmd first and separately from commands
        -:16380:      ** that simply appear on the command-line.  This seems goofy.  It would
        -:16381:      ** be better if all commands ran in the order that they appear.  But
        -:16382:      ** we retain the goofy behavior for historical compatibility. */
    #####:16383:      if( i==argc-1 ) break;
    #####:16384:      z = cmdline_option_value(argc,argv,++i);
    #####:16385:      if( z[0]=='.' ){
    #####:16386:        rc = do_meta_command(z, &data);
    #####:16387:        if( rc && bail_on_error ) return rc==2 ? 0 : rc;
        -:16388:      }else{
    #####:16389:        open_db(&data, 0);
    #####:16390:        rc = shell_exec(&data, z, &zErrMsg);
    #####:16391:        if( zErrMsg!=0 ){
    #####:16392:          utf8_printf(stderr,"Error: %s\n", zErrMsg);
    #####:16393:          if( bail_on_error ) return rc!=0 ? rc : 1;
    #####:16394:        }else if( rc!=0 ){
    #####:16395:          utf8_printf(stderr,"Error: unable to process SQL \"%s\"\n", z);
    #####:16396:          if( bail_on_error ) return rc;
        -:16397:        }
        -:16398:      }
        -:16399:#if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_HAVE_ZLIB)
    #####:16400:    }else if( strncmp(z, "-A", 2)==0 ){
    #####:16401:      if( nCmd>0 ){
    #####:16402:        utf8_printf(stderr, "Error: cannot mix regular SQL or dot-commands"
        -:16403:                            " with \"%s\"\n", z);
    #####:16404:        return 1;
        -:16405:      }
    #####:16406:      open_db(&data, OPEN_DB_ZIPFILE);
    #####:16407:      if( z[2] ){
    #####:16408:        argv[i] = &z[2];
    #####:16409:        arDotCommand(&data, 1, argv+(i-1), argc-(i-1));
        -:16410:      }else{
    #####:16411:        arDotCommand(&data, 1, argv+i, argc-i);
        -:16412:      }
    #####:16413:      readStdin = 0;
    #####:16414:      break;
        -:16415:#endif
        -:16416:    }else{
    #####:16417:      utf8_printf(stderr,"%s: Error: unknown option: %s\n", Argv0, z);
    #####:16418:      raw_printf(stderr,"Use -help for a list of options.\n");
    #####:16419:      return 1;
        -:16420:    }
    #####:16421:    data.cMode = data.mode;
        -:16422:  }
        -:16423:
        2:16424:  if( !readStdin ){
        -:16425:    /* Run all arguments that do not begin with '-' as if they were separate
        -:16426:    ** command-line inputs, except for the argToSkip argument which contains
        -:16427:    ** the database filename.
        -:16428:    */
    #####:16429:    for(i=0; i<nCmd; i++){
    #####:16430:      if( azCmd[i][0]=='.' ){
    #####:16431:        rc = do_meta_command(azCmd[i], &data);
    #####:16432:        if( rc ) return rc==2 ? 0 : rc;
        -:16433:      }else{
    #####:16434:        open_db(&data, 0);
    #####:16435:        rc = shell_exec(&data, azCmd[i], &zErrMsg);
    #####:16436:        if( zErrMsg!=0 ){
    #####:16437:          utf8_printf(stderr,"Error: %s\n", zErrMsg);
    #####:16438:          return rc!=0 ? rc : 1;
    #####:16439:        }else if( rc!=0 ){
    #####:16440:          utf8_printf(stderr,"Error: unable to process SQL: %s\n", azCmd[i]);
    #####:16441:          return rc;
        -:16442:        }
        -:16443:      }
        -:16444:    }
    #####:16445:    free(azCmd);
        -:16446:  }else{
        -:16447:    /* Run commands received from standard input
        -:16448:    */
        2:16449:    if( stdin_is_interactive ){
        -:16450:      char *zHome;
        -:16451:      char *zHistory;
        -:16452:      int nHistory;
        2:16453:      printf(
        -:16454:        "SQLite version %s %.19s\n" /*extra-version-info*/
        -:16455:        "Enter \".help\" for usage hints.\n",
        -:16456:        sqlite3_libversion(), sqlite3_sourceid()
        -:16457:      );
        2:16458:      if( warnInmemoryDb ){
        2:16459:        printf("Connected to a ");
        2:16460:        printBold("transient in-memory database");
        2:16461:        printf(".\nUse \".open FILENAME\" to reopen on a "
        -:16462:               "persistent database.\n");
        -:16463:      }
        2:16464:      zHistory = getenv("SQLITE_HISTORY");
        2:16465:      if( zHistory ){
    #####:16466:        zHistory = strdup(zHistory);
        2:16467:      }else if( (zHome = find_home_dir(0))!=0 ){
        2:16468:        nHistory = strlen30(zHome) + 20;
        2:16469:        if( (zHistory = malloc(nHistory))!=0 ){
        2:16470:          sqlite3_snprintf(nHistory, zHistory,"%s/.sqlite_history", zHome);
        -:16471:        }
        -:16472:      }
        -:16473:      if( zHistory ){ shell_read_history(zHistory); }
        -:16474:#if HAVE_READLINE || HAVE_EDITLINE
        -:16475:      rl_attempted_completion_function = readline_completion;
        -:16476:#elif HAVE_LINENOISE
        -:16477:      linenoiseSetCompletionCallback(linenoise_completion);
        -:16478:#endif
        2:16479:      rc = process_input(&data, 0);
        2:16480:      if( zHistory ){
        -:16481:        shell_stifle_history(2000);
        -:16482:        shell_write_history(zHistory);
        2:16483:        free(zHistory);
        -:16484:      }
        -:16485:    }else{
    #####:16486:      rc = process_input(&data, stdin);
        -:16487:    }
        -:16488:  }
        2:16489:  set_table_name(&data, 0);
        2:16490:  if( data.db ){
        -:16491:    session_close_all(&data);
        2:16492:    close_db(data.db);
        -:16493:  }
        2:16494:  sqlite3_free(data.zFreeOnClose);
        2:16495:  find_home_dir(1);
        2:16496:  output_reset(&data);
        2:16497:  data.doXdgOpen = 0;
        2:16498:  clearTempFile(&data);
        -:16499:#if !SQLITE_SHELL_IS_UTF8
        -:16500:  for(i=0; i<argcToFree; i++) free(argvToFree[i]);
        -:16501:  free(argvToFree);
        -:16502:#endif
        -:16503:  /* Clear the global data structure so that valgrind will detect memory
        -:16504:  ** leaks */
        2:16505:  memset(&data, 0, sizeof(data));
        2:16506:  return rc;
        -:16507:}
